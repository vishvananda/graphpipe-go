// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/autotuning.proto

package for_core_protos_go_proto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AutotuneResult_FailureKind int32

const (
	AutotuneResult_UNKNOWN          AutotuneResult_FailureKind = 0
	AutotuneResult_REDZONE_MODIFIED AutotuneResult_FailureKind = 1
	AutotuneResult_WRONG_RESULT     AutotuneResult_FailureKind = 2
)

var AutotuneResult_FailureKind_name = map[int32]string{
	0: "UNKNOWN",
	1: "REDZONE_MODIFIED",
	2: "WRONG_RESULT",
}

var AutotuneResult_FailureKind_value = map[string]int32{
	"UNKNOWN":          0,
	"REDZONE_MODIFIED": 1,
	"WRONG_RESULT":     2,
}

func (x AutotuneResult_FailureKind) String() string {
	return proto.EnumName(AutotuneResult_FailureKind_name, int32(x))
}

func (AutotuneResult_FailureKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f61248520e180396, []int{2, 0}
}

type CudnnVersion struct {
	Major                int32    `protobuf:"varint,1,opt,name=major,proto3" json:"major,omitempty"`
	Minor                int32    `protobuf:"varint,2,opt,name=minor,proto3" json:"minor,omitempty"`
	Patch                int32    `protobuf:"varint,3,opt,name=patch,proto3" json:"patch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CudnnVersion) Reset()         { *m = CudnnVersion{} }
func (m *CudnnVersion) String() string { return proto.CompactTextString(m) }
func (*CudnnVersion) ProtoMessage()    {}
func (*CudnnVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_f61248520e180396, []int{0}
}
func (m *CudnnVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CudnnVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CudnnVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CudnnVersion.Merge(m, src)
}
func (m *CudnnVersion) XXX_Size() int {
	return m.Size()
}
func (m *CudnnVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_CudnnVersion.DiscardUnknown(m)
}

var xxx_messageInfo_CudnnVersion proto.InternalMessageInfo

func (m *CudnnVersion) GetMajor() int32 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *CudnnVersion) GetMinor() int32 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *CudnnVersion) GetPatch() int32 {
	if m != nil {
		return m.Patch
	}
	return 0
}

type ComputeCapability struct {
	Major                int32    `protobuf:"varint,1,opt,name=major,proto3" json:"major,omitempty"`
	Minor                int32    `protobuf:"varint,2,opt,name=minor,proto3" json:"minor,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComputeCapability) Reset()         { *m = ComputeCapability{} }
func (m *ComputeCapability) String() string { return proto.CompactTextString(m) }
func (*ComputeCapability) ProtoMessage()    {}
func (*ComputeCapability) Descriptor() ([]byte, []int) {
	return fileDescriptor_f61248520e180396, []int{1}
}
func (m *ComputeCapability) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComputeCapability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ComputeCapability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputeCapability.Merge(m, src)
}
func (m *ComputeCapability) XXX_Size() int {
	return m.Size()
}
func (m *ComputeCapability) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputeCapability.DiscardUnknown(m)
}

var xxx_messageInfo_ComputeCapability proto.InternalMessageInfo

func (m *ComputeCapability) GetMajor() int32 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *ComputeCapability) GetMinor() int32 {
	if m != nil {
		return m.Minor
	}
	return 0
}

type AutotuneResult struct {
	ScratchBytes int64                         `protobuf:"varint,8,opt,name=scratch_bytes,json=scratchBytes,proto3" json:"scratch_bytes,omitempty"`
	RunTime      *types.Duration               `protobuf:"bytes,9,opt,name=run_time,json=runTime,proto3" json:"run_time,omitempty"`
	Failure      *AutotuneResult_FailureResult `protobuf:"bytes,7,opt,name=failure,proto3" json:"failure,omitempty"`
	// Types that are valid to be assigned to Key:
	//	*AutotuneResult_Conv
	//	*AutotuneResult_Gemm
	Key                  isAutotuneResult_Key `protobuf_oneof:"key"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AutotuneResult) Reset()         { *m = AutotuneResult{} }
func (m *AutotuneResult) String() string { return proto.CompactTextString(m) }
func (*AutotuneResult) ProtoMessage()    {}
func (*AutotuneResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f61248520e180396, []int{2}
}
func (m *AutotuneResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutotuneResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AutotuneResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutotuneResult.Merge(m, src)
}
func (m *AutotuneResult) XXX_Size() int {
	return m.Size()
}
func (m *AutotuneResult) XXX_DiscardUnknown() {
	xxx_messageInfo_AutotuneResult.DiscardUnknown(m)
}

var xxx_messageInfo_AutotuneResult proto.InternalMessageInfo

type isAutotuneResult_Key interface {
	isAutotuneResult_Key()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AutotuneResult_Conv struct {
	Conv *AutotuneResult_ConvKey `protobuf:"bytes,5,opt,name=conv,proto3,oneof" json:"conv,omitempty"`
}
type AutotuneResult_Gemm struct {
	Gemm *AutotuneResult_GemmKey `protobuf:"bytes,6,opt,name=gemm,proto3,oneof" json:"gemm,omitempty"`
}

func (*AutotuneResult_Conv) isAutotuneResult_Key() {}
func (*AutotuneResult_Gemm) isAutotuneResult_Key() {}

func (m *AutotuneResult) GetKey() isAutotuneResult_Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *AutotuneResult) GetScratchBytes() int64 {
	if m != nil {
		return m.ScratchBytes
	}
	return 0
}

func (m *AutotuneResult) GetRunTime() *types.Duration {
	if m != nil {
		return m.RunTime
	}
	return nil
}

func (m *AutotuneResult) GetFailure() *AutotuneResult_FailureResult {
	if m != nil {
		return m.Failure
	}
	return nil
}

func (m *AutotuneResult) GetConv() *AutotuneResult_ConvKey {
	if x, ok := m.GetKey().(*AutotuneResult_Conv); ok {
		return x.Conv
	}
	return nil
}

func (m *AutotuneResult) GetGemm() *AutotuneResult_GemmKey {
	if x, ok := m.GetKey().(*AutotuneResult_Gemm); ok {
		return x.Gemm
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AutotuneResult) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AutotuneResult_Conv)(nil),
		(*AutotuneResult_Gemm)(nil),
	}
}

type AutotuneResult_FailureResult struct {
	Kind AutotuneResult_FailureKind `protobuf:"varint,1,opt,name=kind,proto3,enum=tensorflow.AutotuneResult_FailureKind" json:"kind,omitempty"`
	Msg  string                     `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	// For failure_kind == WRONG_RESULT, this field indicates the reference
	// configuration that we compared against.
	//
	// Note that the reference algorithm isn't always correct.  However,
	// empirically it's more correct, as it's "algo 0", less fancy than the
	// compared one.
	//
	// Types that are valid to be assigned to Key:
	//	*AutotuneResult_FailureResult_ReferenceConv
	//	*AutotuneResult_FailureResult_ReferenceGemm
	Key                  isAutotuneResult_FailureResult_Key `protobuf_oneof:"key"`
	BufferAddress        int64                              `protobuf:"varint,13,opt,name=buffer_address,json=bufferAddress,proto3" json:"buffer_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *AutotuneResult_FailureResult) Reset()         { *m = AutotuneResult_FailureResult{} }
func (m *AutotuneResult_FailureResult) String() string { return proto.CompactTextString(m) }
func (*AutotuneResult_FailureResult) ProtoMessage()    {}
func (*AutotuneResult_FailureResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f61248520e180396, []int{2, 0}
}
func (m *AutotuneResult_FailureResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutotuneResult_FailureResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AutotuneResult_FailureResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutotuneResult_FailureResult.Merge(m, src)
}
func (m *AutotuneResult_FailureResult) XXX_Size() int {
	return m.Size()
}
func (m *AutotuneResult_FailureResult) XXX_DiscardUnknown() {
	xxx_messageInfo_AutotuneResult_FailureResult.DiscardUnknown(m)
}

var xxx_messageInfo_AutotuneResult_FailureResult proto.InternalMessageInfo

type isAutotuneResult_FailureResult_Key interface {
	isAutotuneResult_FailureResult_Key()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AutotuneResult_FailureResult_ReferenceConv struct {
	ReferenceConv *AutotuneResult_ConvKey `protobuf:"bytes,11,opt,name=reference_conv,json=referenceConv,proto3,oneof" json:"reference_conv,omitempty"`
}
type AutotuneResult_FailureResult_ReferenceGemm struct {
	ReferenceGemm *AutotuneResult_GemmKey `protobuf:"bytes,12,opt,name=reference_gemm,json=referenceGemm,proto3,oneof" json:"reference_gemm,omitempty"`
}

func (*AutotuneResult_FailureResult_ReferenceConv) isAutotuneResult_FailureResult_Key() {}
func (*AutotuneResult_FailureResult_ReferenceGemm) isAutotuneResult_FailureResult_Key() {}

func (m *AutotuneResult_FailureResult) GetKey() isAutotuneResult_FailureResult_Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *AutotuneResult_FailureResult) GetKind() AutotuneResult_FailureKind {
	if m != nil {
		return m.Kind
	}
	return AutotuneResult_UNKNOWN
}

func (m *AutotuneResult_FailureResult) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *AutotuneResult_FailureResult) GetReferenceConv() *AutotuneResult_ConvKey {
	if x, ok := m.GetKey().(*AutotuneResult_FailureResult_ReferenceConv); ok {
		return x.ReferenceConv
	}
	return nil
}

func (m *AutotuneResult_FailureResult) GetReferenceGemm() *AutotuneResult_GemmKey {
	if x, ok := m.GetKey().(*AutotuneResult_FailureResult_ReferenceGemm); ok {
		return x.ReferenceGemm
	}
	return nil
}

func (m *AutotuneResult_FailureResult) GetBufferAddress() int64 {
	if m != nil {
		return m.BufferAddress
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AutotuneResult_FailureResult) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AutotuneResult_FailureResult_ReferenceConv)(nil),
		(*AutotuneResult_FailureResult_ReferenceGemm)(nil),
	}
}

type AutotuneResult_ConvKey struct {
	Algorithm            int64    `protobuf:"varint,1,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	TensorOpsEnabled     bool     `protobuf:"varint,2,opt,name=tensor_ops_enabled,json=tensorOpsEnabled,proto3" json:"tensor_ops_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutotuneResult_ConvKey) Reset()         { *m = AutotuneResult_ConvKey{} }
func (m *AutotuneResult_ConvKey) String() string { return proto.CompactTextString(m) }
func (*AutotuneResult_ConvKey) ProtoMessage()    {}
func (*AutotuneResult_ConvKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_f61248520e180396, []int{2, 1}
}
func (m *AutotuneResult_ConvKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutotuneResult_ConvKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AutotuneResult_ConvKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutotuneResult_ConvKey.Merge(m, src)
}
func (m *AutotuneResult_ConvKey) XXX_Size() int {
	return m.Size()
}
func (m *AutotuneResult_ConvKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AutotuneResult_ConvKey.DiscardUnknown(m)
}

var xxx_messageInfo_AutotuneResult_ConvKey proto.InternalMessageInfo

func (m *AutotuneResult_ConvKey) GetAlgorithm() int64 {
	if m != nil {
		return m.Algorithm
	}
	return 0
}

func (m *AutotuneResult_ConvKey) GetTensorOpsEnabled() bool {
	if m != nil {
		return m.TensorOpsEnabled
	}
	return false
}

type AutotuneResult_GemmKey struct {
	Algorithm            int64    `protobuf:"varint,1,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutotuneResult_GemmKey) Reset()         { *m = AutotuneResult_GemmKey{} }
func (m *AutotuneResult_GemmKey) String() string { return proto.CompactTextString(m) }
func (*AutotuneResult_GemmKey) ProtoMessage()    {}
func (*AutotuneResult_GemmKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_f61248520e180396, []int{2, 2}
}
func (m *AutotuneResult_GemmKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutotuneResult_GemmKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AutotuneResult_GemmKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutotuneResult_GemmKey.Merge(m, src)
}
func (m *AutotuneResult_GemmKey) XXX_Size() int {
	return m.Size()
}
func (m *AutotuneResult_GemmKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AutotuneResult_GemmKey.DiscardUnknown(m)
}

var xxx_messageInfo_AutotuneResult_GemmKey proto.InternalMessageInfo

func (m *AutotuneResult_GemmKey) GetAlgorithm() int64 {
	if m != nil {
		return m.Algorithm
	}
	return 0
}

type AutotuningLog struct {
	Instr *types.Any `protobuf:"bytes,1,opt,name=instr,proto3" json:"instr,omitempty"`
	// Records all auto-tuning results per algorithm.
	Results           []*AutotuneResult  `protobuf:"bytes,2,rep,name=results,proto3" json:"results,omitempty"`
	CudnnVersion      *CudnnVersion      `protobuf:"bytes,3,opt,name=cudnn_version,json=cudnnVersion,proto3" json:"cudnn_version,omitempty"`
	ComputeCapability *ComputeCapability `protobuf:"bytes,4,opt,name=compute_capability,json=computeCapability,proto3" json:"compute_capability,omitempty"`
	// stream_executor::DeviceDescription::pci_bus_id.
	DevicePciBusId       string   `protobuf:"bytes,5,opt,name=device_pci_bus_id,json=devicePciBusId,proto3" json:"device_pci_bus_id,omitempty"`
	BlasVersion          string   `protobuf:"bytes,6,opt,name=blas_version,json=blasVersion,proto3" json:"blas_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutotuningLog) Reset()         { *m = AutotuningLog{} }
func (m *AutotuningLog) String() string { return proto.CompactTextString(m) }
func (*AutotuningLog) ProtoMessage()    {}
func (*AutotuningLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_f61248520e180396, []int{3}
}
func (m *AutotuningLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutotuningLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AutotuningLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutotuningLog.Merge(m, src)
}
func (m *AutotuningLog) XXX_Size() int {
	return m.Size()
}
func (m *AutotuningLog) XXX_DiscardUnknown() {
	xxx_messageInfo_AutotuningLog.DiscardUnknown(m)
}

var xxx_messageInfo_AutotuningLog proto.InternalMessageInfo

func (m *AutotuningLog) GetInstr() *types.Any {
	if m != nil {
		return m.Instr
	}
	return nil
}

func (m *AutotuningLog) GetResults() []*AutotuneResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *AutotuningLog) GetCudnnVersion() *CudnnVersion {
	if m != nil {
		return m.CudnnVersion
	}
	return nil
}

func (m *AutotuningLog) GetComputeCapability() *ComputeCapability {
	if m != nil {
		return m.ComputeCapability
	}
	return nil
}

func (m *AutotuningLog) GetDevicePciBusId() string {
	if m != nil {
		return m.DevicePciBusId
	}
	return ""
}

func (m *AutotuningLog) GetBlasVersion() string {
	if m != nil {
		return m.BlasVersion
	}
	return ""
}

func init() {
	proto.RegisterEnum("tensorflow.AutotuneResult_FailureKind", AutotuneResult_FailureKind_name, AutotuneResult_FailureKind_value)
	proto.RegisterType((*CudnnVersion)(nil), "tensorflow.CudnnVersion")
	proto.RegisterType((*ComputeCapability)(nil), "tensorflow.ComputeCapability")
	proto.RegisterType((*AutotuneResult)(nil), "tensorflow.AutotuneResult")
	proto.RegisterType((*AutotuneResult_FailureResult)(nil), "tensorflow.AutotuneResult.FailureResult")
	proto.RegisterType((*AutotuneResult_ConvKey)(nil), "tensorflow.AutotuneResult.ConvKey")
	proto.RegisterType((*AutotuneResult_GemmKey)(nil), "tensorflow.AutotuneResult.GemmKey")
	proto.RegisterType((*AutotuningLog)(nil), "tensorflow.AutotuningLog")
}

func init() {
	proto.RegisterFile("tensorflow/core/protobuf/autotuning.proto", fileDescriptor_f61248520e180396)
}

var fileDescriptor_f61248520e180396 = []byte{
	// 733 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0x33, 0x35,
	0x14, 0xfd, 0x26, 0x69, 0x92, 0xc6, 0x93, 0x44, 0xa9, 0xd5, 0xc5, 0x7c, 0x11, 0x44, 0x21, 0x08,
	0xc8, 0x87, 0xd0, 0x44, 0x0a, 0x5d, 0x20, 0x24, 0x84, 0xf2, 0xd7, 0x52, 0xa5, 0x24, 0x95, 0x69,
	0xa8, 0xd4, 0x8d, 0x35, 0x3f, 0xce, 0xd4, 0x74, 0xc6, 0x8e, 0xec, 0x99, 0xa0, 0xbc, 0x08, 0x6f,
	0xc0, 0xbb, 0xb0, 0x60, 0xc1, 0x92, 0x25, 0xca, 0x93, 0xa0, 0xb1, 0xa7, 0xf9, 0x69, 0xa1, 0x55,
	0x57, 0xb1, 0xcf, 0xbd, 0xe7, 0xe8, 0x9e, 0x9b, 0xf1, 0x01, 0x1f, 0x62, 0xc2, 0x24, 0x17, 0x8b,
	0x90, 0xff, 0xda, 0xf5, 0xb8, 0x20, 0xdd, 0xa5, 0xe0, 0x31, 0x77, 0x93, 0x45, 0xd7, 0x49, 0x62,
	0x1e, 0x27, 0x8c, 0xb2, 0xc0, 0x56, 0x18, 0x04, 0xbb, 0xd6, 0xc6, 0xfb, 0x80, 0xf3, 0x20, 0xdc,
	0xef, 0x66, 0x6b, 0xdd, 0xd6, 0x68, 0x3e, 0x2d, 0xf9, 0x89, 0x70, 0x62, 0xca, 0x99, 0xae, 0xb7,
	0xaf, 0x41, 0x65, 0x98, 0xf8, 0x8c, 0xfd, 0x4c, 0x84, 0xa4, 0x9c, 0xc1, 0x53, 0x50, 0x88, 0x9c,
	0x5f, 0xb8, 0xb0, 0x8c, 0x96, 0xd1, 0x29, 0x20, 0x7d, 0x51, 0x28, 0x65, 0x5c, 0x58, 0xb9, 0x0c,
	0x4d, 0x2f, 0x29, 0xba, 0x74, 0x62, 0xef, 0xde, 0xca, 0x6b, 0x54, 0x5d, 0xda, 0xdf, 0x83, 0x93,
	0x21, 0x8f, 0x96, 0x49, 0x4c, 0x86, 0xce, 0xd2, 0x71, 0x69, 0x48, 0xe3, 0xf5, 0x5b, 0x64, 0xdb,
	0xbf, 0x15, 0x41, 0xad, 0xaf, 0xed, 0x12, 0x44, 0x64, 0x12, 0xc6, 0xf0, 0x53, 0x50, 0x95, 0x9e,
	0x48, 0xe5, 0xb1, 0xbb, 0x8e, 0x89, 0xb4, 0x8e, 0x5b, 0x46, 0x27, 0x8f, 0x2a, 0x19, 0x38, 0x48,
	0x31, 0x78, 0x06, 0x8e, 0x45, 0xc2, 0x70, 0x4c, 0x23, 0x62, 0x95, 0x5b, 0x46, 0xc7, 0xec, 0xbd,
	0xb7, 0xb5, 0x7b, 0xfb, 0xd1, 0xbd, 0x3d, 0xca, 0xdc, 0xa3, 0x92, 0x48, 0xd8, 0x0d, 0x8d, 0x08,
	0x1c, 0x80, 0xd2, 0xc2, 0xa1, 0x61, 0x22, 0x88, 0x55, 0x52, 0xa4, 0x8e, 0xbd, 0xdb, 0xac, 0x7d,
	0x38, 0x87, 0x7d, 0xae, 0x3b, 0xf5, 0x0d, 0x3d, 0x12, 0xe1, 0x37, 0xe0, 0xc8, 0xe3, 0x6c, 0x65,
	0x15, 0x94, 0x40, 0xfb, 0x05, 0x81, 0x21, 0x67, 0xab, 0x09, 0x59, 0xff, 0xf0, 0x0e, 0x29, 0x46,
	0xca, 0x0c, 0x48, 0x14, 0x59, 0xc5, 0x57, 0x99, 0x17, 0x24, 0x8a, 0x32, 0x66, 0xca, 0x68, 0xfc,
	0x9e, 0x03, 0xd5, 0x83, 0x71, 0xe0, 0xb7, 0xe0, 0xe8, 0x81, 0x32, 0x5f, 0xad, 0xb8, 0xd6, 0xfb,
	0xfc, 0x75, 0x1b, 0x13, 0xca, 0x7c, 0xa4, 0x38, 0xb0, 0x0e, 0xf2, 0x91, 0x0c, 0xd4, 0xff, 0x50,
	0x46, 0xe9, 0x11, 0x4e, 0x40, 0x4d, 0x90, 0x05, 0x11, 0x84, 0x79, 0x04, 0x2b, 0x77, 0xe6, 0x1b,
	0xdc, 0x55, 0xb7, 0xdc, 0x14, 0x3b, 0x14, 0x53, 0x86, 0x2b, 0x6f, 0x30, 0xbc, 0x13, 0x4b, 0x31,
	0xf8, 0x19, 0xa8, 0xb9, 0xc9, 0x62, 0x41, 0x04, 0x76, 0x7c, 0x5f, 0x10, 0x29, 0xad, 0xaa, 0xfa,
	0x1a, 0xaa, 0x1a, 0xed, 0x6b, 0x70, 0x50, 0x00, 0xf9, 0x07, 0xb2, 0x6e, 0xcc, 0x41, 0x29, 0x1b,
	0x0b, 0x7e, 0x04, 0xca, 0x4e, 0x18, 0x70, 0x41, 0xe3, 0xfb, 0x48, 0x6d, 0x29, 0x8f, 0x76, 0x00,
	0xfc, 0x0a, 0x40, 0x3d, 0x0c, 0xe6, 0x4b, 0x89, 0x09, 0x73, 0xdc, 0x90, 0xf8, 0x6a, 0x23, 0xc7,
	0xa8, 0xae, 0x2b, 0xb3, 0xa5, 0x1c, 0x6b, 0xbc, 0xf1, 0x05, 0x28, 0x65, 0x03, 0xbe, 0x2c, 0xdb,
	0x1e, 0x00, 0x73, 0x6f, 0xdd, 0xd0, 0x04, 0xa5, 0xf9, 0x74, 0x32, 0x9d, 0xdd, 0x4e, 0xeb, 0xef,
	0xe0, 0x29, 0xa8, 0xa3, 0xf1, 0xe8, 0x6e, 0x36, 0x1d, 0xe3, 0x1f, 0x67, 0xa3, 0xcb, 0xf3, 0xcb,
	0xf1, 0xa8, 0x6e, 0xc0, 0x3a, 0xa8, 0xdc, 0xa2, 0xd9, 0xf4, 0x02, 0xa3, 0xf1, 0x4f, 0xf3, 0xab,
	0x9b, 0x7a, 0x2e, 0xb3, 0xd2, 0xfe, 0x33, 0x07, 0xaa, 0xfd, 0x6d, 0x0e, 0x5c, 0xf1, 0x00, 0x7e,
	0x09, 0x0a, 0x94, 0xc9, 0x58, 0x3f, 0x2b, 0xb3, 0x77, 0xfa, 0xec, 0x7b, 0xef, 0xb3, 0x35, 0xd2,
	0x2d, 0xf0, 0x0c, 0x94, 0x84, 0xda, 0xac, 0xb4, 0x72, 0xad, 0x7c, 0xc7, 0xec, 0x35, 0xfe, 0x7f,
	0xf9, 0xe8, 0xb1, 0x15, 0x7e, 0x07, 0xaa, 0x5e, 0x9a, 0x0f, 0x78, 0xa5, 0x03, 0x42, 0xbd, 0x75,
	0xb3, 0x67, 0xed, 0x73, 0xf7, 0x03, 0x04, 0x55, 0xbc, 0xfd, 0x38, 0xb9, 0x02, 0xd0, 0xd3, 0x61,
	0x80, 0xbd, 0x6d, 0x1a, 0x58, 0x47, 0x4a, 0xe3, 0xe3, 0x03, 0x8d, 0xa7, 0x91, 0x81, 0x4e, 0xbc,
	0x67, 0x29, 0xf2, 0x01, 0x9c, 0xf8, 0x64, 0x45, 0x3d, 0x82, 0x97, 0x1e, 0xc5, 0x6e, 0x22, 0x31,
	0xf5, 0xd5, 0xa3, 0x2b, 0xa3, 0x9a, 0x2e, 0x5c, 0x7b, 0x74, 0x90, 0xc8, 0x4b, 0x1f, 0x7e, 0x02,
	0x2a, 0x6e, 0xe8, 0xc8, 0xed, 0xd8, 0x45, 0xd5, 0x65, 0xa6, 0x58, 0x36, 0xdb, 0x20, 0xf8, 0x63,
	0xd3, 0x34, 0xfe, 0xda, 0x34, 0x8d, 0xbf, 0x37, 0x4d, 0xe3, 0x9f, 0x4d, 0xd3, 0xb8, 0x9b, 0x07,
	0x34, 0xbe, 0x4f, 0x5c, 0xdb, 0xe3, 0x51, 0x77, 0x2f, 0x89, 0xff, 0xfb, 0x18, 0xf0, 0x27, 0x11,
	0xbd, 0xe0, 0x02, 0xa7, 0x08, 0x56, 0x88, 0xc4, 0x01, 0xd7, 0x27, 0xb7, 0xa8, 0x7e, 0xbe, 0xfe,
	0x37, 0x00, 0x00, 0xff, 0xff, 0xe3, 0xf4, 0xd6, 0x3f, 0xde, 0x05, 0x00, 0x00,
}

func (m *CudnnVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CudnnVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CudnnVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Patch != 0 {
		i = encodeVarintAutotuning(dAtA, i, uint64(m.Patch))
		i--
		dAtA[i] = 0x18
	}
	if m.Minor != 0 {
		i = encodeVarintAutotuning(dAtA, i, uint64(m.Minor))
		i--
		dAtA[i] = 0x10
	}
	if m.Major != 0 {
		i = encodeVarintAutotuning(dAtA, i, uint64(m.Major))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComputeCapability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComputeCapability) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComputeCapability) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Minor != 0 {
		i = encodeVarintAutotuning(dAtA, i, uint64(m.Minor))
		i--
		dAtA[i] = 0x10
	}
	if m.Major != 0 {
		i = encodeVarintAutotuning(dAtA, i, uint64(m.Major))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutotuneResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutotuneResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutotuneResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RunTime != nil {
		{
			size, err := m.RunTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAutotuning(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ScratchBytes != 0 {
		i = encodeVarintAutotuning(dAtA, i, uint64(m.ScratchBytes))
		i--
		dAtA[i] = 0x40
	}
	if m.Failure != nil {
		{
			size, err := m.Failure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAutotuning(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Key != nil {
		{
			size := m.Key.Size()
			i -= size
			if _, err := m.Key.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AutotuneResult_Conv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutotuneResult_Conv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Conv != nil {
		{
			size, err := m.Conv.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAutotuning(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AutotuneResult_Gemm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutotuneResult_Gemm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gemm != nil {
		{
			size, err := m.Gemm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAutotuning(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AutotuneResult_FailureResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutotuneResult_FailureResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutotuneResult_FailureResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BufferAddress != 0 {
		i = encodeVarintAutotuning(dAtA, i, uint64(m.BufferAddress))
		i--
		dAtA[i] = 0x68
	}
	if m.Key != nil {
		{
			size := m.Key.Size()
			i -= size
			if _, err := m.Key.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintAutotuning(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintAutotuning(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutotuneResult_FailureResult_ReferenceConv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutotuneResult_FailureResult_ReferenceConv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReferenceConv != nil {
		{
			size, err := m.ReferenceConv.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAutotuning(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *AutotuneResult_FailureResult_ReferenceGemm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutotuneResult_FailureResult_ReferenceGemm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReferenceGemm != nil {
		{
			size, err := m.ReferenceGemm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAutotuning(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *AutotuneResult_ConvKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutotuneResult_ConvKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutotuneResult_ConvKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TensorOpsEnabled {
		i--
		if m.TensorOpsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Algorithm != 0 {
		i = encodeVarintAutotuning(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutotuneResult_GemmKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutotuneResult_GemmKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutotuneResult_GemmKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Algorithm != 0 {
		i = encodeVarintAutotuning(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutotuningLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutotuningLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutotuningLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BlasVersion) > 0 {
		i -= len(m.BlasVersion)
		copy(dAtA[i:], m.BlasVersion)
		i = encodeVarintAutotuning(dAtA, i, uint64(len(m.BlasVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DevicePciBusId) > 0 {
		i -= len(m.DevicePciBusId)
		copy(dAtA[i:], m.DevicePciBusId)
		i = encodeVarintAutotuning(dAtA, i, uint64(len(m.DevicePciBusId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ComputeCapability != nil {
		{
			size, err := m.ComputeCapability.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAutotuning(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CudnnVersion != nil {
		{
			size, err := m.CudnnVersion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAutotuning(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAutotuning(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Instr != nil {
		{
			size, err := m.Instr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAutotuning(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAutotuning(dAtA []byte, offset int, v uint64) int {
	offset -= sovAutotuning(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CudnnVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovAutotuning(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovAutotuning(uint64(m.Minor))
	}
	if m.Patch != 0 {
		n += 1 + sovAutotuning(uint64(m.Patch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComputeCapability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovAutotuning(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovAutotuning(uint64(m.Minor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutotuneResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		n += m.Key.Size()
	}
	if m.Failure != nil {
		l = m.Failure.Size()
		n += 1 + l + sovAutotuning(uint64(l))
	}
	if m.ScratchBytes != 0 {
		n += 1 + sovAutotuning(uint64(m.ScratchBytes))
	}
	if m.RunTime != nil {
		l = m.RunTime.Size()
		n += 1 + l + sovAutotuning(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutotuneResult_Conv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Conv != nil {
		l = m.Conv.Size()
		n += 1 + l + sovAutotuning(uint64(l))
	}
	return n
}
func (m *AutotuneResult_Gemm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gemm != nil {
		l = m.Gemm.Size()
		n += 1 + l + sovAutotuning(uint64(l))
	}
	return n
}
func (m *AutotuneResult_FailureResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovAutotuning(uint64(m.Kind))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovAutotuning(uint64(l))
	}
	if m.Key != nil {
		n += m.Key.Size()
	}
	if m.BufferAddress != 0 {
		n += 1 + sovAutotuning(uint64(m.BufferAddress))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutotuneResult_FailureResult_ReferenceConv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReferenceConv != nil {
		l = m.ReferenceConv.Size()
		n += 1 + l + sovAutotuning(uint64(l))
	}
	return n
}
func (m *AutotuneResult_FailureResult_ReferenceGemm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReferenceGemm != nil {
		l = m.ReferenceGemm.Size()
		n += 1 + l + sovAutotuning(uint64(l))
	}
	return n
}
func (m *AutotuneResult_ConvKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algorithm != 0 {
		n += 1 + sovAutotuning(uint64(m.Algorithm))
	}
	if m.TensorOpsEnabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutotuneResult_GemmKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algorithm != 0 {
		n += 1 + sovAutotuning(uint64(m.Algorithm))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutotuningLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Instr != nil {
		l = m.Instr.Size()
		n += 1 + l + sovAutotuning(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovAutotuning(uint64(l))
		}
	}
	if m.CudnnVersion != nil {
		l = m.CudnnVersion.Size()
		n += 1 + l + sovAutotuning(uint64(l))
	}
	if m.ComputeCapability != nil {
		l = m.ComputeCapability.Size()
		n += 1 + l + sovAutotuning(uint64(l))
	}
	l = len(m.DevicePciBusId)
	if l > 0 {
		n += 1 + l + sovAutotuning(uint64(l))
	}
	l = len(m.BlasVersion)
	if l > 0 {
		n += 1 + l + sovAutotuning(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAutotuning(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAutotuning(x uint64) (n int) {
	return sovAutotuning(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CudnnVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAutotuning
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CudnnVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CudnnVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			m.Patch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Patch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAutotuning(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAutotuning
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComputeCapability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAutotuning
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComputeCapability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComputeCapability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAutotuning(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAutotuning
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutotuneResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAutotuning
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutotuneResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutotuneResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AutotuneResult_ConvKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Key = &AutotuneResult_Conv{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gemm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AutotuneResult_GemmKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Key = &AutotuneResult_Gemm{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Failure == nil {
				m.Failure = &AutotuneResult_FailureResult{}
			}
			if err := m.Failure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScratchBytes", wireType)
			}
			m.ScratchBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScratchBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunTime == nil {
				m.RunTime = &types.Duration{}
			}
			if err := m.RunTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAutotuning(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAutotuning
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutotuneResult_FailureResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAutotuning
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailureResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailureResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= AutotuneResult_FailureKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceConv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AutotuneResult_ConvKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Key = &AutotuneResult_FailureResult_ReferenceConv{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceGemm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AutotuneResult_GemmKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Key = &AutotuneResult_FailureResult_ReferenceGemm{v}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferAddress", wireType)
			}
			m.BufferAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferAddress |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAutotuning(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAutotuning
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutotuneResult_ConvKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAutotuning
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorOpsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TensorOpsEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAutotuning(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAutotuning
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutotuneResult_GemmKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAutotuning
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GemmKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GemmKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAutotuning(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAutotuning
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutotuningLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAutotuning
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutotuningLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutotuningLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instr == nil {
				m.Instr = &types.Any{}
			}
			if err := m.Instr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &AutotuneResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CudnnVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CudnnVersion == nil {
				m.CudnnVersion = &CudnnVersion{}
			}
			if err := m.CudnnVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeCapability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ComputeCapability == nil {
				m.ComputeCapability = &ComputeCapability{}
			}
			if err := m.ComputeCapability.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevicePciBusId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevicePciBusId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlasVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAutotuning
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAutotuning
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlasVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAutotuning(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAutotuning
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAutotuning(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAutotuning
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAutotuning
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAutotuning
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAutotuning
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAutotuning
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAutotuning        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAutotuning          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAutotuning = fmt.Errorf("proto: unexpected end of group")
)
