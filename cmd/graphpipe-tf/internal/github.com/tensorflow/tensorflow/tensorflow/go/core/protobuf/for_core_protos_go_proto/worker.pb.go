// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/worker.proto

package for_core_protos_go_proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	cost_graph_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/cost_graph_go_proto"
	device_attributes_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/device_attributes_go_proto"
	graph_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/graph_go_proto"
	step_stats_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/step_stats_go_proto"
	tensor_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/tensor_go_proto"
	tensor_shape_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/tensor_shape_go_proto"
	types_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/types_go_proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GetStatusRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStatusRequest) Reset()         { *m = GetStatusRequest{} }
func (m *GetStatusRequest) String() string { return proto.CompactTextString(m) }
func (*GetStatusRequest) ProtoMessage()    {}
func (*GetStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{0}
}
func (m *GetStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStatusRequest.Merge(m, src)
}
func (m *GetStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStatusRequest proto.InternalMessageInfo

type GetStatusResponse struct {
	DeviceAttributes     []*device_attributes_go_proto.DeviceAttributes `protobuf:"bytes,1,rep,name=device_attributes,json=deviceAttributes,proto3" json:"device_attributes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                       `json:"-"`
	XXX_unrecognized     []byte                                         `json:"-"`
	XXX_sizecache        int32                                          `json:"-"`
}

func (m *GetStatusResponse) Reset()         { *m = GetStatusResponse{} }
func (m *GetStatusResponse) String() string { return proto.CompactTextString(m) }
func (*GetStatusResponse) ProtoMessage()    {}
func (*GetStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{1}
}
func (m *GetStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStatusResponse.Merge(m, src)
}
func (m *GetStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStatusResponse proto.InternalMessageInfo

func (m *GetStatusResponse) GetDeviceAttributes() []*device_attributes_go_proto.DeviceAttributes {
	if m != nil {
		return m.DeviceAttributes
	}
	return nil
}

type CreateWorkerSessionRequest struct {
	// Sessions are identified by a given handle.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// Defines the configuration of a TensorFlow worker.
	ServerDef *ServerDef `protobuf:"bytes,2,opt,name=server_def,json=serverDef,proto3" json:"server_def,omitempty"`
	// If true, any resources such as Variables used in the session will not be
	// shared with other sessions.
	IsolateSessionState bool `protobuf:"varint,3,opt,name=isolate_session_state,json=isolateSessionState,proto3" json:"isolate_session_state,omitempty"`
	// The device attributes of all the devices in the cluster.
	ClusterDeviceAttributes []*device_attributes_go_proto.DeviceAttributes `protobuf:"bytes,4,rep,name=cluster_device_attributes,json=clusterDeviceAttributes,proto3" json:"cluster_device_attributes,omitempty"`
	// The master task name from which the request is sent.
	MasterTask string `protobuf:"bytes,5,opt,name=master_task,json=masterTask,proto3" json:"master_task,omitempty"`
	// The incarnation ID of the master task local CPU device.
	// If the target worker already has a WorkerSession created previously with
	// the same master task name but a different incarnation, it usually indicates
	// that the previous master failed before deleting the WorkerSession on the
	// worker. To prevent memory leaks, the worker should garbage collect the old
	// WorkerSessions.
	MasterIncarnation    int64    `protobuf:"varint,6,opt,name=master_incarnation,json=masterIncarnation,proto3" json:"master_incarnation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateWorkerSessionRequest) Reset()         { *m = CreateWorkerSessionRequest{} }
func (m *CreateWorkerSessionRequest) String() string { return proto.CompactTextString(m) }
func (*CreateWorkerSessionRequest) ProtoMessage()    {}
func (*CreateWorkerSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{2}
}
func (m *CreateWorkerSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateWorkerSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateWorkerSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWorkerSessionRequest.Merge(m, src)
}
func (m *CreateWorkerSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateWorkerSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWorkerSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWorkerSessionRequest proto.InternalMessageInfo

func (m *CreateWorkerSessionRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *CreateWorkerSessionRequest) GetServerDef() *ServerDef {
	if m != nil {
		return m.ServerDef
	}
	return nil
}

func (m *CreateWorkerSessionRequest) GetIsolateSessionState() bool {
	if m != nil {
		return m.IsolateSessionState
	}
	return false
}

func (m *CreateWorkerSessionRequest) GetClusterDeviceAttributes() []*device_attributes_go_proto.DeviceAttributes {
	if m != nil {
		return m.ClusterDeviceAttributes
	}
	return nil
}

func (m *CreateWorkerSessionRequest) GetMasterTask() string {
	if m != nil {
		return m.MasterTask
	}
	return ""
}

func (m *CreateWorkerSessionRequest) GetMasterIncarnation() int64 {
	if m != nil {
		return m.MasterIncarnation
	}
	return 0
}

type CreateWorkerSessionResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateWorkerSessionResponse) Reset()         { *m = CreateWorkerSessionResponse{} }
func (m *CreateWorkerSessionResponse) String() string { return proto.CompactTextString(m) }
func (*CreateWorkerSessionResponse) ProtoMessage()    {}
func (*CreateWorkerSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{3}
}
func (m *CreateWorkerSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateWorkerSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateWorkerSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWorkerSessionResponse.Merge(m, src)
}
func (m *CreateWorkerSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateWorkerSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWorkerSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWorkerSessionResponse proto.InternalMessageInfo

type DeleteWorkerSessionRequest struct {
	// Sessions are identified by a given handle.
	SessionHandle        string   `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteWorkerSessionRequest) Reset()         { *m = DeleteWorkerSessionRequest{} }
func (m *DeleteWorkerSessionRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteWorkerSessionRequest) ProtoMessage()    {}
func (*DeleteWorkerSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{4}
}
func (m *DeleteWorkerSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteWorkerSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteWorkerSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteWorkerSessionRequest.Merge(m, src)
}
func (m *DeleteWorkerSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteWorkerSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteWorkerSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteWorkerSessionRequest proto.InternalMessageInfo

func (m *DeleteWorkerSessionRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

type DeleteWorkerSessionResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteWorkerSessionResponse) Reset()         { *m = DeleteWorkerSessionResponse{} }
func (m *DeleteWorkerSessionResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteWorkerSessionResponse) ProtoMessage()    {}
func (*DeleteWorkerSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{5}
}
func (m *DeleteWorkerSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteWorkerSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteWorkerSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteWorkerSessionResponse.Merge(m, src)
}
func (m *DeleteWorkerSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteWorkerSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteWorkerSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteWorkerSessionResponse proto.InternalMessageInfo

type RegisterGraphRequest struct {
	// Subgraphs are scoped within one session.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// Set to true if `CreateWorkerSession` was called for `session_handle`.
	CreateWorkerSessionCalled bool `protobuf:"varint,6,opt,name=create_worker_session_called,json=createWorkerSessionCalled,proto3" json:"create_worker_session_called,omitempty"`
	// "graph_def" has the subgraph of nodes for this worker, with each node
	// having its device_name filled in.
	GraphDef *graph_go_proto.GraphDef `protobuf:"bytes,2,opt,name=graph_def,json=graphDef,proto3" json:"graph_def,omitempty"`
	// True iff the graph (before partitioning) contains control flow nodes.
	//
	// As of 01/11/2015, this is no longer set by clients.
	HasControlFlow bool `protobuf:"varint,3,opt,name=has_control_flow,json=hasControlFlow,proto3" json:"has_control_flow,omitempty"` // Deprecated: Do not use.
	// Configuration options for the session in which this graph was created.
	GraphOptions *GraphOptions `protobuf:"bytes,4,opt,name=graph_options,json=graphOptions,proto3" json:"graph_options,omitempty"`
	// Field(s) used by TensorFlow Debugger (tfdbg).
	DebugOptions *DebugOptions `protobuf:"bytes,5,opt,name=debug_options,json=debugOptions,proto3" json:"debug_options,omitempty"`
	// If graph_def contains any collective ops this must be a positive
	// integer used to coordinate execution with other graphs.  All
	// graphs in a distributed execution with the same
	// collective_graph_key will coordinate to use the same step_id
	// concurrently so that BufRendezvous entries will make the correct
	// values accessible.
	CollectiveGraphKey int64 `protobuf:"varint,7,opt,name=collective_graph_key,json=collectiveGraphKey,proto3" json:"collective_graph_key,omitempty"`
	// ConfigProto from the session in which this graph was created.
	// Contains additional parameters beyond graph_options, including
	// the name of the requested executor.
	ConfigProto          *ConfigProto `protobuf:"bytes,8,opt,name=config_proto,json=configProto,proto3" json:"config_proto,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RegisterGraphRequest) Reset()         { *m = RegisterGraphRequest{} }
func (m *RegisterGraphRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterGraphRequest) ProtoMessage()    {}
func (*RegisterGraphRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{6}
}
func (m *RegisterGraphRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterGraphRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RegisterGraphRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterGraphRequest.Merge(m, src)
}
func (m *RegisterGraphRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterGraphRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterGraphRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterGraphRequest proto.InternalMessageInfo

func (m *RegisterGraphRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *RegisterGraphRequest) GetCreateWorkerSessionCalled() bool {
	if m != nil {
		return m.CreateWorkerSessionCalled
	}
	return false
}

func (m *RegisterGraphRequest) GetGraphDef() *graph_go_proto.GraphDef {
	if m != nil {
		return m.GraphDef
	}
	return nil
}

// Deprecated: Do not use.
func (m *RegisterGraphRequest) GetHasControlFlow() bool {
	if m != nil {
		return m.HasControlFlow
	}
	return false
}

func (m *RegisterGraphRequest) GetGraphOptions() *GraphOptions {
	if m != nil {
		return m.GraphOptions
	}
	return nil
}

func (m *RegisterGraphRequest) GetDebugOptions() *DebugOptions {
	if m != nil {
		return m.DebugOptions
	}
	return nil
}

func (m *RegisterGraphRequest) GetCollectiveGraphKey() int64 {
	if m != nil {
		return m.CollectiveGraphKey
	}
	return 0
}

func (m *RegisterGraphRequest) GetConfigProto() *ConfigProto {
	if m != nil {
		return m.ConfigProto
	}
	return nil
}

type RegisterGraphResponse struct {
	// If the registration succeeds, returns an opaque graph_handle to
	// the master. The master calls RunGraph with graph_handle to
	// compute different steps.
	GraphHandle          string   `protobuf:"bytes,1,opt,name=graph_handle,json=graphHandle,proto3" json:"graph_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterGraphResponse) Reset()         { *m = RegisterGraphResponse{} }
func (m *RegisterGraphResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterGraphResponse) ProtoMessage()    {}
func (*RegisterGraphResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{7}
}
func (m *RegisterGraphResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterGraphResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RegisterGraphResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterGraphResponse.Merge(m, src)
}
func (m *RegisterGraphResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegisterGraphResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterGraphResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterGraphResponse proto.InternalMessageInfo

func (m *RegisterGraphResponse) GetGraphHandle() string {
	if m != nil {
		return m.GraphHandle
	}
	return ""
}

type DeregisterGraphRequest struct {
	// The session_handle used when registering the graph. If session_handle is
	// empty, a single global namespace is used.
	SessionHandle string `protobuf:"bytes,2,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// Set to true if `CreateWorkerSession` was called for `session_handle`.
	CreateWorkerSessionCalled bool `protobuf:"varint,3,opt,name=create_worker_session_called,json=createWorkerSessionCalled,proto3" json:"create_worker_session_called,omitempty"`
	// REQUIRED: graph_handle must be returned by a RegisterGraph call
	// to the same WorkerService.
	GraphHandle          string   `protobuf:"bytes,1,opt,name=graph_handle,json=graphHandle,proto3" json:"graph_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeregisterGraphRequest) Reset()         { *m = DeregisterGraphRequest{} }
func (m *DeregisterGraphRequest) String() string { return proto.CompactTextString(m) }
func (*DeregisterGraphRequest) ProtoMessage()    {}
func (*DeregisterGraphRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{8}
}
func (m *DeregisterGraphRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeregisterGraphRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeregisterGraphRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeregisterGraphRequest.Merge(m, src)
}
func (m *DeregisterGraphRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeregisterGraphRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeregisterGraphRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeregisterGraphRequest proto.InternalMessageInfo

func (m *DeregisterGraphRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *DeregisterGraphRequest) GetCreateWorkerSessionCalled() bool {
	if m != nil {
		return m.CreateWorkerSessionCalled
	}
	return false
}

func (m *DeregisterGraphRequest) GetGraphHandle() string {
	if m != nil {
		return m.GraphHandle
	}
	return ""
}

type DeregisterGraphResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeregisterGraphResponse) Reset()         { *m = DeregisterGraphResponse{} }
func (m *DeregisterGraphResponse) String() string { return proto.CompactTextString(m) }
func (*DeregisterGraphResponse) ProtoMessage()    {}
func (*DeregisterGraphResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{9}
}
func (m *DeregisterGraphResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeregisterGraphResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeregisterGraphResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeregisterGraphResponse.Merge(m, src)
}
func (m *DeregisterGraphResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeregisterGraphResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeregisterGraphResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeregisterGraphResponse proto.InternalMessageInfo

type CleanupAllRequest struct {
	// A list of container names.
	//
	// If 'container' is not empty, releases resources in the given
	// containers in all devices.
	//
	// If 'container' is empty, releases resources in the default
	// container in all devices.
	Container            []string `protobuf:"bytes,1,rep,name=container,proto3" json:"container,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CleanupAllRequest) Reset()         { *m = CleanupAllRequest{} }
func (m *CleanupAllRequest) String() string { return proto.CompactTextString(m) }
func (*CleanupAllRequest) ProtoMessage()    {}
func (*CleanupAllRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{10}
}
func (m *CleanupAllRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CleanupAllRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CleanupAllRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CleanupAllRequest.Merge(m, src)
}
func (m *CleanupAllRequest) XXX_Size() int {
	return m.Size()
}
func (m *CleanupAllRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CleanupAllRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CleanupAllRequest proto.InternalMessageInfo

func (m *CleanupAllRequest) GetContainer() []string {
	if m != nil {
		return m.Container
	}
	return nil
}

type CleanupAllResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CleanupAllResponse) Reset()         { *m = CleanupAllResponse{} }
func (m *CleanupAllResponse) String() string { return proto.CompactTextString(m) }
func (*CleanupAllResponse) ProtoMessage()    {}
func (*CleanupAllResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{11}
}
func (m *CleanupAllResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CleanupAllResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CleanupAllResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CleanupAllResponse.Merge(m, src)
}
func (m *CleanupAllResponse) XXX_Size() int {
	return m.Size()
}
func (m *CleanupAllResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CleanupAllResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CleanupAllResponse proto.InternalMessageInfo

// Options specific to the execution of a single step.
type ExecutorOpts struct {
	RecordCosts                    bool     `protobuf:"varint,1,opt,name=record_costs,json=recordCosts,proto3" json:"record_costs,omitempty"`
	RecordTimeline                 bool     `protobuf:"varint,3,opt,name=record_timeline,json=recordTimeline,proto3" json:"record_timeline,omitempty"`
	RecordPartitionGraphs          bool     `protobuf:"varint,4,opt,name=record_partition_graphs,json=recordPartitionGraphs,proto3" json:"record_partition_graphs,omitempty"`
	ReportTensorAllocationsUponOom bool     `protobuf:"varint,5,opt,name=report_tensor_allocations_upon_oom,json=reportTensorAllocationsUponOom,proto3" json:"report_tensor_allocations_upon_oom,omitempty"`
	XXX_NoUnkeyedLiteral           struct{} `json:"-"`
	XXX_unrecognized               []byte   `json:"-"`
	XXX_sizecache                  int32    `json:"-"`
}

func (m *ExecutorOpts) Reset()         { *m = ExecutorOpts{} }
func (m *ExecutorOpts) String() string { return proto.CompactTextString(m) }
func (*ExecutorOpts) ProtoMessage()    {}
func (*ExecutorOpts) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{12}
}
func (m *ExecutorOpts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutorOpts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExecutorOpts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutorOpts.Merge(m, src)
}
func (m *ExecutorOpts) XXX_Size() int {
	return m.Size()
}
func (m *ExecutorOpts) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutorOpts.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutorOpts proto.InternalMessageInfo

func (m *ExecutorOpts) GetRecordCosts() bool {
	if m != nil {
		return m.RecordCosts
	}
	return false
}

func (m *ExecutorOpts) GetRecordTimeline() bool {
	if m != nil {
		return m.RecordTimeline
	}
	return false
}

func (m *ExecutorOpts) GetRecordPartitionGraphs() bool {
	if m != nil {
		return m.RecordPartitionGraphs
	}
	return false
}

func (m *ExecutorOpts) GetReportTensorAllocationsUponOom() bool {
	if m != nil {
		return m.ReportTensorAllocationsUponOom
	}
	return false
}

type RunGraphRequest struct {
	// session_handle is the master-generated unique id for this session.
	// If session_handle is non-empty, it must be the same as used when
	// registering the graph. If it is empty, a single global namespace is used to
	// search for the graph_handle.
	SessionHandle string `protobuf:"bytes,8,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// Set to true if `CreateWorkerSession` was called for `session_handle`.
	CreateWorkerSessionCalled bool `protobuf:"varint,10,opt,name=create_worker_session_called,json=createWorkerSessionCalled,proto3" json:"create_worker_session_called,omitempty"`
	// REQUIRED: graph_handle must be returned by a RegisterGraph call
	// to the same WorkerService.
	GraphHandle string `protobuf:"bytes,1,opt,name=graph_handle,json=graphHandle,proto3" json:"graph_handle,omitempty"`
	// A unique ID to distinguish different runs of the same graph.
	//
	// The master generates a global unique `step_id` to distinguish
	// different runs of the graph computation. Subgraphs communicate
	// (e.g., send/recv ops) with each other using `step_id` to
	// distinguish tensors generated by different runs.
	StepId int64 `protobuf:"varint,2,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	// Options for this step.
	ExecOpts *ExecutorOpts `protobuf:"bytes,5,opt,name=exec_opts,json=execOpts,proto3" json:"exec_opts,omitempty"`
	// Runs the graph.
	//
	// Sends the tensors in "send" into the graph before the run and
	// fetches the keys into `RunGraphResponse.recv` after the run.
	Send    []*NamedTensorProto `protobuf:"bytes,3,rep,name=send,proto3" json:"send,omitempty"`
	RecvKey []string            `protobuf:"bytes,4,rep,name=recv_key,json=recvKey,proto3" json:"recv_key,omitempty"`
	// True if the RunGraphRequest is a partial run request.
	IsPartial bool `protobuf:"varint,6,opt,name=is_partial,json=isPartial,proto3" json:"is_partial,omitempty"`
	// True if this is the last partial run request in a sequence of requests.
	IsLastPartialRun bool `protobuf:"varint,7,opt,name=is_last_partial_run,json=isLastPartialRun,proto3" json:"is_last_partial_run,omitempty"`
	// If true then some errors, e.g., execution errors that have long
	// error messages, may return an OK RunGraphResponse with the actual
	// error saved in the status_code/status_error_message fields of the
	// response body. This is a workaround since the RPC subsystem may
	// truncate long metadata messages.
	StoreErrorsInResponseBody bool `protobuf:"varint,9,opt,name=store_errors_in_response_body,json=storeErrorsInResponseBody,proto3" json:"store_errors_in_response_body,omitempty"`
	// Unique identifier for this request. Every RunGraphRequest must have a
	// unique request_id, and retried RunGraphRequests must have the same
	// request_id. If request_id is zero, retry detection is disabled.
	//
	// Retried RunGraphRequests are problematic because they may issue a
	// RecvTensor that will have no corresponding sender and will wait forever.
	// Workers use request_ids to reject retried RunGraph requests instead of
	// waiting forever.
	RequestId            int64    `protobuf:"varint,11,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunGraphRequest) Reset()         { *m = RunGraphRequest{} }
func (m *RunGraphRequest) String() string { return proto.CompactTextString(m) }
func (*RunGraphRequest) ProtoMessage()    {}
func (*RunGraphRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{13}
}
func (m *RunGraphRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunGraphRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RunGraphRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunGraphRequest.Merge(m, src)
}
func (m *RunGraphRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunGraphRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunGraphRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunGraphRequest proto.InternalMessageInfo

func (m *RunGraphRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *RunGraphRequest) GetCreateWorkerSessionCalled() bool {
	if m != nil {
		return m.CreateWorkerSessionCalled
	}
	return false
}

func (m *RunGraphRequest) GetGraphHandle() string {
	if m != nil {
		return m.GraphHandle
	}
	return ""
}

func (m *RunGraphRequest) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

func (m *RunGraphRequest) GetExecOpts() *ExecutorOpts {
	if m != nil {
		return m.ExecOpts
	}
	return nil
}

func (m *RunGraphRequest) GetSend() []*NamedTensorProto {
	if m != nil {
		return m.Send
	}
	return nil
}

func (m *RunGraphRequest) GetRecvKey() []string {
	if m != nil {
		return m.RecvKey
	}
	return nil
}

func (m *RunGraphRequest) GetIsPartial() bool {
	if m != nil {
		return m.IsPartial
	}
	return false
}

func (m *RunGraphRequest) GetIsLastPartialRun() bool {
	if m != nil {
		return m.IsLastPartialRun
	}
	return false
}

func (m *RunGraphRequest) GetStoreErrorsInResponseBody() bool {
	if m != nil {
		return m.StoreErrorsInResponseBody
	}
	return false
}

func (m *RunGraphRequest) GetRequestId() int64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

type RunGraphResponse struct {
	// A list of tensors corresponding to those requested by
	// `RunGraphRequest.recv_key`.
	Recv []*NamedTensorProto `protobuf:"bytes,1,rep,name=recv,proto3" json:"recv,omitempty"`
	// If the request asked for execution stats, the cost graph, or the partition
	// graphs, these are returned here.
	// TODO(suharshs): Package these in a RunMetadata instead.
	StepStats      *step_stats_go_proto.StepStats    `protobuf:"bytes,2,opt,name=step_stats,json=stepStats,proto3" json:"step_stats,omitempty"`
	CostGraph      *cost_graph_go_proto.CostGraphDef `protobuf:"bytes,3,opt,name=cost_graph,json=costGraph,proto3" json:"cost_graph,omitempty"`
	PartitionGraph []*graph_go_proto.GraphDef        `protobuf:"bytes,4,rep,name=partition_graph,json=partitionGraph,proto3" json:"partition_graph,omitempty"`
	// If store_errors_in_response_body is true in the request, then
	// optionally the server may return an OK status for the RPC and
	// fill the true status into the fields below, to allow for messages
	// that are too long to fit in metadata.
	StatusCode           Code     `protobuf:"varint,5,opt,name=status_code,json=statusCode,proto3,enum=tensorflow.error.Code" json:"status_code,omitempty"`
	StatusErrorMessage   string   `protobuf:"bytes,6,opt,name=status_error_message,json=statusErrorMessage,proto3" json:"status_error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunGraphResponse) Reset()         { *m = RunGraphResponse{} }
func (m *RunGraphResponse) String() string { return proto.CompactTextString(m) }
func (*RunGraphResponse) ProtoMessage()    {}
func (*RunGraphResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{14}
}
func (m *RunGraphResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunGraphResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RunGraphResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunGraphResponse.Merge(m, src)
}
func (m *RunGraphResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunGraphResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunGraphResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunGraphResponse proto.InternalMessageInfo

func (m *RunGraphResponse) GetRecv() []*NamedTensorProto {
	if m != nil {
		return m.Recv
	}
	return nil
}

func (m *RunGraphResponse) GetStepStats() *step_stats_go_proto.StepStats {
	if m != nil {
		return m.StepStats
	}
	return nil
}

func (m *RunGraphResponse) GetCostGraph() *cost_graph_go_proto.CostGraphDef {
	if m != nil {
		return m.CostGraph
	}
	return nil
}

func (m *RunGraphResponse) GetPartitionGraph() []*graph_go_proto.GraphDef {
	if m != nil {
		return m.PartitionGraph
	}
	return nil
}

func (m *RunGraphResponse) GetStatusCode() Code {
	if m != nil {
		return m.StatusCode
	}
	return Code_OK
}

func (m *RunGraphResponse) GetStatusErrorMessage() string {
	if m != nil {
		return m.StatusErrorMessage
	}
	return ""
}

type CleanupGraphRequest struct {
	StepId               int64    `protobuf:"varint,1,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CleanupGraphRequest) Reset()         { *m = CleanupGraphRequest{} }
func (m *CleanupGraphRequest) String() string { return proto.CompactTextString(m) }
func (*CleanupGraphRequest) ProtoMessage()    {}
func (*CleanupGraphRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{15}
}
func (m *CleanupGraphRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CleanupGraphRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CleanupGraphRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CleanupGraphRequest.Merge(m, src)
}
func (m *CleanupGraphRequest) XXX_Size() int {
	return m.Size()
}
func (m *CleanupGraphRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CleanupGraphRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CleanupGraphRequest proto.InternalMessageInfo

func (m *CleanupGraphRequest) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

type CleanupGraphResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CleanupGraphResponse) Reset()         { *m = CleanupGraphResponse{} }
func (m *CleanupGraphResponse) String() string { return proto.CompactTextString(m) }
func (*CleanupGraphResponse) ProtoMessage()    {}
func (*CleanupGraphResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{16}
}
func (m *CleanupGraphResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CleanupGraphResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CleanupGraphResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CleanupGraphResponse.Merge(m, src)
}
func (m *CleanupGraphResponse) XXX_Size() int {
	return m.Size()
}
func (m *CleanupGraphResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CleanupGraphResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CleanupGraphResponse proto.InternalMessageInfo

type RecvTensorRequest struct {
	// The step in which the tensor will be produced.
	//
	// REQUIRED: This must eventually correspond to the `step_id` passed
	// into a RunGraph call on the same WorkerService.
	StepId int64 `protobuf:"varint,1,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	// A key identifying the channel to receive tensors from. A RecvTensor request
	// retrieves one tensor from the channel, but multiple tensors can be sent and
	// received over the same channel with multiple RecvTensor requests. See
	// rendezvous.h for details.
	RendezvousKey string `protobuf:"bytes,2,opt,name=rendezvous_key,json=rendezvousKey,proto3" json:"rendezvous_key,omitempty"`
	// If true, use an out-of-band DMA mechanism to transfer the
	// received tensor.
	DmaOk bool `protobuf:"varint,3,opt,name=dma_ok,json=dmaOk,proto3" json:"dma_ok,omitempty"`
	// Optional information on client-side device locality.
	ClientLocality *device_attributes_go_proto.DeviceLocality `protobuf:"bytes,4,opt,name=client_locality,json=clientLocality,proto3" json:"client_locality,omitempty"`
	// Optional information on server-side device locality.
	ServerLocality *device_attributes_go_proto.DeviceLocality `protobuf:"bytes,5,opt,name=server_locality,json=serverLocality,proto3" json:"server_locality,omitempty"`
	// Optional information needed by the RPC subsystem.
	TransportOptions *types.Any `protobuf:"bytes,6,opt,name=transport_options,json=transportOptions,proto3" json:"transport_options,omitempty"`
	// Unique identifier for this request. Every RecvTensorRequest must have a
	// unique request_id, and retried RecvTensorRequests must have the same
	// request_id. If request_id is zero, retry detection and response cache
	// are disabled.
	//
	// Retried RecvTensorRequests are problematic because a RecvTensor with no
	// corresponding sender will wait forever, and the tensor may have been
	// delivered to a previous retry. Workers use request_ids to reject retried
	// RecvTensor requests instead of waiting forever.
	RequestId            int64    `protobuf:"varint,7,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecvTensorRequest) Reset()         { *m = RecvTensorRequest{} }
func (m *RecvTensorRequest) String() string { return proto.CompactTextString(m) }
func (*RecvTensorRequest) ProtoMessage()    {}
func (*RecvTensorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{17}
}
func (m *RecvTensorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecvTensorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecvTensorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecvTensorRequest.Merge(m, src)
}
func (m *RecvTensorRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecvTensorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecvTensorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecvTensorRequest proto.InternalMessageInfo

func (m *RecvTensorRequest) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

func (m *RecvTensorRequest) GetRendezvousKey() string {
	if m != nil {
		return m.RendezvousKey
	}
	return ""
}

func (m *RecvTensorRequest) GetDmaOk() bool {
	if m != nil {
		return m.DmaOk
	}
	return false
}

func (m *RecvTensorRequest) GetClientLocality() *device_attributes_go_proto.DeviceLocality {
	if m != nil {
		return m.ClientLocality
	}
	return nil
}

func (m *RecvTensorRequest) GetServerLocality() *device_attributes_go_proto.DeviceLocality {
	if m != nil {
		return m.ServerLocality
	}
	return nil
}

func (m *RecvTensorRequest) GetTransportOptions() *types.Any {
	if m != nil {
		return m.TransportOptions
	}
	return nil
}

func (m *RecvTensorRequest) GetRequestId() int64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

type RecvTensorResponse struct {
	// The tensor as a proto.
	Tensor *tensor_go_proto.TensorProto `protobuf:"bytes,1,opt,name=tensor,proto3" json:"tensor,omitempty"`
	// If true, this tensor was the output of a dead node, and the
	// content is invalid.
	IsDead bool `protobuf:"varint,2,opt,name=is_dead,json=isDead,proto3" json:"is_dead,omitempty"`
	// The time at which tensor was available and started to be returned.
	SendStartMicros int64 `protobuf:"varint,3,opt,name=send_start_micros,json=sendStartMicros,proto3" json:"send_start_micros,omitempty"`
	// Optional additional information about how to receive the tensor,
	// e.g. in the event that `RecvTensorRequest.dma_ok` was true.
	TransportOptions *types.Any `protobuf:"bytes,4,opt,name=transport_options,json=transportOptions,proto3" json:"transport_options,omitempty"`
	// Whether the receiver should send a MarkRecvFinishedRequest to the sender
	// to ack the message.
	RequireAck           bool     `protobuf:"varint,5,opt,name=require_ack,json=requireAck,proto3" json:"require_ack,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecvTensorResponse) Reset()         { *m = RecvTensorResponse{} }
func (m *RecvTensorResponse) String() string { return proto.CompactTextString(m) }
func (*RecvTensorResponse) ProtoMessage()    {}
func (*RecvTensorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{18}
}
func (m *RecvTensorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecvTensorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecvTensorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecvTensorResponse.Merge(m, src)
}
func (m *RecvTensorResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecvTensorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecvTensorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecvTensorResponse proto.InternalMessageInfo

func (m *RecvTensorResponse) GetTensor() *tensor_go_proto.TensorProto {
	if m != nil {
		return m.Tensor
	}
	return nil
}

func (m *RecvTensorResponse) GetIsDead() bool {
	if m != nil {
		return m.IsDead
	}
	return false
}

func (m *RecvTensorResponse) GetSendStartMicros() int64 {
	if m != nil {
		return m.SendStartMicros
	}
	return 0
}

func (m *RecvTensorResponse) GetTransportOptions() *types.Any {
	if m != nil {
		return m.TransportOptions
	}
	return nil
}

func (m *RecvTensorResponse) GetRequireAck() bool {
	if m != nil {
		return m.RequireAck
	}
	return false
}

// Message for managing the response cache maintained on the sender side.
// Currently only used by the gRPC worker service.
type MarkRecvFinishedRequest struct {
	RequestId            int64    `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkRecvFinishedRequest) Reset()         { *m = MarkRecvFinishedRequest{} }
func (m *MarkRecvFinishedRequest) String() string { return proto.CompactTextString(m) }
func (*MarkRecvFinishedRequest) ProtoMessage()    {}
func (*MarkRecvFinishedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{19}
}
func (m *MarkRecvFinishedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkRecvFinishedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MarkRecvFinishedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkRecvFinishedRequest.Merge(m, src)
}
func (m *MarkRecvFinishedRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkRecvFinishedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkRecvFinishedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkRecvFinishedRequest proto.InternalMessageInfo

func (m *MarkRecvFinishedRequest) GetRequestId() int64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

type MarkRecvFinishedResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkRecvFinishedResponse) Reset()         { *m = MarkRecvFinishedResponse{} }
func (m *MarkRecvFinishedResponse) String() string { return proto.CompactTextString(m) }
func (*MarkRecvFinishedResponse) ProtoMessage()    {}
func (*MarkRecvFinishedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{20}
}
func (m *MarkRecvFinishedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkRecvFinishedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MarkRecvFinishedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkRecvFinishedResponse.Merge(m, src)
}
func (m *MarkRecvFinishedResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkRecvFinishedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkRecvFinishedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkRecvFinishedResponse proto.InternalMessageInfo

// Out-of-band request to begin or end logging, or
// to retrieve logs for particular steps.
type LoggingRequest struct {
	// If true, RPC logging will be enabled.
	EnableRpcLogging bool `protobuf:"varint,1,opt,name=enable_rpc_logging,json=enableRpcLogging,proto3" json:"enable_rpc_logging,omitempty"`
	// If true, RPC logging will be disabled.
	DisableRpcLogging bool `protobuf:"varint,4,opt,name=disable_rpc_logging,json=disableRpcLogging,proto3" json:"disable_rpc_logging,omitempty"`
	// If true, discard any saved logging data (for all steps).
	Clear bool `protobuf:"varint,2,opt,name=clear,proto3" json:"clear,omitempty"`
	// When set, requests all saved log data pertaining to the step.
	// Any log data retrieved is eliminated from the store and cannot be
	// retrieved again.
	FetchStepId          []int64  `protobuf:"varint,3,rep,packed,name=fetch_step_id,json=fetchStepId,proto3" json:"fetch_step_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoggingRequest) Reset()         { *m = LoggingRequest{} }
func (m *LoggingRequest) String() string { return proto.CompactTextString(m) }
func (*LoggingRequest) ProtoMessage()    {}
func (*LoggingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{21}
}
func (m *LoggingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LoggingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggingRequest.Merge(m, src)
}
func (m *LoggingRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoggingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoggingRequest proto.InternalMessageInfo

func (m *LoggingRequest) GetEnableRpcLogging() bool {
	if m != nil {
		return m.EnableRpcLogging
	}
	return false
}

func (m *LoggingRequest) GetDisableRpcLogging() bool {
	if m != nil {
		return m.DisableRpcLogging
	}
	return false
}

func (m *LoggingRequest) GetClear() bool {
	if m != nil {
		return m.Clear
	}
	return false
}

func (m *LoggingRequest) GetFetchStepId() []int64 {
	if m != nil {
		return m.FetchStepId
	}
	return nil
}

type LabeledStepStats struct {
	StepId               int64                          `protobuf:"varint,1,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	StepStats            *step_stats_go_proto.StepStats `protobuf:"bytes,2,opt,name=step_stats,json=stepStats,proto3" json:"step_stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *LabeledStepStats) Reset()         { *m = LabeledStepStats{} }
func (m *LabeledStepStats) String() string { return proto.CompactTextString(m) }
func (*LabeledStepStats) ProtoMessage()    {}
func (*LabeledStepStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{22}
}
func (m *LabeledStepStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabeledStepStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LabeledStepStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabeledStepStats.Merge(m, src)
}
func (m *LabeledStepStats) XXX_Size() int {
	return m.Size()
}
func (m *LabeledStepStats) XXX_DiscardUnknown() {
	xxx_messageInfo_LabeledStepStats.DiscardUnknown(m)
}

var xxx_messageInfo_LabeledStepStats proto.InternalMessageInfo

func (m *LabeledStepStats) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

func (m *LabeledStepStats) GetStepStats() *step_stats_go_proto.StepStats {
	if m != nil {
		return m.StepStats
	}
	return nil
}

type LoggingResponse struct {
	Step                 []*LabeledStepStats `protobuf:"bytes,1,rep,name=step,proto3" json:"step,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LoggingResponse) Reset()         { *m = LoggingResponse{} }
func (m *LoggingResponse) String() string { return proto.CompactTextString(m) }
func (*LoggingResponse) ProtoMessage()    {}
func (*LoggingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{23}
}
func (m *LoggingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LoggingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggingResponse.Merge(m, src)
}
func (m *LoggingResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoggingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoggingResponse proto.InternalMessageInfo

func (m *LoggingResponse) GetStep() []*LabeledStepStats {
	if m != nil {
		return m.Step
	}
	return nil
}

type TraceOpts struct {
	// Length of the trace to be taken, in seconds.
	Duration float64 `protobuf:"fixed64,1,opt,name=duration,proto3" json:"duration,omitempty"`
	// If true, capture step profile locally in each worker. Currently
	// unimplemented.
	UseStepProfiler bool `protobuf:"varint,2,opt,name=use_step_profiler,json=useStepProfiler,proto3" json:"use_step_profiler,omitempty"`
	// If true, capture kernel events from each worker.
	UseKernelProfiler bool `protobuf:"varint,3,opt,name=use_kernel_profiler,json=useKernelProfiler,proto3" json:"use_kernel_profiler,omitempty"`
	// If true, capture extended profiling events from TensorFlow process.
	UseExtendedProfiler bool `protobuf:"varint,4,opt,name=use_extended_profiler,json=useExtendedProfiler,proto3" json:"use_extended_profiler,omitempty"`
	// If true, capture GPU profiling events locally on each
	// machine. Currently unimplemented.
	UseGpuProfiler bool `protobuf:"varint,5,opt,name=use_gpu_profiler,json=useGpuProfiler,proto3" json:"use_gpu_profiler,omitempty"`
	// If true, collect sampled profile events. Currently unimplemented.
	UseSampleProfiler    bool     `protobuf:"varint,6,opt,name=use_sample_profiler,json=useSampleProfiler,proto3" json:"use_sample_profiler,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TraceOpts) Reset()         { *m = TraceOpts{} }
func (m *TraceOpts) String() string { return proto.CompactTextString(m) }
func (*TraceOpts) ProtoMessage()    {}
func (*TraceOpts) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{24}
}
func (m *TraceOpts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceOpts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TraceOpts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceOpts.Merge(m, src)
}
func (m *TraceOpts) XXX_Size() int {
	return m.Size()
}
func (m *TraceOpts) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceOpts.DiscardUnknown(m)
}

var xxx_messageInfo_TraceOpts proto.InternalMessageInfo

func (m *TraceOpts) GetDuration() float64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *TraceOpts) GetUseStepProfiler() bool {
	if m != nil {
		return m.UseStepProfiler
	}
	return false
}

func (m *TraceOpts) GetUseKernelProfiler() bool {
	if m != nil {
		return m.UseKernelProfiler
	}
	return false
}

func (m *TraceOpts) GetUseExtendedProfiler() bool {
	if m != nil {
		return m.UseExtendedProfiler
	}
	return false
}

func (m *TraceOpts) GetUseGpuProfiler() bool {
	if m != nil {
		return m.UseGpuProfiler
	}
	return false
}

func (m *TraceOpts) GetUseSampleProfiler() bool {
	if m != nil {
		return m.UseSampleProfiler
	}
	return false
}

// Out-of-band request to configure distributed tracing.
type TracingRequest struct {
	Options              *TraceOpts `protobuf:"bytes,1,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TracingRequest) Reset()         { *m = TracingRequest{} }
func (m *TracingRequest) String() string { return proto.CompactTextString(m) }
func (*TracingRequest) ProtoMessage()    {}
func (*TracingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{25}
}
func (m *TracingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TracingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracingRequest.Merge(m, src)
}
func (m *TracingRequest) XXX_Size() int {
	return m.Size()
}
func (m *TracingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TracingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TracingRequest proto.InternalMessageInfo

func (m *TracingRequest) GetOptions() *TraceOpts {
	if m != nil {
		return m.Options
	}
	return nil
}

type TracingResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TracingResponse) Reset()         { *m = TracingResponse{} }
func (m *TracingResponse) String() string { return proto.CompactTextString(m) }
func (*TracingResponse) ProtoMessage()    {}
func (*TracingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{26}
}
func (m *TracingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TracingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracingResponse.Merge(m, src)
}
func (m *TracingResponse) XXX_Size() int {
	return m.Size()
}
func (m *TracingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TracingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TracingResponse proto.InternalMessageInfo

type RecvBufRequest struct {
	// Used at server side to find the correct BufRendezvous.
	StepId int64 `protobuf:"varint,1,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	// Arbitrary string identifying a BufRendezvous entry.
	BufRendezvousKey string `protobuf:"bytes,2,opt,name=buf_rendezvous_key,json=bufRendezvousKey,proto3" json:"buf_rendezvous_key,omitempty"`
	// Size of value expected, must agree with BufRendezvous entry.
	NumBytes int64 `protobuf:"varint,3,opt,name=num_bytes,json=numBytes,proto3" json:"num_bytes,omitempty"`
	// When RDMA is in use, address of destination field on client.
	BufPtr uint64 `protobuf:"fixed64,4,opt,name=buf_ptr,json=bufPtr,proto3" json:"buf_ptr,omitempty"`
	// Optional information on client-side device locality.
	ClientLocality *device_attributes_go_proto.DeviceLocality `protobuf:"bytes,5,opt,name=client_locality,json=clientLocality,proto3" json:"client_locality,omitempty"`
	// Optional information on server-side device locality.
	ServerLocality *device_attributes_go_proto.DeviceLocality `protobuf:"bytes,6,opt,name=server_locality,json=serverLocality,proto3" json:"server_locality,omitempty"`
	// Optional, implementation-specific data.
	TransportOptions *types.Any `protobuf:"bytes,7,opt,name=transport_options,json=transportOptions,proto3" json:"transport_options,omitempty"`
	// For annotating timeline and device incarnation check.
	SrcDevice string `protobuf:"bytes,8,opt,name=src_device,json=srcDevice,proto3" json:"src_device,omitempty"`
	// Optional, for annotating the timeline.
	DstDevice string `protobuf:"bytes,9,opt,name=dst_device,json=dstDevice,proto3" json:"dst_device,omitempty"`
	// Depending on the RPC system in use, it may be necessary to set this
	// id to detect resends of RPCs where the server is not aware that
	// the prior RPC failed.
	RequestId int64 `protobuf:"varint,10,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Incarnation number of the source device, used to detect worker failures.
	SrcIncarnation       uint64   `protobuf:"varint,11,opt,name=src_incarnation,json=srcIncarnation,proto3" json:"src_incarnation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecvBufRequest) Reset()         { *m = RecvBufRequest{} }
func (m *RecvBufRequest) String() string { return proto.CompactTextString(m) }
func (*RecvBufRequest) ProtoMessage()    {}
func (*RecvBufRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{27}
}
func (m *RecvBufRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecvBufRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecvBufRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecvBufRequest.Merge(m, src)
}
func (m *RecvBufRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecvBufRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecvBufRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecvBufRequest proto.InternalMessageInfo

func (m *RecvBufRequest) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

func (m *RecvBufRequest) GetBufRendezvousKey() string {
	if m != nil {
		return m.BufRendezvousKey
	}
	return ""
}

func (m *RecvBufRequest) GetNumBytes() int64 {
	if m != nil {
		return m.NumBytes
	}
	return 0
}

func (m *RecvBufRequest) GetBufPtr() uint64 {
	if m != nil {
		return m.BufPtr
	}
	return 0
}

func (m *RecvBufRequest) GetClientLocality() *device_attributes_go_proto.DeviceLocality {
	if m != nil {
		return m.ClientLocality
	}
	return nil
}

func (m *RecvBufRequest) GetServerLocality() *device_attributes_go_proto.DeviceLocality {
	if m != nil {
		return m.ServerLocality
	}
	return nil
}

func (m *RecvBufRequest) GetTransportOptions() *types.Any {
	if m != nil {
		return m.TransportOptions
	}
	return nil
}

func (m *RecvBufRequest) GetSrcDevice() string {
	if m != nil {
		return m.SrcDevice
	}
	return ""
}

func (m *RecvBufRequest) GetDstDevice() string {
	if m != nil {
		return m.DstDevice
	}
	return ""
}

func (m *RecvBufRequest) GetRequestId() int64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *RecvBufRequest) GetSrcIncarnation() uint64 {
	if m != nil {
		return m.SrcIncarnation
	}
	return 0
}

type RecvBufResponse struct {
	BufPtr   uint64 `protobuf:"fixed64,1,opt,name=buf_ptr,json=bufPtr,proto3" json:"buf_ptr,omitempty"`
	NumBytes int64  `protobuf:"varint,2,opt,name=num_bytes,json=numBytes,proto3" json:"num_bytes,omitempty"`
	IsDead   bool   `protobuf:"varint,3,opt,name=is_dead,json=isDead,proto3" json:"is_dead,omitempty"`
	// Optional, implementation-specific data.
	TransportOptions *types.Any `protobuf:"bytes,4,opt,name=transport_options,json=transportOptions,proto3" json:"transport_options,omitempty"`
	// Optional, for timeline.
	SendStartMicros int64 `protobuf:"varint,5,opt,name=send_start_micros,json=sendStartMicros,proto3" json:"send_start_micros,omitempty"`
	// Whether the receiver should send a MarkRecvFinishedRequest to the sender
	// to ack the message.
	RequireAck           bool     `protobuf:"varint,6,opt,name=require_ack,json=requireAck,proto3" json:"require_ack,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecvBufResponse) Reset()         { *m = RecvBufResponse{} }
func (m *RecvBufResponse) String() string { return proto.CompactTextString(m) }
func (*RecvBufResponse) ProtoMessage()    {}
func (*RecvBufResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{28}
}
func (m *RecvBufResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecvBufResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecvBufResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecvBufResponse.Merge(m, src)
}
func (m *RecvBufResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecvBufResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecvBufResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecvBufResponse proto.InternalMessageInfo

func (m *RecvBufResponse) GetBufPtr() uint64 {
	if m != nil {
		return m.BufPtr
	}
	return 0
}

func (m *RecvBufResponse) GetNumBytes() int64 {
	if m != nil {
		return m.NumBytes
	}
	return 0
}

func (m *RecvBufResponse) GetIsDead() bool {
	if m != nil {
		return m.IsDead
	}
	return false
}

func (m *RecvBufResponse) GetTransportOptions() *types.Any {
	if m != nil {
		return m.TransportOptions
	}
	return nil
}

func (m *RecvBufResponse) GetSendStartMicros() int64 {
	if m != nil {
		return m.SendStartMicros
	}
	return 0
}

func (m *RecvBufResponse) GetRequireAck() bool {
	if m != nil {
		return m.RequireAck
	}
	return false
}

// Supplies one or more device names as members of the group identified by
// group_key.  Service will respond when all group_size devices become known.
// All devices in group must have same type.
type CompleteGroupRequest struct {
	GroupKey             int32                                        `protobuf:"varint,1,opt,name=group_key,json=groupKey,proto3" json:"group_key,omitempty"`
	GroupSize            int32                                        `protobuf:"varint,2,opt,name=group_size,json=groupSize,proto3" json:"group_size,omitempty"`
	DeviceType           string                                       `protobuf:"bytes,3,opt,name=device_type,json=deviceType,proto3" json:"device_type,omitempty"`
	CollectiveType       int32                                        `protobuf:"varint,5,opt,name=collective_type,json=collectiveType,proto3" json:"collective_type,omitempty"`
	DeviceAttributes     *device_attributes_go_proto.DeviceAttributes `protobuf:"bytes,6,opt,name=device_attributes,json=deviceAttributes,proto3" json:"device_attributes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *CompleteGroupRequest) Reset()         { *m = CompleteGroupRequest{} }
func (m *CompleteGroupRequest) String() string { return proto.CompactTextString(m) }
func (*CompleteGroupRequest) ProtoMessage()    {}
func (*CompleteGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{29}
}
func (m *CompleteGroupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteGroupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompleteGroupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteGroupRequest.Merge(m, src)
}
func (m *CompleteGroupRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompleteGroupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteGroupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteGroupRequest proto.InternalMessageInfo

func (m *CompleteGroupRequest) GetGroupKey() int32 {
	if m != nil {
		return m.GroupKey
	}
	return 0
}

func (m *CompleteGroupRequest) GetGroupSize() int32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

func (m *CompleteGroupRequest) GetDeviceType() string {
	if m != nil {
		return m.DeviceType
	}
	return ""
}

func (m *CompleteGroupRequest) GetCollectiveType() int32 {
	if m != nil {
		return m.CollectiveType
	}
	return 0
}

func (m *CompleteGroupRequest) GetDeviceAttributes() *device_attributes_go_proto.DeviceAttributes {
	if m != nil {
		return m.DeviceAttributes
	}
	return nil
}

// Gives the complete membership of the group identified by group_key.
type CompleteGroupResponse struct {
	GroupKey             int32                                          `protobuf:"varint,1,opt,name=group_key,json=groupKey,proto3" json:"group_key,omitempty"`
	GroupSize            int32                                          `protobuf:"varint,2,opt,name=group_size,json=groupSize,proto3" json:"group_size,omitempty"`
	DeviceType           string                                         `protobuf:"bytes,3,opt,name=device_type,json=deviceType,proto3" json:"device_type,omitempty"`
	NumTasks             int32                                          `protobuf:"varint,4,opt,name=num_tasks,json=numTasks,proto3" json:"num_tasks,omitempty"`
	CommunicatorKey      []byte                                         `protobuf:"bytes,7,opt,name=communicator_key,json=communicatorKey,proto3" json:"communicator_key,omitempty"`
	DeviceAttributes     []*device_attributes_go_proto.DeviceAttributes `protobuf:"bytes,8,rep,name=device_attributes,json=deviceAttributes,proto3" json:"device_attributes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                       `json:"-"`
	XXX_unrecognized     []byte                                         `json:"-"`
	XXX_sizecache        int32                                          `json:"-"`
}

func (m *CompleteGroupResponse) Reset()         { *m = CompleteGroupResponse{} }
func (m *CompleteGroupResponse) String() string { return proto.CompactTextString(m) }
func (*CompleteGroupResponse) ProtoMessage()    {}
func (*CompleteGroupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{30}
}
func (m *CompleteGroupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteGroupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompleteGroupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteGroupResponse.Merge(m, src)
}
func (m *CompleteGroupResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompleteGroupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteGroupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteGroupResponse proto.InternalMessageInfo

func (m *CompleteGroupResponse) GetGroupKey() int32 {
	if m != nil {
		return m.GroupKey
	}
	return 0
}

func (m *CompleteGroupResponse) GetGroupSize() int32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

func (m *CompleteGroupResponse) GetDeviceType() string {
	if m != nil {
		return m.DeviceType
	}
	return ""
}

func (m *CompleteGroupResponse) GetNumTasks() int32 {
	if m != nil {
		return m.NumTasks
	}
	return 0
}

func (m *CompleteGroupResponse) GetCommunicatorKey() []byte {
	if m != nil {
		return m.CommunicatorKey
	}
	return nil
}

func (m *CompleteGroupResponse) GetDeviceAttributes() []*device_attributes_go_proto.DeviceAttributes {
	if m != nil {
		return m.DeviceAttributes
	}
	return nil
}

// Supplies data about one collective op belonging to the instance identified
// by instance_key.  Service will respond when all group_size ops have
// become known.  Most of the data being sent is for correctness checking,
// to ensure that all ops in the instance share common attributes.
type CompleteInstanceRequest struct {
	Name                 string                                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 int32                                   `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	DataType             types_go_proto.DataType                 `protobuf:"varint,3,opt,name=data_type,json=dataType,proto3,enum=tensorflow.DataType" json:"data_type,omitempty"`
	Shape                *tensor_shape_go_proto.TensorShapeProto `protobuf:"bytes,4,opt,name=shape,proto3" json:"shape,omitempty"`
	GroupKey             int32                                   `protobuf:"varint,5,opt,name=group_key,json=groupKey,proto3" json:"group_key,omitempty"`
	GroupSize            int32                                   `protobuf:"varint,6,opt,name=group_size,json=groupSize,proto3" json:"group_size,omitempty"`
	InstanceKey          int32                                   `protobuf:"varint,7,opt,name=instance_key,json=instanceKey,proto3" json:"instance_key,omitempty"`
	DeviceType           string                                  `protobuf:"bytes,8,opt,name=device_type,json=deviceType,proto3" json:"device_type,omitempty"`
	SubdivOffset         []int32                                 `protobuf:"varint,9,rep,packed,name=subdiv_offset,json=subdivOffset,proto3" json:"subdiv_offset,omitempty"`
	Device               string                                  `protobuf:"bytes,10,opt,name=device,proto3" json:"device,omitempty"`
	IsSource             bool                                    `protobuf:"varint,11,opt,name=is_source,json=isSource,proto3" json:"is_source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *CompleteInstanceRequest) Reset()         { *m = CompleteInstanceRequest{} }
func (m *CompleteInstanceRequest) String() string { return proto.CompactTextString(m) }
func (*CompleteInstanceRequest) ProtoMessage()    {}
func (*CompleteInstanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{31}
}
func (m *CompleteInstanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteInstanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompleteInstanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteInstanceRequest.Merge(m, src)
}
func (m *CompleteInstanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompleteInstanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteInstanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteInstanceRequest proto.InternalMessageInfo

func (m *CompleteInstanceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CompleteInstanceRequest) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CompleteInstanceRequest) GetDataType() types_go_proto.DataType {
	if m != nil {
		return m.DataType
	}
	return types_go_proto.DataType_DT_INVALID
}

func (m *CompleteInstanceRequest) GetShape() *tensor_shape_go_proto.TensorShapeProto {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *CompleteInstanceRequest) GetGroupKey() int32 {
	if m != nil {
		return m.GroupKey
	}
	return 0
}

func (m *CompleteInstanceRequest) GetGroupSize() int32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

func (m *CompleteInstanceRequest) GetInstanceKey() int32 {
	if m != nil {
		return m.InstanceKey
	}
	return 0
}

func (m *CompleteInstanceRequest) GetDeviceType() string {
	if m != nil {
		return m.DeviceType
	}
	return ""
}

func (m *CompleteInstanceRequest) GetSubdivOffset() []int32 {
	if m != nil {
		return m.SubdivOffset
	}
	return nil
}

func (m *CompleteInstanceRequest) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *CompleteInstanceRequest) GetIsSource() bool {
	if m != nil {
		return m.IsSource
	}
	return false
}

// Confirms that every op in the instance has consistently declared itself.
// Also gives the source_rank in case of broadcast.
type CompleteInstanceResponse struct {
	InstanceKey          int32    `protobuf:"varint,1,opt,name=instance_key,json=instanceKey,proto3" json:"instance_key,omitempty"`
	SourceRank           int32    `protobuf:"varint,2,opt,name=source_rank,json=sourceRank,proto3" json:"source_rank,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompleteInstanceResponse) Reset()         { *m = CompleteInstanceResponse{} }
func (m *CompleteInstanceResponse) String() string { return proto.CompactTextString(m) }
func (*CompleteInstanceResponse) ProtoMessage()    {}
func (*CompleteInstanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{32}
}
func (m *CompleteInstanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteInstanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompleteInstanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteInstanceResponse.Merge(m, src)
}
func (m *CompleteInstanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompleteInstanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteInstanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteInstanceResponse proto.InternalMessageInfo

func (m *CompleteInstanceResponse) GetInstanceKey() int32 {
	if m != nil {
		return m.InstanceKey
	}
	return 0
}

func (m *CompleteInstanceResponse) GetSourceRank() int32 {
	if m != nil {
		return m.SourceRank
	}
	return 0
}

// Request for next agreed-upon step_id for the specified graph_keys.
// This is used to enable multiple graphs containing nodes from
// a common collective instance to coordinate using the same step_ids.
type GetStepSequenceRequest struct {
	GraphKey             []int64  `protobuf:"varint,1,rep,packed,name=graph_key,json=graphKey,proto3" json:"graph_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStepSequenceRequest) Reset()         { *m = GetStepSequenceRequest{} }
func (m *GetStepSequenceRequest) String() string { return proto.CompactTextString(m) }
func (*GetStepSequenceRequest) ProtoMessage()    {}
func (*GetStepSequenceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{33}
}
func (m *GetStepSequenceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStepSequenceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetStepSequenceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStepSequenceRequest.Merge(m, src)
}
func (m *GetStepSequenceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStepSequenceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStepSequenceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStepSequenceRequest proto.InternalMessageInfo

func (m *GetStepSequenceRequest) GetGraphKey() []int64 {
	if m != nil {
		return m.GraphKey
	}
	return nil
}

type StepSequence struct {
	GraphKey             int64    `protobuf:"varint,1,opt,name=graph_key,json=graphKey,proto3" json:"graph_key,omitempty"`
	NextStepId           int64    `protobuf:"varint,2,opt,name=next_step_id,json=nextStepId,proto3" json:"next_step_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StepSequence) Reset()         { *m = StepSequence{} }
func (m *StepSequence) String() string { return proto.CompactTextString(m) }
func (*StepSequence) ProtoMessage()    {}
func (*StepSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{34}
}
func (m *StepSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StepSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepSequence.Merge(m, src)
}
func (m *StepSequence) XXX_Size() int {
	return m.Size()
}
func (m *StepSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_StepSequence.DiscardUnknown(m)
}

var xxx_messageInfo_StepSequence proto.InternalMessageInfo

func (m *StepSequence) GetGraphKey() int64 {
	if m != nil {
		return m.GraphKey
	}
	return 0
}

func (m *StepSequence) GetNextStepId() int64 {
	if m != nil {
		return m.NextStepId
	}
	return 0
}

// Next valid step_ids for one or more graph_keys.
type GetStepSequenceResponse struct {
	StepSequence         []*StepSequence `protobuf:"bytes,1,rep,name=step_sequence,json=stepSequence,proto3" json:"step_sequence,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetStepSequenceResponse) Reset()         { *m = GetStepSequenceResponse{} }
func (m *GetStepSequenceResponse) String() string { return proto.CompactTextString(m) }
func (*GetStepSequenceResponse) ProtoMessage()    {}
func (*GetStepSequenceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f24b6dc95cbd078c, []int{35}
}
func (m *GetStepSequenceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStepSequenceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetStepSequenceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStepSequenceResponse.Merge(m, src)
}
func (m *GetStepSequenceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetStepSequenceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStepSequenceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStepSequenceResponse proto.InternalMessageInfo

func (m *GetStepSequenceResponse) GetStepSequence() []*StepSequence {
	if m != nil {
		return m.StepSequence
	}
	return nil
}

func init() {
	proto.RegisterType((*GetStatusRequest)(nil), "tensorflow.GetStatusRequest")
	proto.RegisterType((*GetStatusResponse)(nil), "tensorflow.GetStatusResponse")
	proto.RegisterType((*CreateWorkerSessionRequest)(nil), "tensorflow.CreateWorkerSessionRequest")
	proto.RegisterType((*CreateWorkerSessionResponse)(nil), "tensorflow.CreateWorkerSessionResponse")
	proto.RegisterType((*DeleteWorkerSessionRequest)(nil), "tensorflow.DeleteWorkerSessionRequest")
	proto.RegisterType((*DeleteWorkerSessionResponse)(nil), "tensorflow.DeleteWorkerSessionResponse")
	proto.RegisterType((*RegisterGraphRequest)(nil), "tensorflow.RegisterGraphRequest")
	proto.RegisterType((*RegisterGraphResponse)(nil), "tensorflow.RegisterGraphResponse")
	proto.RegisterType((*DeregisterGraphRequest)(nil), "tensorflow.DeregisterGraphRequest")
	proto.RegisterType((*DeregisterGraphResponse)(nil), "tensorflow.DeregisterGraphResponse")
	proto.RegisterType((*CleanupAllRequest)(nil), "tensorflow.CleanupAllRequest")
	proto.RegisterType((*CleanupAllResponse)(nil), "tensorflow.CleanupAllResponse")
	proto.RegisterType((*ExecutorOpts)(nil), "tensorflow.ExecutorOpts")
	proto.RegisterType((*RunGraphRequest)(nil), "tensorflow.RunGraphRequest")
	proto.RegisterType((*RunGraphResponse)(nil), "tensorflow.RunGraphResponse")
	proto.RegisterType((*CleanupGraphRequest)(nil), "tensorflow.CleanupGraphRequest")
	proto.RegisterType((*CleanupGraphResponse)(nil), "tensorflow.CleanupGraphResponse")
	proto.RegisterType((*RecvTensorRequest)(nil), "tensorflow.RecvTensorRequest")
	proto.RegisterType((*RecvTensorResponse)(nil), "tensorflow.RecvTensorResponse")
	proto.RegisterType((*MarkRecvFinishedRequest)(nil), "tensorflow.MarkRecvFinishedRequest")
	proto.RegisterType((*MarkRecvFinishedResponse)(nil), "tensorflow.MarkRecvFinishedResponse")
	proto.RegisterType((*LoggingRequest)(nil), "tensorflow.LoggingRequest")
	proto.RegisterType((*LabeledStepStats)(nil), "tensorflow.LabeledStepStats")
	proto.RegisterType((*LoggingResponse)(nil), "tensorflow.LoggingResponse")
	proto.RegisterType((*TraceOpts)(nil), "tensorflow.TraceOpts")
	proto.RegisterType((*TracingRequest)(nil), "tensorflow.TracingRequest")
	proto.RegisterType((*TracingResponse)(nil), "tensorflow.TracingResponse")
	proto.RegisterType((*RecvBufRequest)(nil), "tensorflow.RecvBufRequest")
	proto.RegisterType((*RecvBufResponse)(nil), "tensorflow.RecvBufResponse")
	proto.RegisterType((*CompleteGroupRequest)(nil), "tensorflow.CompleteGroupRequest")
	proto.RegisterType((*CompleteGroupResponse)(nil), "tensorflow.CompleteGroupResponse")
	proto.RegisterType((*CompleteInstanceRequest)(nil), "tensorflow.CompleteInstanceRequest")
	proto.RegisterType((*CompleteInstanceResponse)(nil), "tensorflow.CompleteInstanceResponse")
	proto.RegisterType((*GetStepSequenceRequest)(nil), "tensorflow.GetStepSequenceRequest")
	proto.RegisterType((*StepSequence)(nil), "tensorflow.StepSequence")
	proto.RegisterType((*GetStepSequenceResponse)(nil), "tensorflow.GetStepSequenceResponse")
}

func init() {
	proto.RegisterFile("tensorflow/core/protobuf/worker.proto", fileDescriptor_f24b6dc95cbd078c)
}

var fileDescriptor_f24b6dc95cbd078c = []byte{
	// 2311 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x5b, 0x6f, 0x1c, 0x49,
	0xf5, 0x57, 0x7b, 0x2e, 0xee, 0x39, 0x76, 0xc6, 0xe3, 0x8a, 0x1d, 0x4f, 0x9c, 0xcb, 0x7a, 0xfb,
	0xff, 0x0f, 0x98, 0x25, 0x6b, 0x27, 0x86, 0x65, 0xd1, 0x4a, 0x11, 0xd8, 0xe3, 0x6c, 0x70, 0x2e,
	0xc4, 0x2a, 0x7b, 0xc5, 0x8a, 0x07, 0x5a, 0x35, 0xdd, 0x35, 0xe3, 0xd6, 0xf4, 0x74, 0x35, 0x55,
	0xd5, 0x4e, 0x26, 0x8f, 0x7c, 0x03, 0x84, 0xc4, 0x17, 0xe0, 0x85, 0x8f, 0x82, 0xc4, 0x0b, 0x4f,
	0xc0, 0x0b, 0x68, 0x95, 0x27, 0x5e, 0x40, 0x3c, 0xf2, 0x88, 0xea, 0xd2, 0x3d, 0x3d, 0x17, 0xaf,
	0x93, 0x6c, 0x78, 0xab, 0x3a, 0xe7, 0x57, 0xa7, 0x4e, 0x9d, 0x5b, 0x9d, 0x2a, 0xb8, 0x23, 0x69,
	0x22, 0x18, 0xef, 0xc5, 0xec, 0xc5, 0x6e, 0xc0, 0x38, 0xdd, 0x4d, 0x39, 0x93, 0xac, 0x9b, 0xf5,
	0x76, 0x5f, 0x30, 0x3e, 0xa0, 0x7c, 0x47, 0xcf, 0x11, 0x8c, 0x61, 0x9b, 0xd7, 0xfb, 0x8c, 0xf5,
	0xe3, 0x12, 0x92, 0x24, 0x23, 0x03, 0xdb, 0xfc, 0x68, 0x5a, 0x5a, 0x8f, 0x93, 0x21, 0x55, 0x92,
	0x76, 0x03, 0x26, 0xa4, 0xdf, 0xe7, 0x24, 0x3d, 0xb3, 0xd8, 0xfb, 0x17, 0x63, 0x43, 0x7a, 0x1e,
	0x05, 0xd4, 0x27, 0x52, 0xf2, 0xa8, 0x9b, 0x49, 0x2a, 0xec, 0x92, 0x3b, 0x17, 0x2f, 0x29, 0x4b,
	0xfe, 0x1a, 0x2d, 0x84, 0xa4, 0xa9, 0x2f, 0x24, 0x91, 0xb9, 0xc8, 0x6f, 0x5d, 0x8c, 0x35, 0x1c,
	0x8b, 0xbb, 0x7b, 0x19, 0xce, 0x17, 0x67, 0x24, 0xa5, 0x97, 0x2b, 0x2a, 0x47, 0xe9, 0xc5, 0xe7,
	0x29, 0x4c, 0x1a, 0xb0, 0xa4, 0x17, 0xf5, 0x2d, 0xec, 0xff, 0x2f, 0x84, 0x85, 0xb4, 0x9b, 0xf5,
	0x2f, 0x3a, 0x75, 0x81, 0xa2, 0x9c, 0x33, 0xee, 0x07, 0x2c, 0x2c, 0x36, 0xfe, 0xee, 0x85, 0xd8,
	0x84, 0x0c, 0x69, 0xe8, 0x4f, 0x1c, 0xfd, 0xde, 0x85, 0xe0, 0x31, 0xc3, 0x17, 0x94, 0x9f, 0xe7,
	0xd1, 0xe2, 0x21, 0x68, 0x3d, 0xa2, 0xf2, 0x44, 0x12, 0x99, 0x09, 0x4c, 0x7f, 0x99, 0x51, 0x21,
	0xbd, 0x5f, 0xc0, 0x6a, 0x89, 0x26, 0x52, 0x96, 0x08, 0x8a, 0x8e, 0x60, 0x75, 0xc6, 0xd7, 0x6d,
	0x67, 0xab, 0xb2, 0xbd, 0xb4, 0x77, 0x73, 0x67, 0x2c, 0x7d, 0xe7, 0x50, 0x83, 0xf6, 0x0b, 0x0c,
	0x6e, 0x85, 0x53, 0x14, 0xef, 0x2f, 0x0b, 0xb0, 0xd9, 0xe1, 0x94, 0x48, 0xfa, 0x33, 0x1d, 0xb8,
	0x27, 0x54, 0x88, 0x88, 0x25, 0x76, 0x7b, 0x74, 0x07, 0x9a, 0xc2, 0x50, 0xfc, 0x33, 0x92, 0x84,
	0x31, 0x6d, 0x3b, 0x5b, 0xce, 0x76, 0x03, 0x5f, 0xb1, 0xd4, 0x9f, 0x68, 0x22, 0xfa, 0x3e, 0x80,
	0x39, 0x89, 0x1f, 0xd2, 0x5e, 0x7b, 0x61, 0xcb, 0xd9, 0x5e, 0xda, 0x5b, 0x2f, 0x6b, 0x72, 0xa2,
	0xb9, 0x87, 0xb4, 0x87, 0x1b, 0x22, 0x1f, 0xa2, 0x3d, 0x58, 0x8f, 0x04, 0x8b, 0x89, 0xa4, 0x7e,
	0xbe, 0x89, 0x8a, 0x31, 0xda, 0xae, 0x6c, 0x39, 0xdb, 0x2e, 0xbe, 0x6a, 0x99, 0x56, 0x25, 0x65,
	0x03, 0x8a, 0xbe, 0x84, 0xeb, 0x41, 0x9c, 0x09, 0xa9, 0xb7, 0x9a, 0x36, 0x41, 0xf5, 0x0d, 0x4c,
	0xb0, 0x61, 0x97, 0x4f, 0x33, 0xd0, 0x07, 0xb0, 0x34, 0x24, 0x5a, 0xb0, 0x24, 0x62, 0xd0, 0xae,
	0xe9, 0x73, 0x82, 0x21, 0x9d, 0x12, 0x31, 0x40, 0x1f, 0x03, 0xb2, 0x80, 0x28, 0x09, 0x08, 0x4f,
	0x88, 0x8c, 0x58, 0xd2, 0xae, 0x6f, 0x39, 0xdb, 0x15, 0xbc, 0x6a, 0x38, 0x47, 0x63, 0x86, 0x77,
	0x0b, 0x6e, 0xcc, 0x35, 0xac, 0xf1, 0xa1, 0xd7, 0x81, 0xcd, 0x43, 0x1a, 0xd3, 0x6f, 0x64, 0x77,
	0xb5, 0xc7, 0x5c, 0x21, 0x76, 0x8f, 0x3f, 0x56, 0x60, 0x0d, 0xd3, 0x7e, 0xa4, 0x54, 0x7b, 0xa4,
	0x32, 0xfd, 0x2d, 0xdd, 0xfa, 0x23, 0xb8, 0x19, 0xe8, 0x23, 0xf8, 0xa6, 0xaa, 0x15, 0x6e, 0x0a,
	0x48, 0x1c, 0xd3, 0x50, 0x9f, 0xdd, 0xc5, 0xd7, 0x83, 0xd9, 0x63, 0x76, 0x34, 0x00, 0xdd, 0x87,
	0x86, 0xae, 0x30, 0xa5, 0xb0, 0x58, 0x2b, 0x7b, 0x47, 0x2b, 0xa5, 0xa2, 0xc2, 0xed, 0xdb, 0x11,
	0xba, 0x0b, 0xad, 0x33, 0x22, 0xfc, 0x80, 0x25, 0x92, 0xb3, 0xd8, 0x57, 0x30, 0x13, 0x0f, 0x07,
	0x0b, 0x6d, 0x07, 0x37, 0xcf, 0x88, 0xe8, 0x18, 0xd6, 0xe7, 0x31, 0x7b, 0x81, 0x1e, 0xc0, 0x15,
	0xb3, 0x01, 0x4b, 0x95, 0xd1, 0x55, 0x08, 0xa8, 0x4d, 0xda, 0x33, 0x9b, 0x3c, 0x37, 0x7c, 0xbc,
	0xdc, 0x2f, 0xcd, 0xd4, 0x72, 0x5d, 0x0b, 0x8a, 0xe5, 0xb5, 0xd9, 0xe5, 0x87, 0x0a, 0x50, 0x2c,
	0x0f, 0x4b, 0x33, 0x74, 0x0f, 0xd6, 0x02, 0x16, 0xc7, 0x34, 0x90, 0xd1, 0x39, 0x35, 0x55, 0xda,
	0x1f, 0xd0, 0x51, 0x7b, 0x51, 0xc7, 0x04, 0x1a, 0xf3, 0xb4, 0x0a, 0x4f, 0xe8, 0x08, 0x7d, 0x06,
	0xcb, 0xa6, 0x46, 0xf9, 0x3a, 0xe5, 0xdb, 0xae, 0xde, 0x6f, 0xa3, 0xbc, 0x5f, 0x47, 0xf3, 0x8f,
	0x15, 0x1b, 0x2f, 0x05, 0xe3, 0x89, 0xf7, 0x19, 0xac, 0x4f, 0x39, 0xd3, 0x96, 0x83, 0x0f, 0xc1,
	0x9c, 0x6a, 0xd2, 0x97, 0x4b, 0x9a, 0x66, 0x03, 0xe5, 0x77, 0x0e, 0x5c, 0x3b, 0xa4, 0xfc, 0xcd,
	0x62, 0x61, 0xe1, 0x5d, 0x62, 0xa1, 0x72, 0x59, 0x2c, 0xbc, 0x81, 0x96, 0xd7, 0x61, 0x63, 0x46,
	0x49, 0x1b, 0xca, 0xf7, 0x61, 0xb5, 0x13, 0x53, 0x92, 0x64, 0xe9, 0x7e, 0x1c, 0xe7, 0xaa, 0xdf,
	0x84, 0x86, 0x8a, 0x13, 0x12, 0x25, 0x94, 0xeb, 0xfa, 0xd7, 0xc0, 0x63, 0x82, 0xb7, 0x06, 0xa8,
	0xbc, 0xc4, 0x0a, 0xfa, 0xbb, 0x03, 0xcb, 0x0f, 0x5f, 0xd2, 0x20, 0x93, 0x8c, 0x3f, 0x4f, 0xa5,
	0x50, 0x7a, 0x71, 0x1a, 0x30, 0x1e, 0xfa, 0xea, 0xae, 0x15, 0x5a, 0x2f, 0x17, 0x2f, 0x19, 0x5a,
	0x47, 0x91, 0xd0, 0xb7, 0x61, 0xc5, 0x42, 0x64, 0x34, 0xa4, 0x71, 0x94, 0xe4, 0x25, 0xaa, 0x69,
	0xc8, 0xa7, 0x96, 0x8a, 0x7e, 0x00, 0x1b, 0x16, 0x98, 0x12, 0x2e, 0x23, 0x15, 0x25, 0x26, 0x2c,
	0x4c, 0x60, 0xba, 0x78, 0xdd, 0xb0, 0x8f, 0x73, 0xae, 0x3e, 0xa4, 0x40, 0x8f, 0xc1, 0xe3, 0x34,
	0x65, 0x5c, 0xda, 0x2b, 0xc4, 0x27, 0x71, 0xcc, 0x02, 0x5d, 0x47, 0x84, 0x9f, 0xa5, 0x2c, 0xf1,
	0x19, 0x1b, 0xea, 0xe0, 0x74, 0xf1, 0x6d, 0x83, 0x3c, 0xd5, 0xc0, 0xfd, 0x31, 0xee, 0x8b, 0x94,
	0x25, 0xcf, 0xd9, 0xd0, 0xfb, 0x47, 0x05, 0x56, 0x70, 0x96, 0x5c, 0xe2, 0x63, 0xf7, 0x5d, 0x7c,
	0x0c, 0xdf, 0xdc, 0xc7, 0x68, 0x03, 0x16, 0x75, 0x37, 0x11, 0x85, 0x3a, 0xce, 0x2a, 0xb8, 0xae,
	0xa6, 0x47, 0x21, 0xfa, 0x04, 0x1a, 0xf4, 0x25, 0x0d, 0x54, 0x2a, 0xce, 0xcd, 0xc3, 0xb2, 0xd3,
	0xb0, 0xab, 0xa0, 0xda, 0x7d, 0xf7, 0xa0, 0x2a, 0x68, 0xa2, 0xe2, 0x6f, 0xa6, 0xf6, 0xff, 0x54,
	0x5d, 0xca, 0xc6, 0x4e, 0x26, 0x9d, 0x34, 0x12, 0x5d, 0x07, 0x97, 0xd3, 0xe0, 0x5c, 0x67, 0x6a,
	0x55, 0x07, 0xcd, 0xa2, 0x9a, 0xab, 0xf4, 0xbc, 0x05, 0x10, 0x09, 0xe3, 0x3b, 0x12, 0xdb, 0xf2,
	0xd6, 0x88, 0xc4, 0xb1, 0x21, 0xa0, 0x8f, 0xe1, 0x6a, 0x24, 0xfc, 0x98, 0x08, 0x99, 0x63, 0x7c,
	0x9e, 0x25, 0x3a, 0xdd, 0x5d, 0xdc, 0x8a, 0xc4, 0x53, 0x22, 0xa4, 0xc5, 0xe2, 0x2c, 0x41, 0x3f,
	0x86, 0x5b, 0x42, 0x32, 0x4e, 0x7d, 0xdd, 0x49, 0x08, 0x3f, 0x4a, 0x7c, 0x6e, 0xc3, 0xd0, 0xef,
	0xb2, 0x70, 0xd4, 0x6e, 0x18, 0x7b, 0x6a, 0xd0, 0x43, 0x8d, 0x39, 0x2a, 0x8a, 0xf7, 0x01, 0x0b,
	0xb5, 0x3e, 0xdc, 0xb8, 0x50, 0xd9, 0x6b, 0x49, 0xdb, 0xab, 0x61, 0x29, 0x47, 0xa1, 0xf7, 0xb7,
	0x05, 0x68, 0x8d, 0x5d, 0x6d, 0xab, 0xc1, 0x3d, 0xa8, 0xaa, 0xe3, 0xcc, 0xeb, 0x07, 0x66, 0x0d,
	0xa2, 0x90, 0xfa, 0xf6, 0x2e, 0x1a, 0xbc, 0xb9, 0xb7, 0xb7, 0xa4, 0xa9, 0xba, 0x7e, 0x05, 0x6e,
	0x88, 0x7c, 0x88, 0x3e, 0x05, 0x18, 0x37, 0xa7, 0x3a, 0x1f, 0xa6, 0x1c, 0xa6, 0x72, 0xa7, 0x28,
	0xf0, 0x8d, 0x20, 0x9f, 0xa1, 0x07, 0xb0, 0x32, 0x95, 0x1d, 0xf6, 0xe2, 0x9e, 0x7f, 0x35, 0x34,
	0xd3, 0x89, 0x64, 0x41, 0x9f, 0xc2, 0x92, 0xd0, 0xed, 0x90, 0x6e, 0xcd, 0x74, 0xa4, 0x34, 0xf7,
	0xae, 0x95, 0x97, 0x6a, 0x73, 0xef, 0x74, 0x58, 0x48, 0x31, 0x18, 0xa8, 0x1a, 0xab, 0x6a, 0x6d,
	0x17, 0x9a, 0xce, 0x6e, 0x48, 0x85, 0x20, 0x7d, 0xaa, 0xdd, 0xdc, 0xc0, 0xc8, 0xf0, 0xb4, 0x1b,
	0x9e, 0x19, 0x8e, 0xb7, 0x03, 0x57, 0x6d, 0x05, 0x99, 0xc8, 0xa6, 0x52, 0x08, 0x3b, 0xe5, 0x10,
	0xf6, 0xae, 0xc1, 0xda, 0x24, 0xde, 0xd6, 0x9c, 0x3f, 0x2f, 0xc0, 0x2a, 0xa6, 0xc1, 0xb9, 0x31,
	0xfd, 0x65, 0x62, 0x54, 0xb6, 0x72, 0x9a, 0x84, 0xf4, 0xd5, 0x39, 0xcb, 0x84, 0x0e, 0x53, 0x5b,
	0x91, 0xc7, 0x54, 0x15, 0xac, 0xeb, 0x50, 0x0f, 0x87, 0xc4, 0x67, 0x03, 0x5b, 0x8c, 0x6a, 0xe1,
	0x90, 0x3c, 0x1f, 0xa0, 0x0e, 0xac, 0x04, 0x71, 0x44, 0x13, 0xe9, 0xab, 0xd2, 0x10, 0x47, 0x72,
	0x64, 0x2f, 0xc5, 0xcd, 0xd9, 0xbe, 0xe8, 0xa9, 0x45, 0xe0, 0xa6, 0x59, 0x92, 0xcf, 0x95, 0x10,
	0xdb, 0xd0, 0x15, 0x42, 0x6a, 0x97, 0x0b, 0x31, 0x4b, 0x0a, 0x21, 0xfb, 0xb0, 0x2a, 0x39, 0x49,
	0x84, 0x2e, 0x6c, 0xf9, 0x0d, 0x5b, 0xb7, 0x5d, 0x80, 0x79, 0x0d, 0xed, 0xe4, 0x4d, 0xf1, 0xce,
	0x7e, 0x32, 0xc2, 0xad, 0x02, 0x9e, 0xdf, 0xb0, 0x93, 0x09, 0xb0, 0x38, 0x9d, 0x00, 0xff, 0x72,
	0x00, 0x95, 0x0d, 0x6b, 0x53, 0x60, 0x17, 0xea, 0x46, 0x4b, 0x6d, 0xd8, 0xa9, 0xfb, 0xb5, 0x1c,
	0xff, 0x16, 0xa6, 0x5c, 0x11, 0x09, 0x3f, 0xa4, 0xc4, 0x14, 0x25, 0x17, 0xd7, 0x23, 0x71, 0x48,
	0x49, 0x88, 0x3e, 0x82, 0x55, 0x55, 0x33, 0x54, 0x6a, 0x70, 0xe9, 0x0f, 0xa3, 0x80, 0x33, 0xa1,
	0xcd, 0x5d, 0xc1, 0x2b, 0x8a, 0x71, 0xa2, 0xe8, 0xcf, 0x34, 0x79, 0xfe, 0x71, 0xab, 0x6f, 0x75,
	0xdc, 0x0f, 0x60, 0x49, 0x1d, 0x2e, 0xe2, 0xd4, 0x27, 0xc1, 0xc0, 0x16, 0x7c, 0xb0, 0xa4, 0xfd,
	0x60, 0xe0, 0xfd, 0x10, 0x36, 0x9e, 0x11, 0x3e, 0x50, 0x67, 0xfe, 0x3c, 0x4a, 0x22, 0x71, 0x46,
	0xc3, 0x3c, 0x9c, 0x26, 0x4d, 0xe5, 0x4c, 0x9b, 0x6a, 0x13, 0xda, 0xb3, 0x2b, 0x6d, 0x7c, 0xfe,
	0xde, 0x81, 0xe6, 0x53, 0xd6, 0xef, 0x47, 0x49, 0x3f, 0x97, 0x76, 0x17, 0x10, 0x4d, 0x48, 0x37,
	0xa6, 0x3e, 0x4f, 0x03, 0x3f, 0x36, 0x4c, 0x7b, 0x37, 0xb6, 0x0c, 0x07, 0xa7, 0x81, 0x5d, 0x84,
	0x76, 0xe0, 0x6a, 0x18, 0x89, 0x19, 0xb8, 0xb9, 0xf3, 0x56, 0x2d, 0xab, 0x84, 0x5f, 0x83, 0x5a,
	0x10, 0x53, 0xc2, 0xad, 0xb5, 0xcd, 0x04, 0x79, 0x70, 0xa5, 0x47, 0x65, 0x70, 0xe6, 0xe7, 0x69,
	0xa1, 0x6a, 0x7a, 0x05, 0x2f, 0x69, 0xe2, 0x89, 0x49, 0x31, 0x02, 0xad, 0xa7, 0xa4, 0x4b, 0x63,
	0x1a, 0x16, 0x45, 0xe9, 0xe2, 0x44, 0x7a, 0xa7, 0xc2, 0xe6, 0x75, 0x60, 0xa5, 0x30, 0xc6, 0xb8,
	0xa6, 0x2a, 0xfe, 0xbc, 0x9a, 0x3a, 0xad, 0x0d, 0xd6, 0x48, 0xef, 0xd7, 0x0b, 0xd0, 0x38, 0xe5,
	0x24, 0xa0, 0xfa, 0x92, 0xda, 0x04, 0x37, 0xcc, 0xb8, 0x79, 0x30, 0x28, 0x15, 0x1d, 0x5c, 0xcc,
	0x55, 0x88, 0x65, 0x82, 0x9a, 0x33, 0xa7, 0x9c, 0xf5, 0xa2, 0x98, 0xe6, 0x76, 0x59, 0xc9, 0x04,
	0x55, 0x82, 0x8f, 0x2d, 0x59, 0xd9, 0x59, 0x61, 0x07, 0x94, 0x27, 0x34, 0x1e, 0xa3, 0x4d, 0xfe,
	0x2b, 0x31, 0x4f, 0x34, 0xa7, 0xc0, 0xef, 0xc1, 0xba, 0xc2, 0xd3, 0x97, 0x52, 0x55, 0x8e, 0x70,
	0xbc, 0xc2, 0x78, 0x46, 0x09, 0x7b, 0x68, 0x79, 0xc5, 0x9a, 0x6d, 0x68, 0xa9, 0x35, 0xfd, 0x34,
	0x1b, 0xc3, 0x4d, 0x20, 0x36, 0x33, 0x41, 0x1f, 0xa5, 0xd9, 0xb4, 0x36, 0x82, 0x0c, 0xd3, 0x98,
	0x8e, 0xc1, 0xf5, 0x42, 0x9b, 0x13, 0xcd, 0xc9, 0xf1, 0xde, 0x3e, 0x34, 0x95, 0x49, 0x4a, 0x51,
	0xb6, 0x0b, 0x8b, 0x79, 0xa2, 0x38, 0xb3, 0xde, 0x29, 0xec, 0x87, 0x73, 0x94, 0xb7, 0x0a, 0x2b,
	0x85, 0x08, 0x1b, 0xbc, 0x5f, 0x55, 0xa0, 0xa9, 0xa2, 0xfa, 0x20, 0xeb, 0x5d, 0x5a, 0x59, 0xef,
	0x02, 0xea, 0x66, 0x3d, 0x7f, 0x6e, 0x75, 0x6d, 0x75, 0x95, 0x80, 0x72, 0x81, 0xbd, 0x01, 0x8d,
	0x24, 0x1b, 0xfa, 0xdd, 0x91, 0x7a, 0x5b, 0x9a, 0xa4, 0x77, 0x93, 0x6c, 0x78, 0xa0, 0xe6, 0x6a,
	0x0f, 0x25, 0x2a, 0x95, 0xc6, 0x98, 0x75, 0x5c, 0xef, 0x66, 0xbd, 0x63, 0xc9, 0xe7, 0xd5, 0xdf,
	0xda, 0xfb, 0xa8, 0xbf, 0xf5, 0xf7, 0x53, 0x7f, 0x17, 0xdf, 0xb6, 0xfe, 0x0a, 0x1e, 0xd8, 0xa7,
	0xb6, 0x6d, 0x1a, 0x1b, 0x82, 0x07, 0x66, 0x67, 0xc5, 0x0e, 0x85, 0xcc, 0xd9, 0x0d, 0xc3, 0x0e,
	0x85, 0x1c, 0xb3, 0x4b, 0x25, 0x09, 0xa6, 0x4a, 0x92, 0x6a, 0xab, 0x95, 0xf0, 0xf2, 0x6b, 0x5a,
	0xb5, 0x38, 0x55, 0xdc, 0x14, 0x3c, 0x28, 0x3f, 0xa5, 0xff, 0xed, 0xc0, 0x4a, 0xe1, 0x62, 0x9b,
	0x92, 0x25, 0xfb, 0x3b, 0x13, 0xf6, 0x9f, 0xf0, 0xda, 0xc2, 0xac, 0xd7, 0xf2, 0x42, 0x5f, 0x99,
	0x28, 0xf4, 0xef, 0xa1, 0x78, 0xcf, 0xbd, 0x2b, 0x6a, 0xf3, 0xef, 0x8a, 0xa9, 0x42, 0x5f, 0x9f,
	0x29, 0xf4, 0xff, 0x74, 0x60, 0xad, 0xc3, 0x54, 0xfa, 0x48, 0xfa, 0x88, 0xb3, 0x2c, 0xcd, 0x63,
	0xfb, 0x86, 0x7a, 0x52, 0xb3, 0x2c, 0xd5, 0x91, 0xab, 0x4e, 0x5e, 0x53, 0x8f, 0x67, 0x96, 0xa5,
	0xb6, 0x7f, 0x35, 0x4c, 0x11, 0xbd, 0x32, 0xef, 0xb8, 0x1a, 0x36, 0xf0, 0x93, 0xe8, 0x15, 0x55,
	0xbb, 0xda, 0x4f, 0x13, 0x39, 0x4a, 0xcd, 0x1b, 0xa6, 0x81, 0xc1, 0x90, 0x4e, 0x47, 0x29, 0x55,
	0x1e, 0x29, 0x3d, 0x68, 0x35, 0xa8, 0xa6, 0x85, 0x34, 0xc7, 0x64, 0x0d, 0x9c, 0xfb, 0x03, 0x65,
	0x22, 0xf4, 0x2d, 0x7f, 0xa0, 0x1e, 0x57, 0xdd, 0x6a, 0xab, 0xe6, 0xfd, 0x66, 0x01, 0xd6, 0xa7,
	0xce, 0x6b, 0x1d, 0xfd, 0x3f, 0x3d, 0xb0, 0x0d, 0x16, 0x49, 0xc4, 0xc0, 0xb8, 0xbb, 0xa6, 0x83,
	0xe5, 0x54, 0xcd, 0xd1, 0x77, 0xa0, 0x15, 0xb0, 0xe1, 0x30, 0x4b, 0xa2, 0x80, 0x48, 0xc6, 0x8b,
	0xa7, 0xfd, 0x32, 0x5e, 0x29, 0xd3, 0x95, 0x1e, 0x73, 0xed, 0xe1, 0xbe, 0xcb, 0x8f, 0xdc, 0xe3,
	0xaa, 0x5b, 0x6b, 0xd5, 0x1f, 0x57, 0xdd, 0x7a, 0x6b, 0xd1, 0xfb, 0x55, 0x05, 0x36, 0x72, 0xab,
	0x1c, 0x25, 0x42, 0x92, 0x24, 0xa0, 0x79, 0x20, 0x20, 0xa8, 0x26, 0x64, 0x98, 0xbf, 0xb1, 0xf4,
	0x58, 0xd1, 0xf4, 0x41, 0x8d, 0x21, 0xf4, 0x18, 0xdd, 0x87, 0x46, 0x48, 0x24, 0x19, 0x5b, 0xa0,
	0x39, 0xd9, 0x68, 0x1f, 0x12, 0x49, 0x94, 0x2d, 0xb0, 0x1b, 0xda, 0x11, 0xda, 0x83, 0x9a, 0xfe,
	0x96, 0xb5, 0x09, 0x70, 0x73, 0xb6, 0x7d, 0x3a, 0x51, 0x6c, 0xd3, 0x43, 0x19, 0xe8, 0xa4, 0x9b,
	0x6a, 0x5f, 0xeb, 0xa6, 0xfa, 0xb4, 0x9b, 0x3e, 0x84, 0xe5, 0xc8, 0x9e, 0xae, 0x30, 0x72, 0x0d,
	0x2f, 0xe5, 0x34, 0x25, 0x61, 0xca, 0x93, 0xee, 0x8c, 0x27, 0xff, 0x0f, 0xae, 0x88, 0xac, 0x1b,
	0x46, 0xe7, 0x3e, 0xeb, 0xf5, 0x04, 0x95, 0xed, 0xc6, 0x56, 0x65, 0xbb, 0x86, 0x97, 0x0d, 0xf1,
	0xb9, 0xa6, 0xa1, 0x6b, 0x50, 0xb7, 0xb5, 0x0a, 0xb4, 0x00, 0x3b, 0x53, 0xca, 0x47, 0xc2, 0x17,
	0x2c, 0xe3, 0x01, 0xd5, 0x35, 0xc8, 0xc5, 0x6e, 0x24, 0x4e, 0xf4, 0xdc, 0x0b, 0xa1, 0x3d, 0xeb,
	0x83, 0xf1, 0xd7, 0xcb, 0x84, 0xe6, 0xce, 0x5c, 0xcd, 0x8d, 0x60, 0x9f, 0x93, 0x64, 0x60, 0x5d,
	0x03, 0x86, 0x84, 0x49, 0x32, 0x78, 0x5c, 0x75, 0x2b, 0xad, 0xaa, 0xf7, 0x09, 0x5c, 0xd3, 0x1f,
	0xbd, 0x34, 0x3d, 0x51, 0x0e, 0x2e, 0x39, 0xfa, 0x46, 0xfe, 0x89, 0x66, 0x36, 0x50, 0x2d, 0x91,
	0xf9, 0x2e, 0x7b, 0x42, 0x47, 0xde, 0x33, 0x58, 0x2e, 0xaf, 0x99, 0x06, 0x3b, 0x65, 0x30, 0xda,
	0x82, 0xe5, 0x84, 0xbe, 0x94, 0xfe, 0xe4, 0x03, 0x1c, 0x14, 0xcd, 0xb6, 0x57, 0x5f, 0xc2, 0xc6,
	0x8c, 0x16, 0xf6, 0xa8, 0x0f, 0xe0, 0x8a, 0x69, 0xa6, 0x2c, 0xc3, 0x36, 0x43, 0xed, 0x99, 0x7e,
	0x2a, 0x5f, 0xb8, 0x2c, 0x4a, 0xb3, 0x83, 0xdf, 0x3a, 0x7f, 0x78, 0x7d, 0xdb, 0xf9, 0xd3, 0xeb,
	0xdb, 0xce, 0x5f, 0x5f, 0xdf, 0x76, 0xbe, 0x7a, 0x7d, 0xdb, 0x81, 0x4d, 0xc6, 0xfb, 0xe5, 0xd5,
	0x61, 0x24, 0x24, 0xcf, 0x12, 0x19, 0x0d, 0xe9, 0xc1, 0xb2, 0xf9, 0x5e, 0xd0, 0x21, 0x26, 0x8e,
	0x9d, 0x9f, 0x7f, 0xd1, 0x8f, 0xe4, 0x59, 0xd6, 0xdd, 0x09, 0xd8, 0xb0, 0xf4, 0x7f, 0x7e, 0xc1,
	0xb0, 0xcf, 0xa6, 0x7e, 0xdc, 0x7b, 0xfa, 0x23, 0x9f, 0x53, 0xf3, 0xeb, 0x26, 0xfc, 0x3e, 0x33,
	0xa3, 0xff, 0x38, 0x4e, 0xb7, 0xae, 0x47, 0xdf, 0xfb, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x83,
	0x52, 0xf1, 0x70, 0xd3, 0x19, 0x00, 0x00,
}

func (m *GetStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeviceAttributes) > 0 {
		for iNdEx := len(m.DeviceAttributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeviceAttributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateWorkerSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWorkerSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateWorkerSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MasterIncarnation != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.MasterIncarnation))
		i--
		dAtA[i] = 0x30
	}
	if len(m.MasterTask) > 0 {
		i -= len(m.MasterTask)
		copy(dAtA[i:], m.MasterTask)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.MasterTask)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterDeviceAttributes) > 0 {
		for iNdEx := len(m.ClusterDeviceAttributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterDeviceAttributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.IsolateSessionState {
		i--
		if m.IsolateSessionState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ServerDef != nil {
		{
			size, err := m.ServerDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateWorkerSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWorkerSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateWorkerSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteWorkerSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteWorkerSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteWorkerSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteWorkerSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteWorkerSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteWorkerSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RegisterGraphRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterGraphRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterGraphRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfigProto != nil {
		{
			size, err := m.ConfigProto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CollectiveGraphKey != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.CollectiveGraphKey))
		i--
		dAtA[i] = 0x38
	}
	if m.CreateWorkerSessionCalled {
		i--
		if m.CreateWorkerSessionCalled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DebugOptions != nil {
		{
			size, err := m.DebugOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.GraphOptions != nil {
		{
			size, err := m.GraphOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.HasControlFlow {
		i--
		if m.HasControlFlow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.GraphDef != nil {
		{
			size, err := m.GraphDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterGraphResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterGraphResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterGraphResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GraphHandle) > 0 {
		i -= len(m.GraphHandle)
		copy(dAtA[i:], m.GraphHandle)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.GraphHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeregisterGraphRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeregisterGraphRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeregisterGraphRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateWorkerSessionCalled {
		i--
		if m.CreateWorkerSessionCalled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GraphHandle) > 0 {
		i -= len(m.GraphHandle)
		copy(dAtA[i:], m.GraphHandle)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.GraphHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeregisterGraphResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeregisterGraphResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeregisterGraphResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CleanupAllRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupAllRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CleanupAllRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Container) > 0 {
		for iNdEx := len(m.Container) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Container[iNdEx])
			copy(dAtA[i:], m.Container[iNdEx])
			i = encodeVarintWorker(dAtA, i, uint64(len(m.Container[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CleanupAllResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupAllResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CleanupAllResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ExecutorOpts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorOpts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutorOpts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReportTensorAllocationsUponOom {
		i--
		if m.ReportTensorAllocationsUponOom {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.RecordPartitionGraphs {
		i--
		if m.RecordPartitionGraphs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.RecordTimeline {
		i--
		if m.RecordTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.RecordCosts {
		i--
		if m.RecordCosts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RunGraphRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunGraphRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunGraphRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestId != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x58
	}
	if m.CreateWorkerSessionCalled {
		i--
		if m.CreateWorkerSessionCalled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.StoreErrorsInResponseBody {
		i--
		if m.StoreErrorsInResponseBody {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0x42
	}
	if m.IsLastPartialRun {
		i--
		if m.IsLastPartialRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.IsPartial {
		i--
		if m.IsPartial {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ExecOpts != nil {
		{
			size, err := m.ExecOpts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RecvKey) > 0 {
		for iNdEx := len(m.RecvKey) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RecvKey[iNdEx])
			copy(dAtA[i:], m.RecvKey[iNdEx])
			i = encodeVarintWorker(dAtA, i, uint64(len(m.RecvKey[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Send) > 0 {
		for iNdEx := len(m.Send) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Send[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.StepId != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.StepId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GraphHandle) > 0 {
		i -= len(m.GraphHandle)
		copy(dAtA[i:], m.GraphHandle)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.GraphHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunGraphResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunGraphResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunGraphResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StatusErrorMessage) > 0 {
		i -= len(m.StatusErrorMessage)
		copy(dAtA[i:], m.StatusErrorMessage)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.StatusErrorMessage)))
		i--
		dAtA[i] = 0x32
	}
	if m.StatusCode != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PartitionGraph) > 0 {
		for iNdEx := len(m.PartitionGraph) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionGraph[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.CostGraph != nil {
		{
			size, err := m.CostGraph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StepStats != nil {
		{
			size, err := m.StepStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Recv) > 0 {
		for iNdEx := len(m.Recv) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recv[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CleanupGraphRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupGraphRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CleanupGraphRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StepId != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.StepId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CleanupGraphResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupGraphResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CleanupGraphResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RecvTensorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecvTensorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecvTensorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestId != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x38
	}
	if m.TransportOptions != nil {
		{
			size, err := m.TransportOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ServerLocality != nil {
		{
			size, err := m.ServerLocality.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ClientLocality != nil {
		{
			size, err := m.ClientLocality.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DmaOk {
		i--
		if m.DmaOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.RendezvousKey) > 0 {
		i -= len(m.RendezvousKey)
		copy(dAtA[i:], m.RendezvousKey)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.RendezvousKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.StepId != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.StepId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecvTensorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecvTensorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecvTensorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequireAck {
		i--
		if m.RequireAck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TransportOptions != nil {
		{
			size, err := m.TransportOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SendStartMicros != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.SendStartMicros))
		i--
		dAtA[i] = 0x18
	}
	if m.IsDead {
		i--
		if m.IsDead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Tensor != nil {
		{
			size, err := m.Tensor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkRecvFinishedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkRecvFinishedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkRecvFinishedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestId != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarkRecvFinishedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkRecvFinishedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkRecvFinishedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *LoggingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DisableRpcLogging {
		i--
		if m.DisableRpcLogging {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.FetchStepId) > 0 {
		dAtA15 := make([]byte, len(m.FetchStepId)*10)
		var j14 int
		for _, num1 := range m.FetchStepId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintWorker(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x1a
	}
	if m.Clear {
		i--
		if m.Clear {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.EnableRpcLogging {
		i--
		if m.EnableRpcLogging {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LabeledStepStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabeledStepStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabeledStepStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StepStats != nil {
		{
			size, err := m.StepStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StepId != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.StepId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoggingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Step) > 0 {
		for iNdEx := len(m.Step) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Step[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceOpts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceOpts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceOpts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseSampleProfiler {
		i--
		if m.UseSampleProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.UseGpuProfiler {
		i--
		if m.UseGpuProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.UseExtendedProfiler {
		i--
		if m.UseExtendedProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UseKernelProfiler {
		i--
		if m.UseKernelProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UseStepProfiler {
		i--
		if m.UseStepProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Duration != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Duration))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *TracingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TracingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RecvBufRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecvBufRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecvBufRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SrcIncarnation != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.SrcIncarnation))
		i--
		dAtA[i] = 0x58
	}
	if m.RequestId != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x50
	}
	if len(m.DstDevice) > 0 {
		i -= len(m.DstDevice)
		copy(dAtA[i:], m.DstDevice)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.DstDevice)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SrcDevice) > 0 {
		i -= len(m.SrcDevice)
		copy(dAtA[i:], m.SrcDevice)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.SrcDevice)))
		i--
		dAtA[i] = 0x42
	}
	if m.TransportOptions != nil {
		{
			size, err := m.TransportOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ServerLocality != nil {
		{
			size, err := m.ServerLocality.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ClientLocality != nil {
		{
			size, err := m.ClientLocality.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BufPtr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.BufPtr))
		i--
		dAtA[i] = 0x21
	}
	if m.NumBytes != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.NumBytes))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BufRendezvousKey) > 0 {
		i -= len(m.BufRendezvousKey)
		copy(dAtA[i:], m.BufRendezvousKey)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.BufRendezvousKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.StepId != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.StepId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecvBufResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecvBufResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecvBufResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequireAck {
		i--
		if m.RequireAck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.SendStartMicros != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.SendStartMicros))
		i--
		dAtA[i] = 0x28
	}
	if m.TransportOptions != nil {
		{
			size, err := m.TransportOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IsDead {
		i--
		if m.IsDead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NumBytes != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.NumBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.BufPtr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.BufPtr))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CompleteGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteGroupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeviceAttributes != nil {
		{
			size, err := m.DeviceAttributes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CollectiveType != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.CollectiveType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.DeviceType) > 0 {
		i -= len(m.DeviceType)
		copy(dAtA[i:], m.DeviceType)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.DeviceType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupSize != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupKey != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.GroupKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompleteGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteGroupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeviceAttributes) > 0 {
		for iNdEx := len(m.DeviceAttributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeviceAttributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CommunicatorKey) > 0 {
		i -= len(m.CommunicatorKey)
		copy(dAtA[i:], m.CommunicatorKey)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.CommunicatorKey)))
		i--
		dAtA[i] = 0x3a
	}
	if m.NumTasks != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.NumTasks))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DeviceType) > 0 {
		i -= len(m.DeviceType)
		copy(dAtA[i:], m.DeviceType)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.DeviceType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupSize != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupKey != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.GroupKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompleteInstanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteInstanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteInstanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsSource {
		i--
		if m.IsSource {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SubdivOffset) > 0 {
		dAtA24 := make([]byte, len(m.SubdivOffset)*10)
		var j23 int
		for _, num1 := range m.SubdivOffset {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintWorker(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DeviceType) > 0 {
		i -= len(m.DeviceType)
		copy(dAtA[i:], m.DeviceType)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.DeviceType)))
		i--
		dAtA[i] = 0x42
	}
	if m.InstanceKey != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.InstanceKey))
		i--
		dAtA[i] = 0x38
	}
	if m.GroupSize != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x30
	}
	if m.GroupKey != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.GroupKey))
		i--
		dAtA[i] = 0x28
	}
	if m.Shape != nil {
		{
			size, err := m.Shape.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWorker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DataType != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWorker(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompleteInstanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteInstanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteInstanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SourceRank != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.SourceRank))
		i--
		dAtA[i] = 0x10
	}
	if m.InstanceKey != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.InstanceKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetStepSequenceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStepSequenceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStepSequenceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GraphKey) > 0 {
		dAtA27 := make([]byte, len(m.GraphKey)*10)
		var j26 int
		for _, num1 := range m.GraphKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintWorker(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StepSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NextStepId != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.NextStepId))
		i--
		dAtA[i] = 0x10
	}
	if m.GraphKey != 0 {
		i = encodeVarintWorker(dAtA, i, uint64(m.GraphKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetStepSequenceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStepSequenceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStepSequenceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StepSequence) > 0 {
		for iNdEx := len(m.StepSequence) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StepSequence[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWorker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintWorker(dAtA []byte, offset int, v uint64) int {
	offset -= sovWorker(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DeviceAttributes) > 0 {
		for _, e := range m.DeviceAttributes {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateWorkerSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.ServerDef != nil {
		l = m.ServerDef.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.IsolateSessionState {
		n += 2
	}
	if len(m.ClusterDeviceAttributes) > 0 {
		for _, e := range m.ClusterDeviceAttributes {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	l = len(m.MasterTask)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.MasterIncarnation != 0 {
		n += 1 + sovWorker(uint64(m.MasterIncarnation))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateWorkerSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteWorkerSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteWorkerSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegisterGraphRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.GraphDef != nil {
		l = m.GraphDef.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.HasControlFlow {
		n += 2
	}
	if m.GraphOptions != nil {
		l = m.GraphOptions.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.DebugOptions != nil {
		l = m.DebugOptions.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.CreateWorkerSessionCalled {
		n += 2
	}
	if m.CollectiveGraphKey != 0 {
		n += 1 + sovWorker(uint64(m.CollectiveGraphKey))
	}
	if m.ConfigProto != nil {
		l = m.ConfigProto.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegisterGraphResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GraphHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeregisterGraphRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GraphHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.CreateWorkerSessionCalled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeregisterGraphResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CleanupAllRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Container) > 0 {
		for _, s := range m.Container {
			l = len(s)
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CleanupAllResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecutorOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecordCosts {
		n += 2
	}
	if m.RecordTimeline {
		n += 2
	}
	if m.RecordPartitionGraphs {
		n += 2
	}
	if m.ReportTensorAllocationsUponOom {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunGraphRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GraphHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.StepId != 0 {
		n += 1 + sovWorker(uint64(m.StepId))
	}
	if len(m.Send) > 0 {
		for _, e := range m.Send {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if len(m.RecvKey) > 0 {
		for _, s := range m.RecvKey {
			l = len(s)
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if m.ExecOpts != nil {
		l = m.ExecOpts.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.IsPartial {
		n += 2
	}
	if m.IsLastPartialRun {
		n += 2
	}
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.StoreErrorsInResponseBody {
		n += 2
	}
	if m.CreateWorkerSessionCalled {
		n += 2
	}
	if m.RequestId != 0 {
		n += 1 + sovWorker(uint64(m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunGraphResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Recv) > 0 {
		for _, e := range m.Recv {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if m.StepStats != nil {
		l = m.StepStats.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.CostGraph != nil {
		l = m.CostGraph.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if len(m.PartitionGraph) > 0 {
		for _, e := range m.PartitionGraph {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if m.StatusCode != 0 {
		n += 1 + sovWorker(uint64(m.StatusCode))
	}
	l = len(m.StatusErrorMessage)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CleanupGraphRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StepId != 0 {
		n += 1 + sovWorker(uint64(m.StepId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CleanupGraphResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecvTensorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StepId != 0 {
		n += 1 + sovWorker(uint64(m.StepId))
	}
	l = len(m.RendezvousKey)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.DmaOk {
		n += 2
	}
	if m.ClientLocality != nil {
		l = m.ClientLocality.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.ServerLocality != nil {
		l = m.ServerLocality.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.TransportOptions != nil {
		l = m.TransportOptions.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovWorker(uint64(m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecvTensorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tensor != nil {
		l = m.Tensor.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.IsDead {
		n += 2
	}
	if m.SendStartMicros != 0 {
		n += 1 + sovWorker(uint64(m.SendStartMicros))
	}
	if m.TransportOptions != nil {
		l = m.TransportOptions.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.RequireAck {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkRecvFinishedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != 0 {
		n += 1 + sovWorker(uint64(m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkRecvFinishedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableRpcLogging {
		n += 2
	}
	if m.Clear {
		n += 2
	}
	if len(m.FetchStepId) > 0 {
		l = 0
		for _, e := range m.FetchStepId {
			l += sovWorker(uint64(e))
		}
		n += 1 + sovWorker(uint64(l)) + l
	}
	if m.DisableRpcLogging {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabeledStepStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StepId != 0 {
		n += 1 + sovWorker(uint64(m.StepId))
	}
	if m.StepStats != nil {
		l = m.StepStats.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Step) > 0 {
		for _, e := range m.Step {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TraceOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != 0 {
		n += 9
	}
	if m.UseStepProfiler {
		n += 2
	}
	if m.UseKernelProfiler {
		n += 2
	}
	if m.UseExtendedProfiler {
		n += 2
	}
	if m.UseGpuProfiler {
		n += 2
	}
	if m.UseSampleProfiler {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecvBufRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StepId != 0 {
		n += 1 + sovWorker(uint64(m.StepId))
	}
	l = len(m.BufRendezvousKey)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.NumBytes != 0 {
		n += 1 + sovWorker(uint64(m.NumBytes))
	}
	if m.BufPtr != 0 {
		n += 9
	}
	if m.ClientLocality != nil {
		l = m.ClientLocality.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.ServerLocality != nil {
		l = m.ServerLocality.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.TransportOptions != nil {
		l = m.TransportOptions.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	l = len(m.SrcDevice)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	l = len(m.DstDevice)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovWorker(uint64(m.RequestId))
	}
	if m.SrcIncarnation != 0 {
		n += 1 + sovWorker(uint64(m.SrcIncarnation))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecvBufResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BufPtr != 0 {
		n += 9
	}
	if m.NumBytes != 0 {
		n += 1 + sovWorker(uint64(m.NumBytes))
	}
	if m.IsDead {
		n += 2
	}
	if m.TransportOptions != nil {
		l = m.TransportOptions.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.SendStartMicros != 0 {
		n += 1 + sovWorker(uint64(m.SendStartMicros))
	}
	if m.RequireAck {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompleteGroupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupKey != 0 {
		n += 1 + sovWorker(uint64(m.GroupKey))
	}
	if m.GroupSize != 0 {
		n += 1 + sovWorker(uint64(m.GroupSize))
	}
	l = len(m.DeviceType)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.CollectiveType != 0 {
		n += 1 + sovWorker(uint64(m.CollectiveType))
	}
	if m.DeviceAttributes != nil {
		l = m.DeviceAttributes.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompleteGroupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupKey != 0 {
		n += 1 + sovWorker(uint64(m.GroupKey))
	}
	if m.GroupSize != 0 {
		n += 1 + sovWorker(uint64(m.GroupSize))
	}
	l = len(m.DeviceType)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.NumTasks != 0 {
		n += 1 + sovWorker(uint64(m.NumTasks))
	}
	l = len(m.CommunicatorKey)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if len(m.DeviceAttributes) > 0 {
		for _, e := range m.DeviceAttributes {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompleteInstanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovWorker(uint64(m.Type))
	}
	if m.DataType != 0 {
		n += 1 + sovWorker(uint64(m.DataType))
	}
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.GroupKey != 0 {
		n += 1 + sovWorker(uint64(m.GroupKey))
	}
	if m.GroupSize != 0 {
		n += 1 + sovWorker(uint64(m.GroupSize))
	}
	if m.InstanceKey != 0 {
		n += 1 + sovWorker(uint64(m.InstanceKey))
	}
	l = len(m.DeviceType)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if len(m.SubdivOffset) > 0 {
		l = 0
		for _, e := range m.SubdivOffset {
			l += sovWorker(uint64(e))
		}
		n += 1 + sovWorker(uint64(l)) + l
	}
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.IsSource {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompleteInstanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InstanceKey != 0 {
		n += 1 + sovWorker(uint64(m.InstanceKey))
	}
	if m.SourceRank != 0 {
		n += 1 + sovWorker(uint64(m.SourceRank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStepSequenceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GraphKey) > 0 {
		l = 0
		for _, e := range m.GraphKey {
			l += sovWorker(uint64(e))
		}
		n += 1 + sovWorker(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StepSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GraphKey != 0 {
		n += 1 + sovWorker(uint64(m.GraphKey))
	}
	if m.NextStepId != 0 {
		n += 1 + sovWorker(uint64(m.NextStepId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStepSequenceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StepSequence) > 0 {
		for _, e := range m.StepSequence {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovWorker(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozWorker(x uint64) (n int) {
	return sovWorker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceAttributes = append(m.DeviceAttributes, &device_attributes_go_proto.DeviceAttributes{})
			if err := m.DeviceAttributes[len(m.DeviceAttributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWorkerSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWorkerSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWorkerSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerDef == nil {
				m.ServerDef = &ServerDef{}
			}
			if err := m.ServerDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolateSessionState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsolateSessionState = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDeviceAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterDeviceAttributes = append(m.ClusterDeviceAttributes, &device_attributes_go_proto.DeviceAttributes{})
			if err := m.ClusterDeviceAttributes[len(m.ClusterDeviceAttributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterTask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterTask = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterIncarnation", wireType)
			}
			m.MasterIncarnation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MasterIncarnation |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWorkerSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWorkerSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWorkerSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteWorkerSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteWorkerSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteWorkerSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteWorkerSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteWorkerSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteWorkerSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterGraphRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterGraphRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterGraphRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphDef == nil {
				m.GraphDef = &graph_go_proto.GraphDef{}
			}
			if err := m.GraphDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasControlFlow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasControlFlow = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphOptions == nil {
				m.GraphOptions = &GraphOptions{}
			}
			if err := m.GraphOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DebugOptions == nil {
				m.DebugOptions = &DebugOptions{}
			}
			if err := m.DebugOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWorkerSessionCalled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateWorkerSessionCalled = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectiveGraphKey", wireType)
			}
			m.CollectiveGraphKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectiveGraphKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigProto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigProto == nil {
				m.ConfigProto = &ConfigProto{}
			}
			if err := m.ConfigProto.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterGraphResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterGraphResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterGraphResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeregisterGraphRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeregisterGraphRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeregisterGraphRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWorkerSessionCalled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateWorkerSessionCalled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeregisterGraphResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeregisterGraphResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeregisterGraphResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupAllRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupAllRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupAllRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = append(m.Container, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupAllResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupAllResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupAllResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutorOpts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorOpts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorOpts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordCosts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecordCosts = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecordTimeline = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordPartitionGraphs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecordPartitionGraphs = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportTensorAllocationsUponOom", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReportTensorAllocationsUponOom = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunGraphRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunGraphRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunGraphRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Send = append(m.Send, &NamedTensorProto{})
			if err := m.Send[len(m.Send)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecvKey = append(m.RecvKey, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecOpts == nil {
				m.ExecOpts = &ExecutorOpts{}
			}
			if err := m.ExecOpts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartial", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPartial = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLastPartialRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLastPartialRun = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreErrorsInResponseBody", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StoreErrorsInResponseBody = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWorkerSessionCalled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateWorkerSessionCalled = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunGraphResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunGraphResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunGraphResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recv = append(m.Recv, &NamedTensorProto{})
			if err := m.Recv[len(m.Recv)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StepStats == nil {
				m.StepStats = &step_stats_go_proto.StepStats{}
			}
			if err := m.StepStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostGraph == nil {
				m.CostGraph = &cost_graph_go_proto.CostGraphDef{}
			}
			if err := m.CostGraph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionGraph = append(m.PartitionGraph, &graph_go_proto.GraphDef{})
			if err := m.PartitionGraph[len(m.PartitionGraph)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupGraphRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupGraphRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupGraphRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupGraphResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupGraphResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupGraphResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecvTensorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecvTensorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecvTensorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RendezvousKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RendezvousKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmaOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DmaOk = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientLocality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientLocality == nil {
				m.ClientLocality = &device_attributes_go_proto.DeviceLocality{}
			}
			if err := m.ClientLocality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerLocality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerLocality == nil {
				m.ServerLocality = &device_attributes_go_proto.DeviceLocality{}
			}
			if err := m.ServerLocality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransportOptions == nil {
				m.TransportOptions = &types.Any{}
			}
			if err := m.TransportOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecvTensorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecvTensorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecvTensorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tensor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tensor == nil {
				m.Tensor = &tensor_go_proto.TensorProto{}
			}
			if err := m.Tensor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDead = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendStartMicros", wireType)
			}
			m.SendStartMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendStartMicros |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransportOptions == nil {
				m.TransportOptions = &types.Any{}
			}
			if err := m.TransportOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireAck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireAck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkRecvFinishedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkRecvFinishedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkRecvFinishedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkRecvFinishedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkRecvFinishedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkRecvFinishedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableRpcLogging", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableRpcLogging = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Clear = bool(v != 0)
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorker
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FetchStepId = append(m.FetchStepId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorker
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWorker
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthWorker
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FetchStepId) == 0 {
					m.FetchStepId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWorker
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FetchStepId = append(m.FetchStepId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchStepId", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableRpcLogging", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableRpcLogging = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabeledStepStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabeledStepStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabeledStepStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StepStats == nil {
				m.StepStats = &step_stats_go_proto.StepStats{}
			}
			if err := m.StepStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = append(m.Step, &LabeledStepStats{})
			if err := m.Step[len(m.Step)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceOpts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceOpts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceOpts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Duration = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseStepProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseStepProfiler = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseKernelProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseKernelProfiler = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseExtendedProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseExtendedProfiler = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseGpuProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseGpuProfiler = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSampleProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSampleProfiler = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &TraceOpts{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecvBufRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecvBufRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecvBufRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufRendezvousKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufRendezvousKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytes", wireType)
			}
			m.NumBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufPtr", wireType)
			}
			m.BufPtr = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.BufPtr = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientLocality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientLocality == nil {
				m.ClientLocality = &device_attributes_go_proto.DeviceLocality{}
			}
			if err := m.ClientLocality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerLocality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerLocality == nil {
				m.ServerLocality = &device_attributes_go_proto.DeviceLocality{}
			}
			if err := m.ServerLocality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransportOptions == nil {
				m.TransportOptions = &types.Any{}
			}
			if err := m.TransportOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIncarnation", wireType)
			}
			m.SrcIncarnation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcIncarnation |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecvBufResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecvBufResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecvBufResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufPtr", wireType)
			}
			m.BufPtr = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.BufPtr = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytes", wireType)
			}
			m.NumBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDead = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransportOptions == nil {
				m.TransportOptions = &types.Any{}
			}
			if err := m.TransportOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendStartMicros", wireType)
			}
			m.SendStartMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendStartMicros |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireAck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireAck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupKey", wireType)
			}
			m.GroupKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupKey |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectiveType", wireType)
			}
			m.CollectiveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectiveType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceAttributes == nil {
				m.DeviceAttributes = &device_attributes_go_proto.DeviceAttributes{}
			}
			if err := m.DeviceAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupKey", wireType)
			}
			m.GroupKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupKey |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTasks", wireType)
			}
			m.NumTasks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTasks |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunicatorKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunicatorKey = append(m.CommunicatorKey[:0], dAtA[iNdEx:postIndex]...)
			if m.CommunicatorKey == nil {
				m.CommunicatorKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceAttributes = append(m.DeviceAttributes, &device_attributes_go_proto.DeviceAttributes{})
			if err := m.DeviceAttributes[len(m.DeviceAttributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteInstanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteInstanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteInstanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= types_go_proto.DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &tensor_shape_go_proto.TensorShapeProto{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupKey", wireType)
			}
			m.GroupKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupKey |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceKey", wireType)
			}
			m.InstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceKey |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorker
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SubdivOffset = append(m.SubdivOffset, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorker
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWorker
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthWorker
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SubdivOffset) == 0 {
					m.SubdivOffset = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWorker
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SubdivOffset = append(m.SubdivOffset, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubdivOffset", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSource", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSource = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteInstanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteInstanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteInstanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceKey", wireType)
			}
			m.InstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceKey |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceRank", wireType)
			}
			m.SourceRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStepSequenceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStepSequenceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStepSequenceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorker
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GraphKey = append(m.GraphKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorker
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWorker
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthWorker
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GraphKey) == 0 {
					m.GraphKey = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWorker
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GraphKey = append(m.GraphKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphKey", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphKey", wireType)
			}
			m.GraphKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GraphKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStepId", wireType)
			}
			m.NextStepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextStepId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStepSequenceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStepSequenceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStepSequenceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWorker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepSequence = append(m.StepSequence, &StepSequence{})
			if err := m.StepSequence[len(m.StepSequence)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWorker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWorker
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupWorker
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthWorker
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthWorker        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWorker          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupWorker = fmt.Errorf("proto: unexpected end of group")
)
