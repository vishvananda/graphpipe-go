// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/meta_graph.proto

package for_core_protos_go_proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	graph_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/graph_go_proto"
	op_def_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/op_def_go_proto"
	tensor_shape_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/tensor_shape_go_proto"
	types_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/types_go_proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// NOTE: This protocol buffer is evolving, and will go through revisions in the
// coming months.
//
// Protocol buffer containing the following which are necessary to restart
// training, run inference. It can be used to serialize/de-serialize memory
// objects necessary for running computation in a graph when crossing the
// process boundary. It can be used for long term storage of graphs,
// cross-language execution of graphs, etc.
//   MetaInfoDef
//   GraphDef
//   SaverDef
//   CollectionDef
//   TensorInfo
//   SignatureDef
type MetaGraphDef struct {
	MetaInfoDef *MetaGraphDef_MetaInfoDef `protobuf:"bytes,1,opt,name=meta_info_def,json=metaInfoDef,proto3" json:"meta_info_def,omitempty"`
	// GraphDef.
	GraphDef *graph_go_proto.GraphDef `protobuf:"bytes,2,opt,name=graph_def,json=graphDef,proto3" json:"graph_def,omitempty"`
	// SaverDef.
	SaverDef *SaverDef `protobuf:"bytes,3,opt,name=saver_def,json=saverDef,proto3" json:"saver_def,omitempty"`
	// collection_def: Map from collection name to collections.
	// See CollectionDef section for details.
	CollectionDef map[string]*CollectionDef `protobuf:"bytes,4,rep,name=collection_def,json=collectionDef,proto3" json:"collection_def,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// signature_def: Map from user supplied key for a signature to a single
	// SignatureDef.
	SignatureDef map[string]*SignatureDef `protobuf:"bytes,5,rep,name=signature_def,json=signatureDef,proto3" json:"signature_def,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Asset file def to be used with the defined graph.
	AssetFileDef []*AssetFileDef `protobuf:"bytes,6,rep,name=asset_file_def,json=assetFileDef,proto3" json:"asset_file_def,omitempty"`
	// Extra information about the structure of functions and stateful objects.
	ObjectGraphDef       *SavedObjectGraph `protobuf:"bytes,7,opt,name=object_graph_def,json=objectGraphDef,proto3" json:"object_graph_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MetaGraphDef) Reset()         { *m = MetaGraphDef{} }
func (m *MetaGraphDef) String() string { return proto.CompactTextString(m) }
func (*MetaGraphDef) ProtoMessage()    {}
func (*MetaGraphDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{0}
}
func (m *MetaGraphDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaGraphDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetaGraphDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaGraphDef.Merge(m, src)
}
func (m *MetaGraphDef) XXX_Size() int {
	return m.Size()
}
func (m *MetaGraphDef) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaGraphDef.DiscardUnknown(m)
}

var xxx_messageInfo_MetaGraphDef proto.InternalMessageInfo

func (m *MetaGraphDef) GetMetaInfoDef() *MetaGraphDef_MetaInfoDef {
	if m != nil {
		return m.MetaInfoDef
	}
	return nil
}

func (m *MetaGraphDef) GetGraphDef() *graph_go_proto.GraphDef {
	if m != nil {
		return m.GraphDef
	}
	return nil
}

func (m *MetaGraphDef) GetSaverDef() *SaverDef {
	if m != nil {
		return m.SaverDef
	}
	return nil
}

func (m *MetaGraphDef) GetCollectionDef() map[string]*CollectionDef {
	if m != nil {
		return m.CollectionDef
	}
	return nil
}

func (m *MetaGraphDef) GetSignatureDef() map[string]*SignatureDef {
	if m != nil {
		return m.SignatureDef
	}
	return nil
}

func (m *MetaGraphDef) GetAssetFileDef() []*AssetFileDef {
	if m != nil {
		return m.AssetFileDef
	}
	return nil
}

func (m *MetaGraphDef) GetObjectGraphDef() *SavedObjectGraph {
	if m != nil {
		return m.ObjectGraphDef
	}
	return nil
}

// Meta information regarding the graph to be exported.  To be used by users
// of this protocol buffer to encode information regarding their meta graph.
type MetaGraphDef_MetaInfoDef struct {
	// User specified Version string. Can be the name of the model and revision,
	// steps this model has been trained to, etc.
	MetaGraphVersion string `protobuf:"bytes,1,opt,name=meta_graph_version,json=metaGraphVersion,proto3" json:"meta_graph_version,omitempty"`
	// A copy of the OpDefs used by the producer of this graph_def.
	// Descriptions and Ops not used in graph_def are stripped out.
	StrippedOpList *op_def_go_proto.OpList `protobuf:"bytes,2,opt,name=stripped_op_list,json=strippedOpList,proto3" json:"stripped_op_list,omitempty"`
	// A serialized protobuf. Can be the time this meta graph is created, or
	// modified, or name of the model.
	AnyInfo *types.Any `protobuf:"bytes,3,opt,name=any_info,json=anyInfo,proto3" json:"any_info,omitempty"`
	// User supplied tag(s) on the meta_graph and included graph_def.
	//
	// MetaGraphDefs should be tagged with their capabilities or use-cases.
	// Examples: "train", "serve", "gpu", "tpu", etc.
	// These tags enable loaders to access the MetaGraph(s) appropriate for a
	// specific use-case or runtime environment.
	Tags []string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	// The __version__ string of the tensorflow build used to write this graph.
	// This will be populated by the framework, which will overwrite any user
	// supplied value.
	TensorflowVersion string `protobuf:"bytes,5,opt,name=tensorflow_version,json=tensorflowVersion,proto3" json:"tensorflow_version,omitempty"`
	// The __git_version__ string of the tensorflow build used to write this
	// graph. This will be populated by the framework, which will overwrite any
	// user supplied value.
	TensorflowGitVersion string `protobuf:"bytes,6,opt,name=tensorflow_git_version,json=tensorflowGitVersion,proto3" json:"tensorflow_git_version,omitempty"`
	// A flag to denote whether default-valued attrs have been stripped from
	// the nodes in this graph_def.
	StrippedDefaultAttrs bool `protobuf:"varint,7,opt,name=stripped_default_attrs,json=strippedDefaultAttrs,proto3" json:"stripped_default_attrs,omitempty"`
	// FunctionDef name to aliases mapping.
	FunctionAliases      map[string]string `protobuf:"bytes,8,rep,name=function_aliases,json=functionAliases,proto3" json:"function_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MetaGraphDef_MetaInfoDef) Reset()         { *m = MetaGraphDef_MetaInfoDef{} }
func (m *MetaGraphDef_MetaInfoDef) String() string { return proto.CompactTextString(m) }
func (*MetaGraphDef_MetaInfoDef) ProtoMessage()    {}
func (*MetaGraphDef_MetaInfoDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{0, 0}
}
func (m *MetaGraphDef_MetaInfoDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaGraphDef_MetaInfoDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetaGraphDef_MetaInfoDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaGraphDef_MetaInfoDef.Merge(m, src)
}
func (m *MetaGraphDef_MetaInfoDef) XXX_Size() int {
	return m.Size()
}
func (m *MetaGraphDef_MetaInfoDef) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaGraphDef_MetaInfoDef.DiscardUnknown(m)
}

var xxx_messageInfo_MetaGraphDef_MetaInfoDef proto.InternalMessageInfo

func (m *MetaGraphDef_MetaInfoDef) GetMetaGraphVersion() string {
	if m != nil {
		return m.MetaGraphVersion
	}
	return ""
}

func (m *MetaGraphDef_MetaInfoDef) GetStrippedOpList() *op_def_go_proto.OpList {
	if m != nil {
		return m.StrippedOpList
	}
	return nil
}

func (m *MetaGraphDef_MetaInfoDef) GetAnyInfo() *types.Any {
	if m != nil {
		return m.AnyInfo
	}
	return nil
}

func (m *MetaGraphDef_MetaInfoDef) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MetaGraphDef_MetaInfoDef) GetTensorflowVersion() string {
	if m != nil {
		return m.TensorflowVersion
	}
	return ""
}

func (m *MetaGraphDef_MetaInfoDef) GetTensorflowGitVersion() string {
	if m != nil {
		return m.TensorflowGitVersion
	}
	return ""
}

func (m *MetaGraphDef_MetaInfoDef) GetStrippedDefaultAttrs() bool {
	if m != nil {
		return m.StrippedDefaultAttrs
	}
	return false
}

func (m *MetaGraphDef_MetaInfoDef) GetFunctionAliases() map[string]string {
	if m != nil {
		return m.FunctionAliases
	}
	return nil
}

// CollectionDef should cover most collections.
// To add a user-defined collection, do one of the following:
// 1. For simple data types, such as string, int, float:
//      tf.add_to_collection("your_collection_name", your_simple_value)
//    strings will be stored as bytes_list.
//
// 2. For Protobuf types, there are three ways to add them:
//    1) tf.add_to_collection("your_collection_name",
//         your_proto.SerializeToString())
//
//       collection_def {
//         key: "user_defined_bytes_collection"
//         value {
//           bytes_list {
//             value: "queue_name: \"test_queue\"\n"
//           }
//         }
//       }
//
//  or
//
//    2) tf.add_to_collection("your_collection_name", str(your_proto))
//
//       collection_def {
//         key: "user_defined_string_collection"
//         value {
//          bytes_list {
//             value: "\n\ntest_queue"
//           }
//         }
//       }
//
//  or
//
//    3) any_buf = any_pb2.Any()
//       tf.add_to_collection("your_collection_name",
//         any_buf.Pack(your_proto))
//
//       collection_def {
//         key: "user_defined_any_collection"
//         value {
//           any_list {
//             value {
//               type_url: "type.googleapis.com/tensorflow.QueueRunnerDef"
//               value: "\n\ntest_queue"
//             }
//           }
//         }
//       }
//
// 3. For Python objects, implement to_proto() and from_proto(), and register
//    them in the following manner:
//    ops.register_proto_function("your_collection_name",
//                                proto_type,
//                                to_proto=YourPythonObject.to_proto,
//                                from_proto=YourPythonObject.from_proto)
//    These functions will be invoked to serialize and de-serialize the
//    collection. For example,
//    ops.register_proto_function(ops.GraphKeys.GLOBAL_VARIABLES,
//                                proto_type=variable_pb2.VariableDef,
//                                to_proto=Variable.to_proto,
//                                from_proto=Variable.from_proto)
type CollectionDef struct {
	// Types that are valid to be assigned to Kind:
	//	*CollectionDef_NodeList_
	//	*CollectionDef_BytesList_
	//	*CollectionDef_Int64List_
	//	*CollectionDef_FloatList_
	//	*CollectionDef_AnyList_
	Kind                 isCollectionDef_Kind `protobuf_oneof:"kind"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CollectionDef) Reset()         { *m = CollectionDef{} }
func (m *CollectionDef) String() string { return proto.CompactTextString(m) }
func (*CollectionDef) ProtoMessage()    {}
func (*CollectionDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{1}
}
func (m *CollectionDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CollectionDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionDef.Merge(m, src)
}
func (m *CollectionDef) XXX_Size() int {
	return m.Size()
}
func (m *CollectionDef) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionDef.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionDef proto.InternalMessageInfo

type isCollectionDef_Kind interface {
	isCollectionDef_Kind()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CollectionDef_NodeList_ struct {
	NodeList *CollectionDef_NodeList `protobuf:"bytes,1,opt,name=node_list,json=nodeList,proto3,oneof" json:"node_list,omitempty"`
}
type CollectionDef_BytesList_ struct {
	BytesList *CollectionDef_BytesList `protobuf:"bytes,2,opt,name=bytes_list,json=bytesList,proto3,oneof" json:"bytes_list,omitempty"`
}
type CollectionDef_Int64List_ struct {
	Int64List *CollectionDef_Int64List `protobuf:"bytes,3,opt,name=int64_list,json=int64List,proto3,oneof" json:"int64_list,omitempty"`
}
type CollectionDef_FloatList_ struct {
	FloatList *CollectionDef_FloatList `protobuf:"bytes,4,opt,name=float_list,json=floatList,proto3,oneof" json:"float_list,omitempty"`
}
type CollectionDef_AnyList_ struct {
	AnyList *CollectionDef_AnyList `protobuf:"bytes,5,opt,name=any_list,json=anyList,proto3,oneof" json:"any_list,omitempty"`
}

func (*CollectionDef_NodeList_) isCollectionDef_Kind()  {}
func (*CollectionDef_BytesList_) isCollectionDef_Kind() {}
func (*CollectionDef_Int64List_) isCollectionDef_Kind() {}
func (*CollectionDef_FloatList_) isCollectionDef_Kind() {}
func (*CollectionDef_AnyList_) isCollectionDef_Kind()   {}

func (m *CollectionDef) GetKind() isCollectionDef_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *CollectionDef) GetNodeList() *CollectionDef_NodeList {
	if x, ok := m.GetKind().(*CollectionDef_NodeList_); ok {
		return x.NodeList
	}
	return nil
}

func (m *CollectionDef) GetBytesList() *CollectionDef_BytesList {
	if x, ok := m.GetKind().(*CollectionDef_BytesList_); ok {
		return x.BytesList
	}
	return nil
}

func (m *CollectionDef) GetInt64List() *CollectionDef_Int64List {
	if x, ok := m.GetKind().(*CollectionDef_Int64List_); ok {
		return x.Int64List
	}
	return nil
}

func (m *CollectionDef) GetFloatList() *CollectionDef_FloatList {
	if x, ok := m.GetKind().(*CollectionDef_FloatList_); ok {
		return x.FloatList
	}
	return nil
}

func (m *CollectionDef) GetAnyList() *CollectionDef_AnyList {
	if x, ok := m.GetKind().(*CollectionDef_AnyList_); ok {
		return x.AnyList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CollectionDef) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CollectionDef_NodeList_)(nil),
		(*CollectionDef_BytesList_)(nil),
		(*CollectionDef_Int64List_)(nil),
		(*CollectionDef_FloatList_)(nil),
		(*CollectionDef_AnyList_)(nil),
	}
}

// NodeList is used for collecting nodes in graph. For example
// collection_def {
//   key: "summaries"
//   value {
//     node_list {
//       value: "input_producer/ScalarSummary:0"
//       value: "shuffle_batch/ScalarSummary:0"
//       value: "ImageSummary:0"
//     }
//   }
type CollectionDef_NodeList struct {
	Value                []string `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CollectionDef_NodeList) Reset()         { *m = CollectionDef_NodeList{} }
func (m *CollectionDef_NodeList) String() string { return proto.CompactTextString(m) }
func (*CollectionDef_NodeList) ProtoMessage()    {}
func (*CollectionDef_NodeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{1, 0}
}
func (m *CollectionDef_NodeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionDef_NodeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CollectionDef_NodeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionDef_NodeList.Merge(m, src)
}
func (m *CollectionDef_NodeList) XXX_Size() int {
	return m.Size()
}
func (m *CollectionDef_NodeList) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionDef_NodeList.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionDef_NodeList proto.InternalMessageInfo

func (m *CollectionDef_NodeList) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

// BytesList is used for collecting strings and serialized protobufs. For
// example:
// collection_def {
//   key: "trainable_variables"
//   value {
//     bytes_list {
//       value: "\n\017conv1/weights:0\022\024conv1/weights/Assign
//              \032\024conv1/weights/read:0"
//       value: "\n\016conv1/biases:0\022\023conv1/biases/Assign\032
//              \023conv1/biases/read:0"
//     }
//   }
// }
type CollectionDef_BytesList struct {
	Value                [][]byte `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CollectionDef_BytesList) Reset()         { *m = CollectionDef_BytesList{} }
func (m *CollectionDef_BytesList) String() string { return proto.CompactTextString(m) }
func (*CollectionDef_BytesList) ProtoMessage()    {}
func (*CollectionDef_BytesList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{1, 1}
}
func (m *CollectionDef_BytesList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionDef_BytesList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CollectionDef_BytesList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionDef_BytesList.Merge(m, src)
}
func (m *CollectionDef_BytesList) XXX_Size() int {
	return m.Size()
}
func (m *CollectionDef_BytesList) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionDef_BytesList.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionDef_BytesList proto.InternalMessageInfo

func (m *CollectionDef_BytesList) GetValue() [][]byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// Int64List is used for collecting int, int64 and long values.
type CollectionDef_Int64List struct {
	Value                []int64  `protobuf:"varint,1,rep,packed,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CollectionDef_Int64List) Reset()         { *m = CollectionDef_Int64List{} }
func (m *CollectionDef_Int64List) String() string { return proto.CompactTextString(m) }
func (*CollectionDef_Int64List) ProtoMessage()    {}
func (*CollectionDef_Int64List) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{1, 2}
}
func (m *CollectionDef_Int64List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionDef_Int64List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CollectionDef_Int64List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionDef_Int64List.Merge(m, src)
}
func (m *CollectionDef_Int64List) XXX_Size() int {
	return m.Size()
}
func (m *CollectionDef_Int64List) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionDef_Int64List.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionDef_Int64List proto.InternalMessageInfo

func (m *CollectionDef_Int64List) GetValue() []int64 {
	if m != nil {
		return m.Value
	}
	return nil
}

// FloatList is used for collecting float values.
type CollectionDef_FloatList struct {
	Value                []float32 `protobuf:"fixed32,1,rep,packed,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CollectionDef_FloatList) Reset()         { *m = CollectionDef_FloatList{} }
func (m *CollectionDef_FloatList) String() string { return proto.CompactTextString(m) }
func (*CollectionDef_FloatList) ProtoMessage()    {}
func (*CollectionDef_FloatList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{1, 3}
}
func (m *CollectionDef_FloatList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionDef_FloatList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CollectionDef_FloatList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionDef_FloatList.Merge(m, src)
}
func (m *CollectionDef_FloatList) XXX_Size() int {
	return m.Size()
}
func (m *CollectionDef_FloatList) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionDef_FloatList.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionDef_FloatList proto.InternalMessageInfo

func (m *CollectionDef_FloatList) GetValue() []float32 {
	if m != nil {
		return m.Value
	}
	return nil
}

// AnyList is used for collecting Any protos.
type CollectionDef_AnyList struct {
	Value                []*types.Any `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CollectionDef_AnyList) Reset()         { *m = CollectionDef_AnyList{} }
func (m *CollectionDef_AnyList) String() string { return proto.CompactTextString(m) }
func (*CollectionDef_AnyList) ProtoMessage()    {}
func (*CollectionDef_AnyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{1, 4}
}
func (m *CollectionDef_AnyList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionDef_AnyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CollectionDef_AnyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionDef_AnyList.Merge(m, src)
}
func (m *CollectionDef_AnyList) XXX_Size() int {
	return m.Size()
}
func (m *CollectionDef_AnyList) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionDef_AnyList.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionDef_AnyList proto.InternalMessageInfo

func (m *CollectionDef_AnyList) GetValue() []*types.Any {
	if m != nil {
		return m.Value
	}
	return nil
}

// Information about a Tensor necessary for feeding or retrieval.
type TensorInfo struct {
	// Types that are valid to be assigned to Encoding:
	//	*TensorInfo_Name
	//	*TensorInfo_CooSparse_
	//	*TensorInfo_CompositeTensor_
	Encoding isTensorInfo_Encoding   `protobuf_oneof:"encoding"`
	Dtype    types_go_proto.DataType `protobuf:"varint,2,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
	// The static shape should be recorded here, to the extent that it can
	// be known in advance.  In the case of a SparseTensor, this field describes
	// the logical shape of the represented tensor (aka dense_shape).
	TensorShape          *tensor_shape_go_proto.TensorShapeProto `protobuf:"bytes,3,opt,name=tensor_shape,json=tensorShape,proto3" json:"tensor_shape,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *TensorInfo) Reset()         { *m = TensorInfo{} }
func (m *TensorInfo) String() string { return proto.CompactTextString(m) }
func (*TensorInfo) ProtoMessage()    {}
func (*TensorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{2}
}
func (m *TensorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TensorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorInfo.Merge(m, src)
}
func (m *TensorInfo) XXX_Size() int {
	return m.Size()
}
func (m *TensorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TensorInfo proto.InternalMessageInfo

type isTensorInfo_Encoding interface {
	isTensorInfo_Encoding()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TensorInfo_Name struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3,oneof" json:"name,omitempty"`
}
type TensorInfo_CooSparse_ struct {
	CooSparse *TensorInfo_CooSparse `protobuf:"bytes,4,opt,name=coo_sparse,json=cooSparse,proto3,oneof" json:"coo_sparse,omitempty"`
}
type TensorInfo_CompositeTensor_ struct {
	CompositeTensor *TensorInfo_CompositeTensor `protobuf:"bytes,5,opt,name=composite_tensor,json=compositeTensor,proto3,oneof" json:"composite_tensor,omitempty"`
}

func (*TensorInfo_Name) isTensorInfo_Encoding()             {}
func (*TensorInfo_CooSparse_) isTensorInfo_Encoding()       {}
func (*TensorInfo_CompositeTensor_) isTensorInfo_Encoding() {}

func (m *TensorInfo) GetEncoding() isTensorInfo_Encoding {
	if m != nil {
		return m.Encoding
	}
	return nil
}

func (m *TensorInfo) GetName() string {
	if x, ok := m.GetEncoding().(*TensorInfo_Name); ok {
		return x.Name
	}
	return ""
}

func (m *TensorInfo) GetCooSparse() *TensorInfo_CooSparse {
	if x, ok := m.GetEncoding().(*TensorInfo_CooSparse_); ok {
		return x.CooSparse
	}
	return nil
}

func (m *TensorInfo) GetCompositeTensor() *TensorInfo_CompositeTensor {
	if x, ok := m.GetEncoding().(*TensorInfo_CompositeTensor_); ok {
		return x.CompositeTensor
	}
	return nil
}

func (m *TensorInfo) GetDtype() types_go_proto.DataType {
	if m != nil {
		return m.Dtype
	}
	return types_go_proto.DataType_DT_INVALID
}

func (m *TensorInfo) GetTensorShape() *tensor_shape_go_proto.TensorShapeProto {
	if m != nil {
		return m.TensorShape
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TensorInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TensorInfo_Name)(nil),
		(*TensorInfo_CooSparse_)(nil),
		(*TensorInfo_CompositeTensor_)(nil),
	}
}

// For sparse tensors, The COO encoding stores a triple of values, indices,
// and shape.
type TensorInfo_CooSparse struct {
	// The shape of the values Tensor is [?].  Its dtype must be the dtype of
	// the SparseTensor as a whole, given in the enclosing TensorInfo.
	ValuesTensorName string `protobuf:"bytes,1,opt,name=values_tensor_name,json=valuesTensorName,proto3" json:"values_tensor_name,omitempty"`
	// The indices Tensor must have dtype int64 and shape [?, ?].
	IndicesTensorName string `protobuf:"bytes,2,opt,name=indices_tensor_name,json=indicesTensorName,proto3" json:"indices_tensor_name,omitempty"`
	// The dynamic logical shape represented by the SparseTensor is recorded in
	// the Tensor referenced here.  It must have dtype int64 and shape [?].
	DenseShapeTensorName string   `protobuf:"bytes,3,opt,name=dense_shape_tensor_name,json=denseShapeTensorName,proto3" json:"dense_shape_tensor_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TensorInfo_CooSparse) Reset()         { *m = TensorInfo_CooSparse{} }
func (m *TensorInfo_CooSparse) String() string { return proto.CompactTextString(m) }
func (*TensorInfo_CooSparse) ProtoMessage()    {}
func (*TensorInfo_CooSparse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{2, 0}
}
func (m *TensorInfo_CooSparse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorInfo_CooSparse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TensorInfo_CooSparse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorInfo_CooSparse.Merge(m, src)
}
func (m *TensorInfo_CooSparse) XXX_Size() int {
	return m.Size()
}
func (m *TensorInfo_CooSparse) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorInfo_CooSparse.DiscardUnknown(m)
}

var xxx_messageInfo_TensorInfo_CooSparse proto.InternalMessageInfo

func (m *TensorInfo_CooSparse) GetValuesTensorName() string {
	if m != nil {
		return m.ValuesTensorName
	}
	return ""
}

func (m *TensorInfo_CooSparse) GetIndicesTensorName() string {
	if m != nil {
		return m.IndicesTensorName
	}
	return ""
}

func (m *TensorInfo_CooSparse) GetDenseShapeTensorName() string {
	if m != nil {
		return m.DenseShapeTensorName
	}
	return ""
}

// Generic encoding for composite tensors.
type TensorInfo_CompositeTensor struct {
	// The serialized TypeSpec for the composite tensor.
	TypeSpec *TypeSpecProto `protobuf:"bytes,1,opt,name=type_spec,json=typeSpec,proto3" json:"type_spec,omitempty"`
	// A TensorInfo for each flattened component tensor.
	Components           []*TensorInfo `protobuf:"bytes,2,rep,name=components,proto3" json:"components,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TensorInfo_CompositeTensor) Reset()         { *m = TensorInfo_CompositeTensor{} }
func (m *TensorInfo_CompositeTensor) String() string { return proto.CompactTextString(m) }
func (*TensorInfo_CompositeTensor) ProtoMessage()    {}
func (*TensorInfo_CompositeTensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{2, 1}
}
func (m *TensorInfo_CompositeTensor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorInfo_CompositeTensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TensorInfo_CompositeTensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorInfo_CompositeTensor.Merge(m, src)
}
func (m *TensorInfo_CompositeTensor) XXX_Size() int {
	return m.Size()
}
func (m *TensorInfo_CompositeTensor) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorInfo_CompositeTensor.DiscardUnknown(m)
}

var xxx_messageInfo_TensorInfo_CompositeTensor proto.InternalMessageInfo

func (m *TensorInfo_CompositeTensor) GetTypeSpec() *TypeSpecProto {
	if m != nil {
		return m.TypeSpec
	}
	return nil
}

func (m *TensorInfo_CompositeTensor) GetComponents() []*TensorInfo {
	if m != nil {
		return m.Components
	}
	return nil
}

// SignatureDef defines the signature of a computation supported by a TensorFlow
// graph.
//
// For example, a model with two loss computations, sharing a single input,
// might have the following signature_def map.
//
// Note that across the two SignatureDefs "loss_A" and "loss_B", the input key,
// output key, and method_name are identical, and will be used by system(s) that
// implement or rely upon this particular loss method. The output tensor names
// differ, demonstrating how different outputs can exist for the same method.
//
// signature_def {
//   key: "loss_A"
//   value {
//     inputs {
//       key: "input"
//       value {
//         name: "input:0"
//         dtype: DT_STRING
//         tensor_shape: ...
//       }
//     }
//     outputs {
//       key: "loss_output"
//       value {
//         name: "loss_output_A:0"
//         dtype: DT_FLOAT
//         tensor_shape: ...
//       }
//     }
//   }
//   ...
//   method_name: "some/package/compute_loss"
// }
// signature_def {
//   key: "loss_B"
//   value {
//     inputs {
//       key: "input"
//       value {
//         name: "input:0"
//         dtype: DT_STRING
//         tensor_shape: ...
//       }
//     }
//     outputs {
//       key: "loss_output"
//       value {
//         name: "loss_output_B:0"
//         dtype: DT_FLOAT
//         tensor_shape: ...
//       }
//     }
//   }
//   ...
//   method_name: "some/package/compute_loss"
// }
type SignatureDef struct {
	// Named input parameters.
	Inputs map[string]*TensorInfo `protobuf:"bytes,1,rep,name=inputs,proto3" json:"inputs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Named output parameters.
	Outputs map[string]*TensorInfo `protobuf:"bytes,2,rep,name=outputs,proto3" json:"outputs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Extensible method_name information enabling third-party users to mark a
	// SignatureDef as supporting a particular method. This enables producers and
	// consumers of SignatureDefs, e.g. a model definition library and a serving
	// library to have a clear hand-off regarding the semantics of a computation.
	//
	// Note that multiple SignatureDefs in a single MetaGraphDef may have the same
	// method_name. This is commonly used to support multi-headed computation,
	// where a single graph computation may return multiple results.
	MethodName           string   `protobuf:"bytes,3,opt,name=method_name,json=methodName,proto3" json:"method_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignatureDef) Reset()         { *m = SignatureDef{} }
func (m *SignatureDef) String() string { return proto.CompactTextString(m) }
func (*SignatureDef) ProtoMessage()    {}
func (*SignatureDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{3}
}
func (m *SignatureDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SignatureDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureDef.Merge(m, src)
}
func (m *SignatureDef) XXX_Size() int {
	return m.Size()
}
func (m *SignatureDef) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureDef.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureDef proto.InternalMessageInfo

func (m *SignatureDef) GetInputs() map[string]*TensorInfo {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *SignatureDef) GetOutputs() map[string]*TensorInfo {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *SignatureDef) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

// An asset file def for a single file or a set of sharded files with the same
// name.
type AssetFileDef struct {
	// The tensor to bind the asset filename to.
	TensorInfo *TensorInfo `protobuf:"bytes,1,opt,name=tensor_info,json=tensorInfo,proto3" json:"tensor_info,omitempty"`
	// The filename within an assets directory. Note: does not include the path
	// prefix, i.e. directories. For an asset at /tmp/path/vocab.txt, the filename
	// would be "vocab.txt".
	Filename             string   `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AssetFileDef) Reset()         { *m = AssetFileDef{} }
func (m *AssetFileDef) String() string { return proto.CompactTextString(m) }
func (*AssetFileDef) ProtoMessage()    {}
func (*AssetFileDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_e94adf32e895c059, []int{4}
}
func (m *AssetFileDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetFileDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AssetFileDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetFileDef.Merge(m, src)
}
func (m *AssetFileDef) XXX_Size() int {
	return m.Size()
}
func (m *AssetFileDef) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetFileDef.DiscardUnknown(m)
}

var xxx_messageInfo_AssetFileDef proto.InternalMessageInfo

func (m *AssetFileDef) GetTensorInfo() *TensorInfo {
	if m != nil {
		return m.TensorInfo
	}
	return nil
}

func (m *AssetFileDef) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func init() {
	proto.RegisterType((*MetaGraphDef)(nil), "tensorflow.MetaGraphDef")
	proto.RegisterMapType((map[string]*CollectionDef)(nil), "tensorflow.MetaGraphDef.CollectionDefEntry")
	proto.RegisterMapType((map[string]*SignatureDef)(nil), "tensorflow.MetaGraphDef.SignatureDefEntry")
	proto.RegisterType((*MetaGraphDef_MetaInfoDef)(nil), "tensorflow.MetaGraphDef.MetaInfoDef")
	proto.RegisterMapType((map[string]string)(nil), "tensorflow.MetaGraphDef.MetaInfoDef.FunctionAliasesEntry")
	proto.RegisterType((*CollectionDef)(nil), "tensorflow.CollectionDef")
	proto.RegisterType((*CollectionDef_NodeList)(nil), "tensorflow.CollectionDef.NodeList")
	proto.RegisterType((*CollectionDef_BytesList)(nil), "tensorflow.CollectionDef.BytesList")
	proto.RegisterType((*CollectionDef_Int64List)(nil), "tensorflow.CollectionDef.Int64List")
	proto.RegisterType((*CollectionDef_FloatList)(nil), "tensorflow.CollectionDef.FloatList")
	proto.RegisterType((*CollectionDef_AnyList)(nil), "tensorflow.CollectionDef.AnyList")
	proto.RegisterType((*TensorInfo)(nil), "tensorflow.TensorInfo")
	proto.RegisterType((*TensorInfo_CooSparse)(nil), "tensorflow.TensorInfo.CooSparse")
	proto.RegisterType((*TensorInfo_CompositeTensor)(nil), "tensorflow.TensorInfo.CompositeTensor")
	proto.RegisterType((*SignatureDef)(nil), "tensorflow.SignatureDef")
	proto.RegisterMapType((map[string]*TensorInfo)(nil), "tensorflow.SignatureDef.InputsEntry")
	proto.RegisterMapType((map[string]*TensorInfo)(nil), "tensorflow.SignatureDef.OutputsEntry")
	proto.RegisterType((*AssetFileDef)(nil), "tensorflow.AssetFileDef")
}

func init() {
	proto.RegisterFile("tensorflow/core/protobuf/meta_graph.proto", fileDescriptor_e94adf32e895c059)
}

var fileDescriptor_e94adf32e895c059 = []byte{
	// 1237 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0xaf, 0x77, 0xb3, 0xbb, 0xf1, 0x4b, 0x76, 0x37, 0x1d, 0xa2, 0x92, 0x5a, 0xd5, 0xb2, 0x0d,
	0x6d, 0x55, 0x4a, 0x71, 0xd4, 0xd2, 0x96, 0x3f, 0xaa, 0x5a, 0x25, 0x0d, 0xdb, 0xad, 0x04, 0xdd,
	0xe2, 0x14, 0x24, 0xe0, 0x60, 0x39, 0xf6, 0xd8, 0x6b, 0x9a, 0xcc, 0x58, 0x9e, 0x49, 0xab, 0x1c,
	0x11, 0x1f, 0x82, 0x2b, 0x57, 0xbe, 0x00, 0x9f, 0x81, 0x23, 0x17, 0x24, 0xc4, 0x09, 0xed, 0xa7,
	0xe0, 0x88, 0x66, 0xc6, 0x7f, 0xc6, 0xbb, 0x71, 0xcb, 0x81, 0xdb, 0xbc, 0x79, 0xbf, 0xf7, 0x9b,
	0xf7, 0x6f, 0x9e, 0xc7, 0xf0, 0x1e, 0xc7, 0x84, 0xd1, 0x34, 0x9c, 0xd1, 0x57, 0x03, 0x9f, 0xa6,
	0x78, 0x90, 0xa4, 0x94, 0xd3, 0xe9, 0x22, 0x1c, 0xcc, 0x31, 0xf7, 0xdc, 0x28, 0xf5, 0x92, 0x63,
	0x5b, 0xee, 0x21, 0x28, 0xa1, 0xd6, 0xc5, 0x88, 0xd2, 0x68, 0xa6, 0xa1, 0x3d, 0xb2, 0x54, 0x30,
	0xeb, 0xea, 0x69, 0xc6, 0x30, 0xf5, 0xe6, 0xf8, 0x15, 0x4d, 0x5f, 0x0c, 0x34, 0x36, 0xeb, 0x5a,
	0x3d, 0x8c, 0x26, 0x6e, 0x80, 0xc3, 0x0c, 0x77, 0xb3, 0x1e, 0xa7, 0x34, 0x2e, 0x3b, 0xf6, 0x12,
	0xfc, 0xe6, 0xc3, 0xf9, 0x32, 0xc1, 0x2c, 0x83, 0xdd, 0xaa, 0x8d, 0x9a, 0x79, 0x2f, 0x71, 0xe0,
	0xd2, 0xe9, 0xf7, 0xd8, 0xe7, 0x7a, 0xf4, 0xd6, 0x95, 0xd7, 0x9a, 0xa4, 0x75, 0xe7, 0x97, 0x28,
	0x9e, 0x2e, 0x7c, 0xae, 0x60, 0xfd, 0x5f, 0x4c, 0x68, 0x7f, 0x81, 0xb9, 0xf7, 0x58, 0x1c, 0x30,
	0xc6, 0x21, 0x3a, 0x84, 0x6d, 0x99, 0xef, 0x98, 0x84, 0x54, 0x04, 0xdf, 0x33, 0xf6, 0x8d, 0xeb,
	0xad, 0xdb, 0x57, 0xec, 0x92, 0xcf, 0xd6, 0x0d, 0xa4, 0xf0, 0x84, 0x84, 0x74, 0x8c, 0x43, 0xa7,
	0x35, 0x2f, 0x05, 0x74, 0x0b, 0x4c, 0xe9, 0xb6, 0x64, 0x59, 0x93, 0x2c, 0x5d, 0x9d, 0x25, 0x67,
	0x70, 0x9a, 0x51, 0x7e, 0xf8, 0x2d, 0x30, 0x65, 0x0c, 0xd2, 0x64, 0xfd, 0xac, 0xc9, 0x44, 0x28,
	0xa5, 0x09, 0xcb, 0x56, 0xc8, 0x81, 0x1d, 0x9f, 0xce, 0x66, 0xd8, 0xe7, 0x31, 0x25, 0xd2, 0xae,
	0xb1, 0xbf, 0x7e, 0xbd, 0x75, 0xfb, 0xfd, 0x5a, 0x87, 0x1f, 0x15, 0xf0, 0x31, 0x0e, 0x3f, 0x23,
	0x3c, 0x5d, 0x3a, 0xdb, 0xbe, 0xbe, 0x87, 0x8e, 0x60, 0x9b, 0xc5, 0x11, 0xf1, 0xf8, 0x22, 0xc5,
	0x92, 0x72, 0x43, 0x52, 0xde, 0xa8, 0xa5, 0x9c, 0xe4, 0xe8, 0x82, 0xb1, 0xcd, 0xb4, 0x2d, 0xf4,
	0x00, 0x76, 0x3c, 0xc6, 0x30, 0x77, 0xc3, 0x78, 0xa6, 0x18, 0x37, 0x25, 0x63, 0x4f, 0x67, 0x1c,
	0x0a, 0xc4, 0x41, 0x3c, 0x13, 0x16, 0x4e, 0xdb, 0xd3, 0x24, 0x74, 0x00, 0x1d, 0xbd, 0x11, 0x24,
	0xc3, 0x96, 0x4c, 0xcf, 0xa5, 0xd3, 0xe9, 0x09, 0x8e, 0x24, 0x50, 0xba, 0xe6, 0xec, 0xd0, 0x52,
	0x18, 0xe3, 0xd0, 0xfa, 0xb1, 0x01, 0x2d, 0xad, 0x5e, 0xe8, 0x26, 0xa0, 0xf2, 0x72, 0xb9, 0x2f,
	0x71, 0xca, 0x62, 0x4a, 0x64, 0xc5, 0x4d, 0xa7, 0x33, 0xcf, 0x23, 0xfc, 0x5a, 0xed, 0xa3, 0xfb,
	0xd0, 0x61, 0x3c, 0x8d, 0x93, 0x44, 0xf4, 0x65, 0xe2, 0xce, 0x62, 0xc6, 0xb3, 0xba, 0x22, 0xdd,
	0x8b, 0xa3, 0xe4, 0xf3, 0x98, 0x71, 0x67, 0x27, 0xc7, 0x2a, 0x19, 0x0d, 0xa0, 0xe9, 0x91, 0xa5,
	0xec, 0xab, 0xa2, 0xb4, 0xea, 0xee, 0xda, 0x79, 0x6b, 0xda, 0x43, 0xb2, 0x74, 0xb6, 0x3c, 0xb2,
	0x14, 0xfe, 0x21, 0x04, 0x0d, 0xee, 0x45, 0x4c, 0xd6, 0xd3, 0x74, 0xe4, 0x1a, 0x7d, 0x00, 0xa8,
	0x3c, 0xa9, 0x70, 0x78, 0x43, 0x3a, 0x7c, 0xbe, 0xd4, 0xe4, 0x1e, 0xdf, 0x81, 0x0b, 0x1a, 0x3c,
	0x8a, 0x79, 0x61, 0xb2, 0x29, 0x4d, 0xba, 0xa5, 0xf6, 0x71, 0xcc, 0x35, 0xab, 0x22, 0xce, 0x00,
	0x87, 0xde, 0x62, 0xc6, 0x5d, 0x8f, 0xf3, 0x94, 0xc9, 0x9c, 0x37, 0x9d, 0x6e, 0xae, 0x1d, 0x2b,
	0xe5, 0x50, 0xe8, 0x50, 0x00, 0x9d, 0x70, 0x41, 0x54, 0x1b, 0x7a, 0xb3, 0xd8, 0x63, 0x98, 0xf5,
	0x9a, 0xb2, 0xca, 0x9f, 0xfc, 0x97, 0xbb, 0x63, 0x1f, 0x64, 0xc6, 0x43, 0x65, 0xab, 0xda, 0x68,
	0x37, 0xac, 0xee, 0x5a, 0x23, 0xe8, 0xae, 0x02, 0xa2, 0x0e, 0xac, 0xbf, 0xc0, 0xcb, 0xac, 0x74,
	0x62, 0x89, 0xba, 0xb0, 0xf1, 0xd2, 0x9b, 0x2d, 0xb0, 0x2c, 0x91, 0xe9, 0x28, 0xe1, 0xd3, 0xb5,
	0x8f, 0x0d, 0xeb, 0x3b, 0x40, 0x67, 0xef, 0xc0, 0x0a, 0x86, 0x81, 0xce, 0xd0, 0xba, 0x7d, 0x51,
	0x0f, 0xa3, 0x42, 0xa0, 0x93, 0x7f, 0x03, 0xe7, 0xcf, 0xdc, 0x86, 0x15, 0xdc, 0x76, 0x95, 0xbb,
	0x72, 0x11, 0x74, 0x7b, 0x8d, 0xba, 0xff, 0x6b, 0x03, 0xb6, 0x2b, 0xe7, 0xa2, 0x21, 0x98, 0x84,
	0x06, 0x58, 0xb5, 0xa2, 0x1a, 0x54, 0xfd, 0x5a, 0x2f, 0xed, 0xa7, 0x34, 0xc0, 0xa2, 0x15, 0x0f,
	0xcf, 0x39, 0x4d, 0x92, 0xad, 0xd1, 0x18, 0x60, 0xba, 0xe4, 0x98, 0xe9, 0xed, 0xfc, 0x6e, 0x3d,
	0xc7, 0x48, 0x60, 0x33, 0x12, 0x73, 0x9a, 0x0b, 0x82, 0x25, 0x26, 0xfc, 0xde, 0x1d, 0xc5, 0xb2,
	0xfe, 0x26, 0x96, 0x27, 0x02, 0x9b, 0xb3, 0xc4, 0xb9, 0x20, 0x58, 0xc2, 0x19, 0xf5, 0xb8, 0x62,
	0x69, 0xbc, 0x89, 0xe5, 0x40, 0x60, 0x73, 0x96, 0x30, 0x17, 0xd0, 0x03, 0x75, 0xd1, 0x24, 0xc7,
	0x86, 0xe4, 0xb8, 0x5c, 0xcf, 0x31, 0x24, 0xcb, 0x8c, 0x41, 0xdc, 0x3b, 0xb1, 0xb4, 0xf6, 0xa1,
	0x99, 0x67, 0xaa, 0x6c, 0x22, 0x43, 0x5e, 0x42, 0x25, 0x58, 0x97, 0xc1, 0x2c, 0xf2, 0x50, 0x85,
	0xb4, 0x73, 0xc8, 0x55, 0x30, 0x8b, 0x20, 0x51, 0x4f, 0x87, 0xac, 0x8f, 0xd6, 0x3a, 0x86, 0x06,
	0x2b, 0xa2, 0xa8, 0xc2, 0xd6, 0x74, 0xd8, 0x5d, 0xd8, 0xca, 0x1c, 0x45, 0x37, 0x74, 0x50, 0xdd,
	0x0c, 0x51, 0x90, 0xd1, 0x26, 0x34, 0x5e, 0xc4, 0x24, 0xe8, 0xff, 0xd5, 0x00, 0x78, 0x2e, 0x33,
	0x20, 0x07, 0x4b, 0x17, 0x1a, 0xc4, 0x9b, 0x63, 0xd5, 0x8e, 0x87, 0xe7, 0x1c, 0x29, 0xa1, 0x21,
	0x80, 0x4f, 0xa9, 0xcb, 0x12, 0x2f, 0x65, 0x38, 0x4b, 0xfe, 0xbe, 0x9e, 0xb8, 0x92, 0xc1, 0x7e,
	0x44, 0xe9, 0x44, 0xe2, 0x44, 0xe6, 0xfd, 0x5c, 0x40, 0x13, 0xe8, 0xf8, 0x74, 0x9e, 0x50, 0x16,
	0x73, 0xec, 0x2a, 0xcb, 0xac, 0x02, 0xd7, 0x6a, 0x89, 0x32, 0xb8, 0xda, 0x3b, 0x3c, 0xe7, 0xec,
	0xfa, 0xd5, 0x2d, 0x11, 0x70, 0x20, 0x5e, 0x0c, 0xb2, 0x37, 0x77, 0xaa, 0xdf, 0xc3, 0xb1, 0xc7,
	0xbd, 0xe7, 0xcb, 0x04, 0x3b, 0x0a, 0x82, 0x1e, 0x42, 0x5b, 0x7f, 0x8a, 0x64, 0x8d, 0x78, 0xe9,
	0xec, 0xe1, 0x13, 0xa1, 0x7e, 0x26, 0x52, 0xe6, 0xb4, 0x78, 0xb9, 0x63, 0xfd, 0x6c, 0x80, 0x59,
	0x04, 0x27, 0x3e, 0x0f, 0x32, 0x91, 0x2c, 0x0b, 0xc6, 0x2d, 0xd3, 0xe6, 0x74, 0x94, 0x46, 0xd1,
	0x3d, 0x15, 0x09, 0xb4, 0xe1, 0xad, 0x98, 0x04, 0xb1, 0x7f, 0x0a, 0xae, 0xc6, 0xcf, 0xf9, 0x4c,
	0xa5, 0xe1, 0xef, 0xc2, 0xdb, 0x01, 0x26, 0x0c, 0x2b, 0x5f, 0x2b, 0x36, 0xeb, 0x6a, 0x3a, 0x4b,
	0xb5, 0x74, 0xac, 0x34, 0xb3, 0x7e, 0x30, 0x60, 0xf7, 0x54, 0xda, 0xd0, 0x3d, 0x30, 0x45, 0xfc,
	0x2e, 0x4b, 0xb0, 0x9f, 0xcd, 0x81, 0xca, 0xb4, 0x12, 0x39, 0x9a, 0x24, 0xd8, 0x57, 0x11, 0x37,
	0x79, 0x26, 0xa2, 0x7b, 0xa2, 0xe6, 0xf3, 0x84, 0x12, 0x4c, 0x38, 0xeb, 0xad, 0xc9, 0x8e, 0xba,
	0xb0, 0xba, 0x54, 0x8e, 0x86, 0x1c, 0x01, 0x34, 0x31, 0xf1, 0x69, 0x10, 0x93, 0xa8, 0xff, 0xc7,
	0x1a, 0xb4, 0xf5, 0x89, 0x85, 0xee, 0xc3, 0x66, 0x4c, 0x92, 0x05, 0x67, 0x59, 0x8b, 0x5e, 0xa9,
	0x9b, 0x6d, 0xf6, 0x13, 0x09, 0x53, 0x93, 0x3e, 0xb3, 0x41, 0x0f, 0x61, 0x8b, 0x2e, 0xb8, 0x34,
	0x57, 0xfe, 0x5c, 0xad, 0x35, 0x3f, 0x52, 0x38, 0x65, 0x9f, 0x5b, 0xa1, 0x77, 0x40, 0xbc, 0xc2,
	0x8e, 0x69, 0xa0, 0xa7, 0x12, 0xd4, 0x96, 0x4c, 0xe0, 0x97, 0xd0, 0xd2, 0x0e, 0x5e, 0x31, 0x9b,
	0x6f, 0x56, 0x67, 0x73, 0x5d, 0x42, 0xb4, 0xa1, 0xef, 0x40, 0x5b, 0x77, 0xe6, 0xff, 0xe0, 0xec,
	0xfb, 0xd0, 0xd6, 0x5f, 0x44, 0xe8, 0x23, 0xc8, 0x3a, 0x55, 0x3d, 0x21, 0x8c, 0xd7, 0xf2, 0x64,
	0x7f, 0x08, 0xf2, 0xba, 0x5b, 0xd0, 0x14, 0xcf, 0x2e, 0xad, 0x19, 0x0b, 0x79, 0xf4, 0x93, 0xf1,
	0xdb, 0xc9, 0x9e, 0xf1, 0xfb, 0xc9, 0x9e, 0xf1, 0xe7, 0xc9, 0x9e, 0xf1, 0xf7, 0xc9, 0x9e, 0x01,
	0x3d, 0x9a, 0x46, 0x3a, 0x6b, 0xf1, 0x6e, 0x1f, 0xed, 0x16, 0xdf, 0x6e, 0xd9, 0x47, 0xec, 0x99,
	0xf1, 0xed, 0x57, 0x51, 0xcc, 0x8f, 0x17, 0x53, 0xdb, 0xa7, 0xf3, 0x81, 0xf6, 0xe0, 0x5e, 0xbd,
	0x8c, 0xe8, 0xa9, 0x97, 0x78, 0x48, 0x53, 0x57, 0xec, 0xb8, 0x72, 0x87, 0xb9, 0x11, 0x55, 0xab,
	0x7f, 0x0c, 0x63, 0xba, 0x29, 0x57, 0x1f, 0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x2f, 0x06, 0x1e,
	0x5e, 0x17, 0x0d, 0x00, 0x00,
}

func (m *MetaGraphDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaGraphDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaGraphDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ObjectGraphDef != nil {
		{
			size, err := m.ObjectGraphDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AssetFileDef) > 0 {
		for iNdEx := len(m.AssetFileDef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssetFileDef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetaGraph(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SignatureDef) > 0 {
		keysForSignatureDef := make([]string, 0, len(m.SignatureDef))
		for k := range m.SignatureDef {
			keysForSignatureDef = append(keysForSignatureDef, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForSignatureDef)
		for iNdEx := len(keysForSignatureDef) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SignatureDef[string(keysForSignatureDef[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMetaGraph(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForSignatureDef[iNdEx])
			copy(dAtA[i:], keysForSignatureDef[iNdEx])
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(keysForSignatureDef[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetaGraph(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CollectionDef) > 0 {
		keysForCollectionDef := make([]string, 0, len(m.CollectionDef))
		for k := range m.CollectionDef {
			keysForCollectionDef = append(keysForCollectionDef, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForCollectionDef)
		for iNdEx := len(keysForCollectionDef) - 1; iNdEx >= 0; iNdEx-- {
			v := m.CollectionDef[string(keysForCollectionDef[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMetaGraph(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForCollectionDef[iNdEx])
			copy(dAtA[i:], keysForCollectionDef[iNdEx])
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(keysForCollectionDef[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetaGraph(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SaverDef != nil {
		{
			size, err := m.SaverDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.GraphDef != nil {
		{
			size, err := m.GraphDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MetaInfoDef != nil {
		{
			size, err := m.MetaInfoDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetaGraphDef_MetaInfoDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaGraphDef_MetaInfoDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaGraphDef_MetaInfoDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FunctionAliases) > 0 {
		keysForFunctionAliases := make([]string, 0, len(m.FunctionAliases))
		for k := range m.FunctionAliases {
			keysForFunctionAliases = append(keysForFunctionAliases, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForFunctionAliases)
		for iNdEx := len(keysForFunctionAliases) - 1; iNdEx >= 0; iNdEx-- {
			v := m.FunctionAliases[string(keysForFunctionAliases[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForFunctionAliases[iNdEx])
			copy(dAtA[i:], keysForFunctionAliases[iNdEx])
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(keysForFunctionAliases[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetaGraph(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.StrippedDefaultAttrs {
		i--
		if m.StrippedDefaultAttrs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.TensorflowGitVersion) > 0 {
		i -= len(m.TensorflowGitVersion)
		copy(dAtA[i:], m.TensorflowGitVersion)
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.TensorflowGitVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TensorflowVersion) > 0 {
		i -= len(m.TensorflowVersion)
		copy(dAtA[i:], m.TensorflowVersion)
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.TensorflowVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.AnyInfo != nil {
		{
			size, err := m.AnyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StrippedOpList != nil {
		{
			size, err := m.StrippedOpList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MetaGraphVersion) > 0 {
		i -= len(m.MetaGraphVersion)
		copy(dAtA[i:], m.MetaGraphVersion)
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.MetaGraphVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionDef_NodeList_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef_NodeList_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodeList != nil {
		{
			size, err := m.NodeList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CollectionDef_BytesList_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef_BytesList_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BytesList != nil {
		{
			size, err := m.BytesList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CollectionDef_Int64List_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef_Int64List_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Int64List != nil {
		{
			size, err := m.Int64List.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CollectionDef_FloatList_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef_FloatList_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FloatList != nil {
		{
			size, err := m.FloatList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CollectionDef_AnyList_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef_AnyList_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyList != nil {
		{
			size, err := m.AnyList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CollectionDef_NodeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef_NodeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef_NodeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Value[iNdEx])
			copy(dAtA[i:], m.Value[iNdEx])
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.Value[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionDef_BytesList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef_BytesList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef_BytesList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Value[iNdEx])
			copy(dAtA[i:], m.Value[iNdEx])
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.Value[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionDef_Int64List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef_Int64List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef_Int64List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		dAtA15 := make([]byte, len(m.Value)*10)
		var j14 int
		for _, num1 := range m.Value {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintMetaGraph(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionDef_FloatList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef_FloatList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef_FloatList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			f16 := math.Float32bits(float32(m.Value[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f16))
		}
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.Value)*4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionDef_AnyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef_AnyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDef_AnyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Value[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetaGraph(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TensorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Encoding != nil {
		{
			size := m.Encoding.Size()
			i -= size
			if _, err := m.Encoding.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TensorShape != nil {
		{
			size, err := m.TensorShape.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Dtype != 0 {
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.Dtype))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *TensorInfo_Name) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorInfo_Name) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *TensorInfo_CooSparse_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorInfo_CooSparse_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CooSparse != nil {
		{
			size, err := m.CooSparse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TensorInfo_CompositeTensor_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorInfo_CompositeTensor_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CompositeTensor != nil {
		{
			size, err := m.CompositeTensor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *TensorInfo_CooSparse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorInfo_CooSparse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorInfo_CooSparse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DenseShapeTensorName) > 0 {
		i -= len(m.DenseShapeTensorName)
		copy(dAtA[i:], m.DenseShapeTensorName)
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.DenseShapeTensorName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IndicesTensorName) > 0 {
		i -= len(m.IndicesTensorName)
		copy(dAtA[i:], m.IndicesTensorName)
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.IndicesTensorName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValuesTensorName) > 0 {
		i -= len(m.ValuesTensorName)
		copy(dAtA[i:], m.ValuesTensorName)
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.ValuesTensorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TensorInfo_CompositeTensor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorInfo_CompositeTensor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorInfo_CompositeTensor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Components) > 0 {
		for iNdEx := len(m.Components) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Components[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetaGraph(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TypeSpec != nil {
		{
			size, err := m.TypeSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignatureDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MethodName) > 0 {
		i -= len(m.MethodName)
		copy(dAtA[i:], m.MethodName)
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.MethodName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Outputs) > 0 {
		keysForOutputs := make([]string, 0, len(m.Outputs))
		for k := range m.Outputs {
			keysForOutputs = append(keysForOutputs, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForOutputs)
		for iNdEx := len(keysForOutputs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Outputs[string(keysForOutputs[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMetaGraph(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForOutputs[iNdEx])
			copy(dAtA[i:], keysForOutputs[iNdEx])
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(keysForOutputs[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetaGraph(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Inputs) > 0 {
		keysForInputs := make([]string, 0, len(m.Inputs))
		for k := range m.Inputs {
			keysForInputs = append(keysForInputs, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForInputs)
		for iNdEx := len(keysForInputs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Inputs[string(keysForInputs[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMetaGraph(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForInputs[iNdEx])
			copy(dAtA[i:], keysForInputs[iNdEx])
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(keysForInputs[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetaGraph(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AssetFileDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetFileDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetFileDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x12
	}
	if m.TensorInfo != nil {
		{
			size, err := m.TensorInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetaGraph(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetaGraph(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MetaGraphDef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetaInfoDef != nil {
		l = m.MetaInfoDef.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.GraphDef != nil {
		l = m.GraphDef.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.SaverDef != nil {
		l = m.SaverDef.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if len(m.CollectionDef) > 0 {
		for k, v := range m.CollectionDef {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetaGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetaGraph(uint64(mapEntrySize))
		}
	}
	if len(m.SignatureDef) > 0 {
		for k, v := range m.SignatureDef {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetaGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetaGraph(uint64(mapEntrySize))
		}
	}
	if len(m.AssetFileDef) > 0 {
		for _, e := range m.AssetFileDef {
			l = e.Size()
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	if m.ObjectGraphDef != nil {
		l = m.ObjectGraphDef.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetaGraphDef_MetaInfoDef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetaGraphVersion)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.StrippedOpList != nil {
		l = m.StrippedOpList.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.AnyInfo != nil {
		l = m.AnyInfo.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	l = len(m.TensorflowVersion)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	l = len(m.TensorflowGitVersion)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.StrippedDefaultAttrs {
		n += 2
	}
	if len(m.FunctionAliases) > 0 {
		for k, v := range m.FunctionAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + 1 + len(v) + sovMetaGraph(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetaGraph(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionDef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionDef_NodeList_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeList != nil {
		l = m.NodeList.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *CollectionDef_BytesList_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesList != nil {
		l = m.BytesList.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *CollectionDef_Int64List_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Int64List != nil {
		l = m.Int64List.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *CollectionDef_FloatList_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FloatList != nil {
		l = m.FloatList.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *CollectionDef_AnyList_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyList != nil {
		l = m.AnyList.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *CollectionDef_NodeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionDef_BytesList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, b := range m.Value {
			l = len(b)
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionDef_Int64List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		l = 0
		for _, e := range m.Value {
			l += sovMetaGraph(uint64(e))
		}
		n += 1 + sovMetaGraph(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionDef_FloatList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		n += 1 + sovMetaGraph(uint64(len(m.Value)*4)) + len(m.Value)*4
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionDef_AnyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TensorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Encoding != nil {
		n += m.Encoding.Size()
	}
	if m.Dtype != 0 {
		n += 1 + sovMetaGraph(uint64(m.Dtype))
	}
	if m.TensorShape != nil {
		l = m.TensorShape.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TensorInfo_Name) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetaGraph(uint64(l))
	return n
}
func (m *TensorInfo_CooSparse_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CooSparse != nil {
		l = m.CooSparse.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *TensorInfo_CompositeTensor_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeTensor != nil {
		l = m.CompositeTensor.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *TensorInfo_CooSparse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValuesTensorName)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	l = len(m.IndicesTensorName)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	l = len(m.DenseShapeTensorName)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TensorInfo_CompositeTensor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeSpec != nil {
		l = m.TypeSpec.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if len(m.Components) > 0 {
		for _, e := range m.Components {
			l = e.Size()
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignatureDef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Inputs) > 0 {
		for k, v := range m.Inputs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetaGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetaGraph(uint64(mapEntrySize))
		}
	}
	if len(m.Outputs) > 0 {
		for k, v := range m.Outputs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetaGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetaGraph(uint64(mapEntrySize))
		}
	}
	l = len(m.MethodName)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AssetFileDef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TensorInfo != nil {
		l = m.TensorInfo.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetaGraph(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetaGraph(x uint64) (n int) {
	return sovMetaGraph(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MetaGraphDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaGraphDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaGraphDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaInfoDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaInfoDef == nil {
				m.MetaInfoDef = &MetaGraphDef_MetaInfoDef{}
			}
			if err := m.MetaInfoDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphDef == nil {
				m.GraphDef = &graph_go_proto.GraphDef{}
			}
			if err := m.GraphDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SaverDef == nil {
				m.SaverDef = &SaverDef{}
			}
			if err := m.SaverDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionDef == nil {
				m.CollectionDef = make(map[string]*CollectionDef)
			}
			var mapkey string
			var mapvalue *CollectionDef
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CollectionDef{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetaGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CollectionDef[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignatureDef == nil {
				m.SignatureDef = make(map[string]*SignatureDef)
			}
			var mapkey string
			var mapvalue *SignatureDef
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SignatureDef{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetaGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SignatureDef[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetFileDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetFileDef = append(m.AssetFileDef, &AssetFileDef{})
			if err := m.AssetFileDef[len(m.AssetFileDef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectGraphDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectGraphDef == nil {
				m.ObjectGraphDef = &SavedObjectGraph{}
			}
			if err := m.ObjectGraphDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaGraphDef_MetaInfoDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaInfoDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaInfoDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaGraphVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaGraphVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrippedOpList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StrippedOpList == nil {
				m.StrippedOpList = &op_def_go_proto.OpList{}
			}
			if err := m.StrippedOpList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnyInfo == nil {
				m.AnyInfo = &types.Any{}
			}
			if err := m.AnyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorflowVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorflowVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorflowGitVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorflowGitVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrippedDefaultAttrs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StrippedDefaultAttrs = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FunctionAliases == nil {
				m.FunctionAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetaGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FunctionAliases[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionDef_NodeList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &CollectionDef_NodeList_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionDef_BytesList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &CollectionDef_BytesList_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionDef_Int64List{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &CollectionDef_Int64List_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionDef_FloatList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &CollectionDef_FloatList_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionDef_AnyList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &CollectionDef_AnyList_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef_NodeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef_BytesList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BytesList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BytesList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, make([]byte, postIndex-iNdEx))
			copy(m.Value[len(m.Value)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef_Int64List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int64List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int64List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Value = append(m.Value, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMetaGraph
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMetaGraph
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Value) == 0 {
					m.Value = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Value = append(m.Value, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef_FloatList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Value = append(m.Value, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMetaGraph
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMetaGraph
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Value) == 0 {
					m.Value = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Value = append(m.Value, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef_AnyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &types.Any{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = &TensorInfo_Name{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= types_go_proto.DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorShape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TensorShape == nil {
				m.TensorShape = &tensor_shape_go_proto.TensorShapeProto{}
			}
			if err := m.TensorShape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CooSparse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TensorInfo_CooSparse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Encoding = &TensorInfo_CooSparse_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeTensor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TensorInfo_CompositeTensor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Encoding = &TensorInfo_CompositeTensor_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorInfo_CooSparse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CooSparse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CooSparse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValuesTensorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValuesTensorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndicesTensorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndicesTensorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseShapeTensorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenseShapeTensorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorInfo_CompositeTensor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompositeTensor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompositeTensor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeSpec == nil {
				m.TypeSpec = &TypeSpecProto{}
			}
			if err := m.TypeSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Components = append(m.Components, &TensorInfo{})
			if err := m.Components[len(m.Components)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inputs == nil {
				m.Inputs = make(map[string]*TensorInfo)
			}
			var mapkey string
			var mapvalue *TensorInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TensorInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetaGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Inputs[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outputs == nil {
				m.Outputs = make(map[string]*TensorInfo)
			}
			var mapkey string
			var mapvalue *TensorInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TensorInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetaGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Outputs[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MethodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetFileDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetFileDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetFileDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TensorInfo == nil {
				m.TensorInfo = &TensorInfo{}
			}
			if err := m.TensorInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetaGraph(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetaGraph
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetaGraph
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetaGraph
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetaGraph        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetaGraph          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetaGraph = fmt.Errorf("proto: unexpected end of group")
)
