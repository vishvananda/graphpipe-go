// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/stream_executor/dnn.proto

package stream_executor

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Specifies the data type used by an operation.
type DataType int32

const (
	DataType_kFloat         DataType = 0
	DataType_kDouble        DataType = 1
	DataType_kHalf          DataType = 2
	DataType_kInt8          DataType = 3
	DataType_kInt32         DataType = 4
	DataType_kComplexFloat  DataType = 5
	DataType_kComplexDouble DataType = 6
)

var DataType_name = map[int32]string{
	0: "kFloat",
	1: "kDouble",
	2: "kHalf",
	3: "kInt8",
	4: "kInt32",
	5: "kComplexFloat",
	6: "kComplexDouble",
}

var DataType_value = map[string]int32{
	"kFloat":         0,
	"kDouble":        1,
	"kHalf":          2,
	"kInt8":          3,
	"kInt32":         4,
	"kComplexFloat":  5,
	"kComplexDouble": 6,
}

func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}

func (DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_768c61f2a579ee6a, []int{0}
}

// Describes how a convolution input or output layer's data is formatted.
type DataLayout int32

const (
	// Naming convention:
	// Y <-> row or height
	// X <-> column or width
	// Batch <-> batch, or N
	// Depth <-> feature, or channel
	// TODO(timshen): turn them into cuDNN names, e.g. kNCHW.
	DataLayout_kYXDepthBatch  DataLayout = 0
	DataLayout_kYXBatchDepth  DataLayout = 1
	DataLayout_kBatchYXDepth  DataLayout = 2
	DataLayout_kBatchDepthYX  DataLayout = 3
	DataLayout_kBatchDepthYX4 DataLayout = 4
)

var DataLayout_name = map[int32]string{
	0: "kYXDepthBatch",
	1: "kYXBatchDepth",
	2: "kBatchYXDepth",
	3: "kBatchDepthYX",
	4: "kBatchDepthYX4",
}

var DataLayout_value = map[string]int32{
	"kYXDepthBatch":  0,
	"kYXBatchDepth":  1,
	"kBatchYXDepth":  2,
	"kBatchDepthYX":  3,
	"kBatchDepthYX4": 4,
}

func (x DataLayout) String() string {
	return proto.EnumName(DataLayout_name, int32(x))
}

func (DataLayout) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_768c61f2a579ee6a, []int{1}
}

// Describes how a convolution filter is laid out in the memory.
type FilterLayout int32

const (
	// Naming convention:
	// Y <-> row or height
	// X <-> column or width
	// Output <-> output feature, or N
	// Input <-> input feature, or N
	// TODO(timshen): turn them into cuDNN names, e.g. kNCHW.
	FilterLayout_kOutputInputYX  FilterLayout = 0
	FilterLayout_kOutputYXInput  FilterLayout = 1
	FilterLayout_kOutputInputYX4 FilterLayout = 2
	FilterLayout_kInputYXOutput  FilterLayout = 3
	FilterLayout_kYXInputOutput  FilterLayout = 4
)

var FilterLayout_name = map[int32]string{
	0: "kOutputInputYX",
	1: "kOutputYXInput",
	2: "kOutputInputYX4",
	3: "kInputYXOutput",
	4: "kYXInputOutput",
}

var FilterLayout_value = map[string]int32{
	"kOutputInputYX":  0,
	"kOutputYXInput":  1,
	"kOutputInputYX4": 2,
	"kInputYXOutput":  3,
	"kYXInputOutput":  4,
}

func (x FilterLayout) String() string {
	return proto.EnumName(FilterLayout_name, int32(x))
}

func (FilterLayout) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_768c61f2a579ee6a, []int{2}
}

// Describes a kind of non-linearity (threshold-like mathematical function).
type ActivationMode int32

const (
	ActivationMode_kNone    ActivationMode = 0
	ActivationMode_kSigmoid ActivationMode = 1
	// Rectified linear activation: f(x) = x < 0 ? 0 : x
	ActivationMode_kRelu ActivationMode = 2
	// Rectified linear activation; where upper maximum is 6.0.
	ActivationMode_kRelu6 ActivationMode = 3
	// Rectified linear activation; where upper maximum specified by
	// BatchDescriptor::value_max().
	ActivationMode_kReluX ActivationMode = 4
	ActivationMode_kTanh  ActivationMode = 5
	// Like ReluX; but passes all values in the range [-X,X].
	ActivationMode_kBandPass ActivationMode = 6
)

var ActivationMode_name = map[int32]string{
	0: "kNone",
	1: "kSigmoid",
	2: "kRelu",
	3: "kRelu6",
	4: "kReluX",
	5: "kTanh",
	6: "kBandPass",
}

var ActivationMode_value = map[string]int32{
	"kNone":     0,
	"kSigmoid":  1,
	"kRelu":     2,
	"kRelu6":    3,
	"kReluX":    4,
	"kTanh":     5,
	"kBandPass": 6,
}

func (x ActivationMode) String() string {
	return proto.EnumName(ActivationMode_name, int32(x))
}

func (ActivationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_768c61f2a579ee6a, []int{3}
}

// Describe the math definition for the conv op. The popular behavior is
// actually called cross-correlation in math, despite the operation is often
// referred as convolution. See cuDNN cudnnConvolutionMode_t.
type ConvolutionMode int32

const (
	ConvolutionMode_CROSS_CORRELATION ConvolutionMode = 0
	ConvolutionMode_CONVOLUTION       ConvolutionMode = 1
)

var ConvolutionMode_name = map[int32]string{
	0: "CROSS_CORRELATION",
	1: "CONVOLUTION",
}

var ConvolutionMode_value = map[string]int32{
	"CROSS_CORRELATION": 0,
	"CONVOLUTION":       1,
}

func (x ConvolutionMode) String() string {
	return proto.EnumName(ConvolutionMode_name, int32(x))
}

func (ConvolutionMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_768c61f2a579ee6a, []int{4}
}

type ConvolutionKind int32

const (
	ConvolutionKind_INVALID                 ConvolutionKind = 0
	ConvolutionKind_FORWARD                 ConvolutionKind = 1
	ConvolutionKind_BACKWARD_FILTER         ConvolutionKind = 2
	ConvolutionKind_BACKWARD_DATA           ConvolutionKind = 3
	ConvolutionKind_FORWARD_BIAS_ACTIVATION ConvolutionKind = 4
)

var ConvolutionKind_name = map[int32]string{
	0: "INVALID",
	1: "FORWARD",
	2: "BACKWARD_FILTER",
	3: "BACKWARD_DATA",
	4: "FORWARD_BIAS_ACTIVATION",
}

var ConvolutionKind_value = map[string]int32{
	"INVALID":                 0,
	"FORWARD":                 1,
	"BACKWARD_FILTER":         2,
	"BACKWARD_DATA":           3,
	"FORWARD_BIAS_ACTIVATION": 4,
}

func (x ConvolutionKind) String() string {
	return proto.EnumName(ConvolutionKind_name, int32(x))
}

func (ConvolutionKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_768c61f2a579ee6a, []int{5}
}

type AlgorithmProto_MathType int32

const (
	AlgorithmProto_DEFAULT_MATH AlgorithmProto_MathType = 0
	// The GPU may operate 4x4 matrix FMA.
	// See cuDNN's documentation for CUDNN_TENSOR_OP_MATH.
	AlgorithmProto_TENSOR_OP_MATH AlgorithmProto_MathType = 1
)

var AlgorithmProto_MathType_name = map[int32]string{
	0: "DEFAULT_MATH",
	1: "TENSOR_OP_MATH",
}

var AlgorithmProto_MathType_value = map[string]int32{
	"DEFAULT_MATH":   0,
	"TENSOR_OP_MATH": 1,
}

func (x AlgorithmProto_MathType) String() string {
	return proto.EnumName(AlgorithmProto_MathType_name, int32(x))
}

func (AlgorithmProto_MathType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_768c61f2a579ee6a, []int{1, 0}
}

// Generic tensor representation.
type TensorDescriptorProto struct {
	Dimensions []int64  `protobuf:"varint,1,rep,packed,name=dimensions,proto3" json:"dimensions,omitempty"`
	DataType   DataType `protobuf:"varint,2,opt,name=data_type,json=dataType,proto3,enum=stream_executor.dnn.DataType" json:"data_type,omitempty"`
	// Types that are valid to be assigned to LayoutOneof:
	//	*TensorDescriptorProto_DataLayout
	//	*TensorDescriptorProto_FilterLayout
	LayoutOneof          isTensorDescriptorProto_LayoutOneof `protobuf_oneof:"layout_oneof"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *TensorDescriptorProto) Reset()         { *m = TensorDescriptorProto{} }
func (m *TensorDescriptorProto) String() string { return proto.CompactTextString(m) }
func (*TensorDescriptorProto) ProtoMessage()    {}
func (*TensorDescriptorProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_768c61f2a579ee6a, []int{0}
}
func (m *TensorDescriptorProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorDescriptorProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TensorDescriptorProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorDescriptorProto.Merge(m, src)
}
func (m *TensorDescriptorProto) XXX_Size() int {
	return m.Size()
}
func (m *TensorDescriptorProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorDescriptorProto.DiscardUnknown(m)
}

var xxx_messageInfo_TensorDescriptorProto proto.InternalMessageInfo

type isTensorDescriptorProto_LayoutOneof interface {
	isTensorDescriptorProto_LayoutOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TensorDescriptorProto_DataLayout struct {
	DataLayout DataLayout `protobuf:"varint,3,opt,name=data_layout,json=dataLayout,proto3,enum=stream_executor.dnn.DataLayout,oneof" json:"data_layout,omitempty"`
}
type TensorDescriptorProto_FilterLayout struct {
	FilterLayout FilterLayout `protobuf:"varint,4,opt,name=filter_layout,json=filterLayout,proto3,enum=stream_executor.dnn.FilterLayout,oneof" json:"filter_layout,omitempty"`
}

func (*TensorDescriptorProto_DataLayout) isTensorDescriptorProto_LayoutOneof()   {}
func (*TensorDescriptorProto_FilterLayout) isTensorDescriptorProto_LayoutOneof() {}

func (m *TensorDescriptorProto) GetLayoutOneof() isTensorDescriptorProto_LayoutOneof {
	if m != nil {
		return m.LayoutOneof
	}
	return nil
}

func (m *TensorDescriptorProto) GetDimensions() []int64 {
	if m != nil {
		return m.Dimensions
	}
	return nil
}

func (m *TensorDescriptorProto) GetDataType() DataType {
	if m != nil {
		return m.DataType
	}
	return DataType_kFloat
}

func (m *TensorDescriptorProto) GetDataLayout() DataLayout {
	if x, ok := m.GetLayoutOneof().(*TensorDescriptorProto_DataLayout); ok {
		return x.DataLayout
	}
	return DataLayout_kYXDepthBatch
}

func (m *TensorDescriptorProto) GetFilterLayout() FilterLayout {
	if x, ok := m.GetLayoutOneof().(*TensorDescriptorProto_FilterLayout); ok {
		return x.FilterLayout
	}
	return FilterLayout_kOutputInputYX
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TensorDescriptorProto) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TensorDescriptorProto_DataLayout)(nil),
		(*TensorDescriptorProto_FilterLayout)(nil),
	}
}

// Generic algorithm representation.
type AlgorithmProto struct {
	AlgoId               int64                   `protobuf:"varint,1,opt,name=algo_id,json=algoId,proto3" json:"algo_id,omitempty"`
	MathType             AlgorithmProto_MathType `protobuf:"varint,2,opt,name=math_type,json=mathType,proto3,enum=stream_executor.dnn.AlgorithmProto_MathType" json:"math_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *AlgorithmProto) Reset()         { *m = AlgorithmProto{} }
func (m *AlgorithmProto) String() string { return proto.CompactTextString(m) }
func (*AlgorithmProto) ProtoMessage()    {}
func (*AlgorithmProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_768c61f2a579ee6a, []int{1}
}
func (m *AlgorithmProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlgorithmProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AlgorithmProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlgorithmProto.Merge(m, src)
}
func (m *AlgorithmProto) XXX_Size() int {
	return m.Size()
}
func (m *AlgorithmProto) XXX_DiscardUnknown() {
	xxx_messageInfo_AlgorithmProto.DiscardUnknown(m)
}

var xxx_messageInfo_AlgorithmProto proto.InternalMessageInfo

func (m *AlgorithmProto) GetAlgoId() int64 {
	if m != nil {
		return m.AlgoId
	}
	return 0
}

func (m *AlgorithmProto) GetMathType() AlgorithmProto_MathType {
	if m != nil {
		return m.MathType
	}
	return AlgorithmProto_DEFAULT_MATH
}

// Convolution-specific parameters.
type ConvolutionDescriptorProto struct {
	Paddings  []int64 `protobuf:"varint,1,rep,packed,name=paddings,proto3" json:"paddings,omitempty"`
	Strides   []int64 `protobuf:"varint,2,rep,packed,name=strides,proto3" json:"strides,omitempty"`
	Dilations []int64 `protobuf:"varint,3,rep,packed,name=dilations,proto3" json:"dilations,omitempty"`
	// The "accumulator" type. For example, use F32 as an accumulator for F16
	// convolutions.
	// See cuDNN's cudnnConvolutionMode_t.
	ComputeMode DataType `protobuf:"varint,4,opt,name=compute_mode,json=computeMode,proto3,enum=stream_executor.dnn.DataType" json:"compute_mode,omitempty"`
	// See cuDNN's group count.
	GroupCount      int32           `protobuf:"varint,5,opt,name=group_count,json=groupCount,proto3" json:"group_count,omitempty"`
	ConvolutionMode ConvolutionMode `protobuf:"varint,6,opt,name=convolution_mode,json=convolutionMode,proto3,enum=stream_executor.dnn.ConvolutionMode" json:"convolution_mode,omitempty"`
	// Tensorflow node name, same as in NodeDef, for debugging purposes.
	Name                 string   `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConvolutionDescriptorProto) Reset()         { *m = ConvolutionDescriptorProto{} }
func (m *ConvolutionDescriptorProto) String() string { return proto.CompactTextString(m) }
func (*ConvolutionDescriptorProto) ProtoMessage()    {}
func (*ConvolutionDescriptorProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_768c61f2a579ee6a, []int{2}
}
func (m *ConvolutionDescriptorProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvolutionDescriptorProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConvolutionDescriptorProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvolutionDescriptorProto.Merge(m, src)
}
func (m *ConvolutionDescriptorProto) XXX_Size() int {
	return m.Size()
}
func (m *ConvolutionDescriptorProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvolutionDescriptorProto.DiscardUnknown(m)
}

var xxx_messageInfo_ConvolutionDescriptorProto proto.InternalMessageInfo

func (m *ConvolutionDescriptorProto) GetPaddings() []int64 {
	if m != nil {
		return m.Paddings
	}
	return nil
}

func (m *ConvolutionDescriptorProto) GetStrides() []int64 {
	if m != nil {
		return m.Strides
	}
	return nil
}

func (m *ConvolutionDescriptorProto) GetDilations() []int64 {
	if m != nil {
		return m.Dilations
	}
	return nil
}

func (m *ConvolutionDescriptorProto) GetComputeMode() DataType {
	if m != nil {
		return m.ComputeMode
	}
	return DataType_kFloat
}

func (m *ConvolutionDescriptorProto) GetGroupCount() int32 {
	if m != nil {
		return m.GroupCount
	}
	return 0
}

func (m *ConvolutionDescriptorProto) GetConvolutionMode() ConvolutionMode {
	if m != nil {
		return m.ConvolutionMode
	}
	return ConvolutionMode_CROSS_CORRELATION
}

func (m *ConvolutionDescriptorProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterEnum("stream_executor.dnn.DataType", DataType_name, DataType_value)
	proto.RegisterEnum("stream_executor.dnn.DataLayout", DataLayout_name, DataLayout_value)
	proto.RegisterEnum("stream_executor.dnn.FilterLayout", FilterLayout_name, FilterLayout_value)
	proto.RegisterEnum("stream_executor.dnn.ActivationMode", ActivationMode_name, ActivationMode_value)
	proto.RegisterEnum("stream_executor.dnn.ConvolutionMode", ConvolutionMode_name, ConvolutionMode_value)
	proto.RegisterEnum("stream_executor.dnn.ConvolutionKind", ConvolutionKind_name, ConvolutionKind_value)
	proto.RegisterEnum("stream_executor.dnn.AlgorithmProto_MathType", AlgorithmProto_MathType_name, AlgorithmProto_MathType_value)
	proto.RegisterType((*TensorDescriptorProto)(nil), "stream_executor.dnn.TensorDescriptorProto")
	proto.RegisterType((*AlgorithmProto)(nil), "stream_executor.dnn.AlgorithmProto")
	proto.RegisterType((*ConvolutionDescriptorProto)(nil), "stream_executor.dnn.ConvolutionDescriptorProto")
}

func init() {
	proto.RegisterFile("tensorflow/stream_executor/dnn.proto", fileDescriptor_768c61f2a579ee6a)
}

var fileDescriptor_768c61f2a579ee6a = []byte{
	// 824 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0xdf, 0x6e, 0xe2, 0xc6,
	0x17, 0xc7, 0x31, 0xff, 0x02, 0x07, 0x42, 0x66, 0x67, 0xb5, 0x5a, 0xb4, 0xbf, 0x5f, 0x59, 0x1a,
	0xed, 0x05, 0x42, 0x15, 0xa9, 0x76, 0x57, 0x55, 0xdb, 0x8b, 0xaa, 0x06, 0x82, 0x62, 0x2d, 0xc1,
	0x91, 0xf1, 0xa6, 0xa4, 0x37, 0xd6, 0xc4, 0x33, 0x80, 0x85, 0x3d, 0x63, 0xd9, 0xe3, 0xed, 0xe6,
	0x31, 0xfa, 0x12, 0x7d, 0x86, 0x3e, 0x42, 0x2f, 0x7b, 0xd9, 0xcb, 0x2a, 0x4f, 0x52, 0x79, 0x6c,
	0x08, 0x89, 0xa8, 0x7a, 0x77, 0xce, 0x67, 0xce, 0x1f, 0xfb, 0xfb, 0x1d, 0x0d, 0xbc, 0x91, 0x8c,
	0xc7, 0x22, 0x5a, 0xfa, 0xe2, 0x97, 0xb3, 0x58, 0x46, 0x8c, 0x04, 0x0e, 0xfb, 0xcc, 0xdc, 0x44,
	0x8a, 0xe8, 0x8c, 0x72, 0x3e, 0x08, 0x23, 0x21, 0x05, 0x7e, 0xfe, 0xe4, 0x68, 0x40, 0x39, 0x3f,
	0xfd, 0xb5, 0x08, 0x2f, 0x6c, 0xd5, 0x3d, 0x66, 0xb1, 0x1b, 0x79, 0xa1, 0x14, 0xd1, 0x95, 0x2a,
	0xef, 0x00, 0x50, 0x2f, 0x60, 0x3c, 0xf6, 0x04, 0x8f, 0xdb, 0x5a, 0xb7, 0xd4, 0x2b, 0x59, 0x7b,
	0x04, 0x7f, 0x0f, 0x75, 0x4a, 0x24, 0x71, 0xe4, 0x5d, 0xc8, 0xda, 0xc5, 0xae, 0xd6, 0x6b, 0xbd,
	0xfd, 0x62, 0x70, 0x60, 0xc5, 0x60, 0x4c, 0x24, 0xb1, 0xef, 0x42, 0x66, 0xd5, 0x68, 0x1e, 0xe1,
	0x21, 0x34, 0x54, 0xaf, 0x4f, 0xee, 0x44, 0x22, 0xdb, 0x25, 0xd5, 0xfd, 0xfa, 0x5f, 0xbb, 0xa7,
	0xaa, 0xec, 0xa2, 0x60, 0x01, 0xdd, 0x65, 0xf8, 0x02, 0x8e, 0x97, 0x9e, 0x2f, 0x59, 0xb4, 0x9d,
	0x52, 0x56, 0x53, 0xbe, 0x3c, 0x38, 0x65, 0xa2, 0x2a, 0x77, 0x73, 0x9a, 0xcb, 0xbd, 0x7c, 0xd8,
	0x82, 0x66, 0x36, 0xc2, 0x11, 0x9c, 0x89, 0xe5, 0xe9, 0x6f, 0x1a, 0xb4, 0x74, 0x7f, 0x25, 0x22,
	0x4f, 0xae, 0x83, 0x4c, 0x8c, 0x97, 0x70, 0x44, 0xfc, 0x95, 0x70, 0x3c, 0xda, 0xd6, 0xba, 0x5a,
	0xaf, 0x64, 0x55, 0xd3, 0xd4, 0xa0, 0xd8, 0x80, 0x7a, 0x40, 0xe4, 0x7a, 0x5f, 0x85, 0xaf, 0x0e,
	0x7e, 0xc1, 0xe3, 0x81, 0x83, 0x4b, 0x22, 0xd7, 0x99, 0x28, 0x41, 0x1e, 0x9d, 0x7e, 0x0d, 0xb5,
	0x2d, 0xc5, 0x08, 0x9a, 0xe3, 0xf3, 0x89, 0xfe, 0x71, 0x6a, 0x3b, 0x97, 0xba, 0x7d, 0x81, 0x0a,
	0x18, 0x43, 0xcb, 0x3e, 0x9f, 0xcd, 0x4d, 0xcb, 0x31, 0xaf, 0x32, 0xa6, 0x9d, 0xfe, 0x5e, 0x84,
	0x57, 0x23, 0xc1, 0x3f, 0x09, 0x3f, 0x91, 0x9e, 0xe0, 0x4f, 0x1d, 0x7c, 0x05, 0xb5, 0x90, 0x50,
	0xea, 0xf1, 0xd5, 0xd6, 0xbf, 0x5d, 0x8e, 0xdb, 0x70, 0x14, 0xcb, 0xc8, 0xa3, 0x2c, 0x6e, 0x17,
	0xd5, 0xd1, 0x36, 0xc5, 0xff, 0x87, 0x3a, 0xf5, 0x7c, 0x22, 0x95, 0xed, 0x25, 0x75, 0xf6, 0x00,
	0xf0, 0x8f, 0xd0, 0x74, 0x45, 0x10, 0x26, 0x92, 0x39, 0x81, 0xa0, 0x2c, 0x17, 0xfd, 0x3f, 0x8c,
	0x6f, 0xe4, 0x2d, 0x97, 0x82, 0x32, 0xfc, 0x1a, 0x1a, 0xab, 0x48, 0x24, 0xa1, 0xe3, 0x8a, 0x84,
	0xcb, 0x76, 0xa5, 0xab, 0xf5, 0x2a, 0x16, 0x28, 0x34, 0x4a, 0x09, 0x36, 0x01, 0xb9, 0x0f, 0x3f,
	0x95, 0xad, 0xa9, 0xaa, 0x35, 0x6f, 0x0e, 0xae, 0xd9, 0x53, 0x20, 0x5d, 0x60, 0x9d, 0xb8, 0x8f,
	0x01, 0xc6, 0x50, 0xe6, 0x24, 0x60, 0xed, 0xa3, 0xae, 0xd6, 0xab, 0x5b, 0x2a, 0xee, 0xfb, 0x50,
	0xdb, 0x7e, 0x1e, 0x06, 0xa8, 0x6e, 0x26, 0xbe, 0x20, 0x12, 0x15, 0x70, 0x03, 0x8e, 0x36, 0x63,
	0x91, 0xdc, 0xfa, 0x0c, 0x69, 0xb8, 0x0e, 0x95, 0xcd, 0x05, 0xf1, 0x97, 0xa8, 0xa8, 0x42, 0x83,
	0xcb, 0x6f, 0x51, 0x49, 0x95, 0x1b, 0x5c, 0xbe, 0x7b, 0x8b, 0xca, 0xf8, 0x19, 0x1c, 0x6f, 0x46,
	0x22, 0x08, 0x7d, 0xf6, 0x39, 0x9b, 0x50, 0x49, 0x8d, 0xda, 0xa2, 0x7c, 0x50, 0xb5, 0xef, 0x03,
	0x3c, 0xdc, 0x63, 0xd5, 0x74, 0xb3, 0x18, 0xb3, 0x50, 0xae, 0x87, 0x44, 0xba, 0x6b, 0x54, 0xc8,
	0x91, 0xca, 0x14, 0x47, 0x9a, 0x42, 0x0a, 0xe4, 0xa5, 0xa8, 0xf8, 0x80, 0x14, 0xb8, 0x59, 0xa0,
	0x92, 0xda, 0xb6, 0x8f, 0xde, 0xa3, 0x72, 0x3f, 0x86, 0xe6, 0xfe, 0x7d, 0x57, 0x35, 0x66, 0x22,
	0xc3, 0x44, 0x1a, 0x3c, 0x4c, 0xe4, 0xcd, 0x22, 0xbb, 0x4e, 0x39, 0xbb, 0x59, 0x28, 0x8a, 0x34,
	0xfc, 0x1c, 0x4e, 0x1e, 0xd7, 0xbd, 0x47, 0x45, 0x55, 0x98, 0xa7, 0xd9, 0x59, 0xbe, 0x34, 0x6f,
	0xcb, 0x59, 0xb9, 0xbf, 0x84, 0x96, 0xee, 0x4a, 0xef, 0x13, 0xd9, 0xc9, 0x9e, 0x4a, 0x36, 0x13,
	0x9c, 0xa1, 0x02, 0x6e, 0x42, 0x6d, 0x33, 0xf7, 0x56, 0x81, 0xf0, 0x68, 0x2e, 0xab, 0xc5, 0xfc,
	0x04, 0x15, 0x95, 0x96, 0x69, 0xf8, 0x4d, 0xae, 0x6b, 0x1a, 0x2f, 0x50, 0x59, 0x95, 0xd8, 0x84,
	0xaf, 0x51, 0x05, 0x1f, 0x43, 0x7d, 0x33, 0x24, 0x9c, 0x5e, 0x91, 0x38, 0x46, 0xd5, 0xfe, 0x77,
	0x70, 0xf2, 0xc4, 0x70, 0xfc, 0x02, 0x9e, 0x8d, 0x2c, 0x73, 0x3e, 0x77, 0x46, 0xa6, 0x65, 0x9d,
	0x4f, 0x75, 0xdb, 0x30, 0x67, 0xa8, 0x80, 0x4f, 0xa0, 0x31, 0x32, 0x67, 0xd7, 0xe6, 0xf4, 0xa3,
	0x02, 0x5a, 0x3f, 0x7c, 0xd4, 0xfa, 0xc1, 0xe3, 0x34, 0xb5, 0xdb, 0x98, 0x5d, 0xeb, 0x53, 0x63,
	0x9c, 0x79, 0x3f, 0x31, 0xad, 0x9f, 0x74, 0x6b, 0x9c, 0x89, 0x31, 0xd4, 0x47, 0x1f, 0xd2, 0xcc,
	0x99, 0x18, 0x53, 0xfb, 0xdc, 0xca, 0x0c, 0xd8, 0xc1, 0xb1, 0x6e, 0xeb, 0xa8, 0x84, 0xff, 0x07,
	0x2f, 0xf3, 0x26, 0x67, 0x68, 0xe8, 0x73, 0x47, 0x1f, 0xd9, 0xc6, 0x75, 0xf6, 0x09, 0xe5, 0xe1,
	0xd5, 0x1f, 0xf7, 0x1d, 0xed, 0xcf, 0xfb, 0x8e, 0xf6, 0xd7, 0x7d, 0x47, 0xfb, 0xfb, 0xbe, 0xa3,
	0xfd, 0xfc, 0xc3, 0xca, 0x93, 0xeb, 0xe4, 0x76, 0xe0, 0x8a, 0xe0, 0x6c, 0xef, 0xd5, 0x3e, 0x1c,
	0xae, 0xc4, 0xd3, 0xe7, 0xfc, 0xb6, 0xaa, 0xde, 0xf2, 0x77, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff,
	0x61, 0xc9, 0x65, 0x31, 0xf3, 0x05, 0x00, 0x00,
}

func (m *TensorDescriptorProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorDescriptorProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorDescriptorProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LayoutOneof != nil {
		{
			size := m.LayoutOneof.Size()
			i -= size
			if _, err := m.LayoutOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DataType != 0 {
		i = encodeVarintDnn(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Dimensions) > 0 {
		dAtA2 := make([]byte, len(m.Dimensions)*10)
		var j1 int
		for _, num1 := range m.Dimensions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintDnn(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TensorDescriptorProto_DataLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorDescriptorProto_DataLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDnn(dAtA, i, uint64(m.DataLayout))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *TensorDescriptorProto_FilterLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorDescriptorProto_FilterLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDnn(dAtA, i, uint64(m.FilterLayout))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *AlgorithmProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlgorithmProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlgorithmProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MathType != 0 {
		i = encodeVarintDnn(dAtA, i, uint64(m.MathType))
		i--
		dAtA[i] = 0x10
	}
	if m.AlgoId != 0 {
		i = encodeVarintDnn(dAtA, i, uint64(m.AlgoId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConvolutionDescriptorProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvolutionDescriptorProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvolutionDescriptorProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDnn(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ConvolutionMode != 0 {
		i = encodeVarintDnn(dAtA, i, uint64(m.ConvolutionMode))
		i--
		dAtA[i] = 0x30
	}
	if m.GroupCount != 0 {
		i = encodeVarintDnn(dAtA, i, uint64(m.GroupCount))
		i--
		dAtA[i] = 0x28
	}
	if m.ComputeMode != 0 {
		i = encodeVarintDnn(dAtA, i, uint64(m.ComputeMode))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Dilations) > 0 {
		dAtA4 := make([]byte, len(m.Dilations)*10)
		var j3 int
		for _, num1 := range m.Dilations {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintDnn(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Strides) > 0 {
		dAtA6 := make([]byte, len(m.Strides)*10)
		var j5 int
		for _, num1 := range m.Strides {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintDnn(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Paddings) > 0 {
		dAtA8 := make([]byte, len(m.Paddings)*10)
		var j7 int
		for _, num1 := range m.Paddings {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintDnn(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDnn(dAtA []byte, offset int, v uint64) int {
	offset -= sovDnn(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TensorDescriptorProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dimensions) > 0 {
		l = 0
		for _, e := range m.Dimensions {
			l += sovDnn(uint64(e))
		}
		n += 1 + sovDnn(uint64(l)) + l
	}
	if m.DataType != 0 {
		n += 1 + sovDnn(uint64(m.DataType))
	}
	if m.LayoutOneof != nil {
		n += m.LayoutOneof.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TensorDescriptorProto_DataLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDnn(uint64(m.DataLayout))
	return n
}
func (m *TensorDescriptorProto_FilterLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDnn(uint64(m.FilterLayout))
	return n
}
func (m *AlgorithmProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlgoId != 0 {
		n += 1 + sovDnn(uint64(m.AlgoId))
	}
	if m.MathType != 0 {
		n += 1 + sovDnn(uint64(m.MathType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConvolutionDescriptorProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Paddings) > 0 {
		l = 0
		for _, e := range m.Paddings {
			l += sovDnn(uint64(e))
		}
		n += 1 + sovDnn(uint64(l)) + l
	}
	if len(m.Strides) > 0 {
		l = 0
		for _, e := range m.Strides {
			l += sovDnn(uint64(e))
		}
		n += 1 + sovDnn(uint64(l)) + l
	}
	if len(m.Dilations) > 0 {
		l = 0
		for _, e := range m.Dilations {
			l += sovDnn(uint64(e))
		}
		n += 1 + sovDnn(uint64(l)) + l
	}
	if m.ComputeMode != 0 {
		n += 1 + sovDnn(uint64(m.ComputeMode))
	}
	if m.GroupCount != 0 {
		n += 1 + sovDnn(uint64(m.GroupCount))
	}
	if m.ConvolutionMode != 0 {
		n += 1 + sovDnn(uint64(m.ConvolutionMode))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDnn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDnn(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDnn(x uint64) (n int) {
	return sovDnn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TensorDescriptorProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDnn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dimensions = append(m.Dimensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDnn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDnn
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDnn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dimensions) == 0 {
					m.Dimensions = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDnn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dimensions = append(m.Dimensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLayout", wireType)
			}
			var v DataLayout
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= DataLayout(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LayoutOneof = &TensorDescriptorProto_DataLayout{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterLayout", wireType)
			}
			var v FilterLayout
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FilterLayout(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LayoutOneof = &TensorDescriptorProto_FilterLayout{v}
		default:
			iNdEx = preIndex
			skippy, err := skipDnn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDnn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlgorithmProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlgorithmProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlgorithmProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgoId", wireType)
			}
			m.AlgoId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgoId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MathType", wireType)
			}
			m.MathType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MathType |= AlgorithmProto_MathType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDnn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDnn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvolutionDescriptorProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvolutionDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvolutionDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDnn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Paddings = append(m.Paddings, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDnn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDnn
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDnn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Paddings) == 0 {
					m.Paddings = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDnn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Paddings = append(m.Paddings, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Paddings", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDnn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Strides = append(m.Strides, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDnn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDnn
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDnn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Strides) == 0 {
					m.Strides = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDnn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Strides = append(m.Strides, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Strides", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDnn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dilations = append(m.Dilations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDnn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDnn
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDnn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dilations) == 0 {
					m.Dilations = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDnn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dilations = append(m.Dilations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dilations", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeMode", wireType)
			}
			m.ComputeMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputeMode |= DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCount", wireType)
			}
			m.GroupCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvolutionMode", wireType)
			}
			m.ConvolutionMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConvolutionMode |= ConvolutionMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDnn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDnn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDnn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDnn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDnn
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDnn
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDnn
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDnn        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDnn          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDnn = fmt.Errorf("proto: unexpected end of group")
)
