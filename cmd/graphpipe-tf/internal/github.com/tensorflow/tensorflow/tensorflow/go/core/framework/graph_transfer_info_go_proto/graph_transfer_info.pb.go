// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/framework/graph_transfer_info.proto

package graph_transfer_info_go_proto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/types_go_proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GraphTransferInfo_Destination int32

const (
	GraphTransferInfo_NOP     GraphTransferInfo_Destination = 0
	GraphTransferInfo_HEXAGON GraphTransferInfo_Destination = 1
)

var GraphTransferInfo_Destination_name = map[int32]string{
	0: "NOP",
	1: "HEXAGON",
}

var GraphTransferInfo_Destination_value = map[string]int32{
	"NOP":     0,
	"HEXAGON": 1,
}

func (x GraphTransferInfo_Destination) String() string {
	return proto.EnumName(GraphTransferInfo_Destination_name, int32(x))
}

func (GraphTransferInfo_Destination) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{7, 0}
}

type GraphTransferNodeInput struct {
	NodeId               int32    `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	OutputPort           int32    `protobuf:"varint,2,opt,name=output_port,json=outputPort,proto3" json:"output_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GraphTransferNodeInput) Reset()         { *m = GraphTransferNodeInput{} }
func (m *GraphTransferNodeInput) String() string { return proto.CompactTextString(m) }
func (*GraphTransferNodeInput) ProtoMessage()    {}
func (*GraphTransferNodeInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{0}
}
func (m *GraphTransferNodeInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferNodeInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GraphTransferNodeInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferNodeInput.Merge(m, src)
}
func (m *GraphTransferNodeInput) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferNodeInput) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferNodeInput.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferNodeInput proto.InternalMessageInfo

func (m *GraphTransferNodeInput) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *GraphTransferNodeInput) GetOutputPort() int32 {
	if m != nil {
		return m.OutputPort
	}
	return 0
}

type GraphTransferNodeInfo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	NodeId               int32    `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	TypeName             string   `protobuf:"bytes,3,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
	SocOpId              int32    `protobuf:"varint,4,opt,name=soc_op_id,json=socOpId,proto3" json:"soc_op_id,omitempty"`
	PaddingId            int32    `protobuf:"varint,5,opt,name=padding_id,json=paddingId,proto3" json:"padding_id,omitempty"`
	InputCount           int32    `protobuf:"varint,6,opt,name=input_count,json=inputCount,proto3" json:"input_count,omitempty"`
	OutputCount          int32    `protobuf:"varint,7,opt,name=output_count,json=outputCount,proto3" json:"output_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GraphTransferNodeInfo) Reset()         { *m = GraphTransferNodeInfo{} }
func (m *GraphTransferNodeInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferNodeInfo) ProtoMessage()    {}
func (*GraphTransferNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{1}
}
func (m *GraphTransferNodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GraphTransferNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferNodeInfo.Merge(m, src)
}
func (m *GraphTransferNodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferNodeInfo proto.InternalMessageInfo

func (m *GraphTransferNodeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphTransferNodeInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *GraphTransferNodeInfo) GetTypeName() string {
	if m != nil {
		return m.TypeName
	}
	return ""
}

func (m *GraphTransferNodeInfo) GetSocOpId() int32 {
	if m != nil {
		return m.SocOpId
	}
	return 0
}

func (m *GraphTransferNodeInfo) GetPaddingId() int32 {
	if m != nil {
		return m.PaddingId
	}
	return 0
}

func (m *GraphTransferNodeInfo) GetInputCount() int32 {
	if m != nil {
		return m.InputCount
	}
	return 0
}

func (m *GraphTransferNodeInfo) GetOutputCount() int32 {
	if m != nil {
		return m.OutputCount
	}
	return 0
}

type GraphTransferConstNodeInfo struct {
	Name                 string                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	NodeId               int32                   `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Shape                []int64                 `protobuf:"varint,3,rep,packed,name=shape,proto3" json:"shape,omitempty"`
	Data                 []byte                  `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	Dtype                types_go_proto.DataType `protobuf:"varint,5,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *GraphTransferConstNodeInfo) Reset()         { *m = GraphTransferConstNodeInfo{} }
func (m *GraphTransferConstNodeInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferConstNodeInfo) ProtoMessage()    {}
func (*GraphTransferConstNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{2}
}
func (m *GraphTransferConstNodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferConstNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GraphTransferConstNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferConstNodeInfo.Merge(m, src)
}
func (m *GraphTransferConstNodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferConstNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferConstNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferConstNodeInfo proto.InternalMessageInfo

func (m *GraphTransferConstNodeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphTransferConstNodeInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *GraphTransferConstNodeInfo) GetShape() []int64 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *GraphTransferConstNodeInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GraphTransferConstNodeInfo) GetDtype() types_go_proto.DataType {
	if m != nil {
		return m.Dtype
	}
	return types_go_proto.DataType_DT_INVALID
}

type GraphTransferNodeInputInfo struct {
	NodeId               int32                     `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeInput            []*GraphTransferNodeInput `protobuf:"bytes,2,rep,name=node_input,json=nodeInput,proto3" json:"node_input,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *GraphTransferNodeInputInfo) Reset()         { *m = GraphTransferNodeInputInfo{} }
func (m *GraphTransferNodeInputInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferNodeInputInfo) ProtoMessage()    {}
func (*GraphTransferNodeInputInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{3}
}
func (m *GraphTransferNodeInputInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferNodeInputInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GraphTransferNodeInputInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferNodeInputInfo.Merge(m, src)
}
func (m *GraphTransferNodeInputInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferNodeInputInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferNodeInputInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferNodeInputInfo proto.InternalMessageInfo

func (m *GraphTransferNodeInputInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *GraphTransferNodeInputInfo) GetNodeInput() []*GraphTransferNodeInput {
	if m != nil {
		return m.NodeInput
	}
	return nil
}

type GraphTransferNodeOutputInfo struct {
	NodeId               int32    `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	MaxByteSize          []int32  `protobuf:"varint,2,rep,packed,name=max_byte_size,json=maxByteSize,proto3" json:"max_byte_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GraphTransferNodeOutputInfo) Reset()         { *m = GraphTransferNodeOutputInfo{} }
func (m *GraphTransferNodeOutputInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferNodeOutputInfo) ProtoMessage()    {}
func (*GraphTransferNodeOutputInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{4}
}
func (m *GraphTransferNodeOutputInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferNodeOutputInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GraphTransferNodeOutputInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferNodeOutputInfo.Merge(m, src)
}
func (m *GraphTransferNodeOutputInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferNodeOutputInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferNodeOutputInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferNodeOutputInfo proto.InternalMessageInfo

func (m *GraphTransferNodeOutputInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *GraphTransferNodeOutputInfo) GetMaxByteSize() []int32 {
	if m != nil {
		return m.MaxByteSize
	}
	return nil
}

type GraphTransferGraphInputNodeInfo struct {
	Name                 string                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Shape                []int64                 `protobuf:"varint,2,rep,packed,name=shape,proto3" json:"shape,omitempty"`
	Dtype                types_go_proto.DataType `protobuf:"varint,3,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *GraphTransferGraphInputNodeInfo) Reset()         { *m = GraphTransferGraphInputNodeInfo{} }
func (m *GraphTransferGraphInputNodeInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferGraphInputNodeInfo) ProtoMessage()    {}
func (*GraphTransferGraphInputNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{5}
}
func (m *GraphTransferGraphInputNodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferGraphInputNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GraphTransferGraphInputNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferGraphInputNodeInfo.Merge(m, src)
}
func (m *GraphTransferGraphInputNodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferGraphInputNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferGraphInputNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferGraphInputNodeInfo proto.InternalMessageInfo

func (m *GraphTransferGraphInputNodeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphTransferGraphInputNodeInfo) GetShape() []int64 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *GraphTransferGraphInputNodeInfo) GetDtype() types_go_proto.DataType {
	if m != nil {
		return m.Dtype
	}
	return types_go_proto.DataType_DT_INVALID
}

type GraphTransferGraphOutputNodeInfo struct {
	Name                 string                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Shape                []int64                 `protobuf:"varint,2,rep,packed,name=shape,proto3" json:"shape,omitempty"`
	Dtype                types_go_proto.DataType `protobuf:"varint,3,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *GraphTransferGraphOutputNodeInfo) Reset()         { *m = GraphTransferGraphOutputNodeInfo{} }
func (m *GraphTransferGraphOutputNodeInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferGraphOutputNodeInfo) ProtoMessage()    {}
func (*GraphTransferGraphOutputNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{6}
}
func (m *GraphTransferGraphOutputNodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferGraphOutputNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GraphTransferGraphOutputNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferGraphOutputNodeInfo.Merge(m, src)
}
func (m *GraphTransferGraphOutputNodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferGraphOutputNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferGraphOutputNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferGraphOutputNodeInfo proto.InternalMessageInfo

func (m *GraphTransferGraphOutputNodeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphTransferGraphOutputNodeInfo) GetShape() []int64 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *GraphTransferGraphOutputNodeInfo) GetDtype() types_go_proto.DataType {
	if m != nil {
		return m.Dtype
	}
	return types_go_proto.DataType_DT_INVALID
}

// Protocol buffer representing a handle to a tensorflow resource. Handles are
// not valid across executions, but can be serialized back and forth from within
// a single run.
type GraphTransferInfo struct {
	NodeInfo       []*GraphTransferNodeInfo       `protobuf:"bytes,1,rep,name=node_info,json=nodeInfo,proto3" json:"node_info,omitempty"`
	ConstNodeInfo  []*GraphTransferConstNodeInfo  `protobuf:"bytes,2,rep,name=const_node_info,json=constNodeInfo,proto3" json:"const_node_info,omitempty"`
	NodeInputInfo  []*GraphTransferNodeInputInfo  `protobuf:"bytes,3,rep,name=node_input_info,json=nodeInputInfo,proto3" json:"node_input_info,omitempty"`
	NodeOutputInfo []*GraphTransferNodeOutputInfo `protobuf:"bytes,4,rep,name=node_output_info,json=nodeOutputInfo,proto3" json:"node_output_info,omitempty"`
	// Input Node parameters of transferred graph
	GraphInputNodeInfo  []*GraphTransferGraphInputNodeInfo  `protobuf:"bytes,5,rep,name=graph_input_node_info,json=graphInputNodeInfo,proto3" json:"graph_input_node_info,omitempty"`
	GraphOutputNodeInfo []*GraphTransferGraphOutputNodeInfo `protobuf:"bytes,6,rep,name=graph_output_node_info,json=graphOutputNodeInfo,proto3" json:"graph_output_node_info,omitempty"`
	// Destination of graph transfer
	Destination          GraphTransferInfo_Destination `protobuf:"varint,7,opt,name=destination,proto3,enum=tensorflow.GraphTransferInfo_Destination" json:"destination,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *GraphTransferInfo) Reset()         { *m = GraphTransferInfo{} }
func (m *GraphTransferInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferInfo) ProtoMessage()    {}
func (*GraphTransferInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{7}
}
func (m *GraphTransferInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GraphTransferInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferInfo.Merge(m, src)
}
func (m *GraphTransferInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferInfo proto.InternalMessageInfo

func (m *GraphTransferInfo) GetNodeInfo() []*GraphTransferNodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetConstNodeInfo() []*GraphTransferConstNodeInfo {
	if m != nil {
		return m.ConstNodeInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetNodeInputInfo() []*GraphTransferNodeInputInfo {
	if m != nil {
		return m.NodeInputInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetNodeOutputInfo() []*GraphTransferNodeOutputInfo {
	if m != nil {
		return m.NodeOutputInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetGraphInputNodeInfo() []*GraphTransferGraphInputNodeInfo {
	if m != nil {
		return m.GraphInputNodeInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetGraphOutputNodeInfo() []*GraphTransferGraphOutputNodeInfo {
	if m != nil {
		return m.GraphOutputNodeInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetDestination() GraphTransferInfo_Destination {
	if m != nil {
		return m.Destination
	}
	return GraphTransferInfo_NOP
}

func init() {
	proto.RegisterEnum("tensorflow.GraphTransferInfo_Destination", GraphTransferInfo_Destination_name, GraphTransferInfo_Destination_value)
	proto.RegisterType((*GraphTransferNodeInput)(nil), "tensorflow.GraphTransferNodeInput")
	proto.RegisterType((*GraphTransferNodeInfo)(nil), "tensorflow.GraphTransferNodeInfo")
	proto.RegisterType((*GraphTransferConstNodeInfo)(nil), "tensorflow.GraphTransferConstNodeInfo")
	proto.RegisterType((*GraphTransferNodeInputInfo)(nil), "tensorflow.GraphTransferNodeInputInfo")
	proto.RegisterType((*GraphTransferNodeOutputInfo)(nil), "tensorflow.GraphTransferNodeOutputInfo")
	proto.RegisterType((*GraphTransferGraphInputNodeInfo)(nil), "tensorflow.GraphTransferGraphInputNodeInfo")
	proto.RegisterType((*GraphTransferGraphOutputNodeInfo)(nil), "tensorflow.GraphTransferGraphOutputNodeInfo")
	proto.RegisterType((*GraphTransferInfo)(nil), "tensorflow.GraphTransferInfo")
}

func init() {
	proto.RegisterFile("tensorflow/core/framework/graph_transfer_info.proto", fileDescriptor_c3a1e773f26c9475)
}

var fileDescriptor_c3a1e773f26c9475 = []byte{
	// 697 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0x4b, 0x6f, 0xd3, 0x4a,
	0x14, 0xbe, 0x93, 0x67, 0x73, 0xd2, 0xd7, 0xf5, 0x6d, 0x7b, 0xa3, 0x56, 0xa4, 0xad, 0x11, 0x50,
	0x1e, 0x4a, 0xa4, 0x76, 0x8f, 0xd4, 0x07, 0x2a, 0x15, 0x52, 0x12, 0x86, 0x2e, 0x50, 0x17, 0x58,
	0xd3, 0x78, 0xe2, 0x5a, 0x90, 0x19, 0xcb, 0x9e, 0xa8, 0x4d, 0xff, 0x0c, 0x0b, 0xfe, 0x0c, 0x4b,
	0x96, 0x2c, 0xab, 0xfc, 0x0a, 0x24, 0x36, 0x68, 0xce, 0xa4, 0xb1, 0x4d, 0x1e, 0xad, 0x90, 0xd8,
	0xcd, 0xe3, 0x9c, 0xef, 0x3b, 0xdf, 0x39, 0x9f, 0x3d, 0xb0, 0xa7, 0xb8, 0x88, 0x64, 0xd8, 0xf9,
	0x24, 0x2f, 0xeb, 0x6d, 0x19, 0xf2, 0x7a, 0x27, 0x64, 0x5d, 0x7e, 0x29, 0xc3, 0x8f, 0x75, 0x2f,
	0x64, 0xc1, 0x85, 0xa3, 0x42, 0x26, 0xa2, 0x0e, 0x0f, 0x1d, 0x5f, 0x74, 0x64, 0x2d, 0x08, 0xa5,
	0x92, 0x16, 0xc4, 0x49, 0xeb, 0x8f, 0xa6, 0x03, 0xa8, 0x7e, 0xc0, 0x23, 0x93, 0x62, 0x53, 0x58,
	0x3b, 0xd6, 0x78, 0xa7, 0x43, 0xb8, 0x86, 0x74, 0xf9, 0x89, 0x08, 0x7a, 0xca, 0xfa, 0x1f, 0x8a,
	0x42, 0xba, 0xdc, 0xf1, 0xdd, 0x0a, 0xd9, 0x22, 0x3b, 0x79, 0x5a, 0xd0, 0xdb, 0x13, 0xd7, 0xda,
	0x84, 0xb2, 0xec, 0xa9, 0xa0, 0xa7, 0x9c, 0x40, 0x86, 0xaa, 0x92, 0xc1, 0x4b, 0x30, 0x47, 0x2d,
	0x19, 0x2a, 0xfb, 0x86, 0xc0, 0xea, 0x04, 0xd0, 0x8e, 0xb4, 0x2c, 0xc8, 0x09, 0xd6, 0xe5, 0x08,
	0x58, 0xa2, 0xb8, 0x4e, 0xf2, 0x64, 0x52, 0x3c, 0x1b, 0x50, 0xd2, 0x95, 0x3a, 0x98, 0x91, 0xc5,
	0x8c, 0x39, 0x7d, 0xd0, 0xd0, 0x59, 0xeb, 0x50, 0x8a, 0x64, 0xdb, 0x91, 0x81, 0xce, 0xcb, 0x61,
	0x5e, 0x31, 0x92, 0xed, 0x66, 0x70, 0xe2, 0x5a, 0x0f, 0x00, 0x02, 0xe6, 0xba, 0xbe, 0xf0, 0xf4,
	0x65, 0x1e, 0x2f, 0x4b, 0xc3, 0x13, 0x53, 0xbf, 0xaf, 0x15, 0x3a, 0x6d, 0xd9, 0x13, 0xaa, 0x52,
	0x30, 0xf5, 0xe3, 0xd1, 0xa1, 0x3e, 0xb1, 0xb6, 0x61, 0x7e, 0x28, 0xd0, 0x44, 0x14, 0x31, 0x62,
	0x28, 0x1a, 0x43, 0xec, 0xcf, 0x04, 0xd6, 0x53, 0x12, 0x0f, 0xa5, 0x88, 0xd4, 0x9f, 0xe9, 0x5c,
	0x81, 0x7c, 0x74, 0xc1, 0x02, 0xad, 0x31, 0xbb, 0x93, 0xa5, 0x66, 0xa3, 0x21, 0x5c, 0xa6, 0x18,
	0x6a, 0x9b, 0xa7, 0xb8, 0xb6, 0x9e, 0x41, 0xde, 0xd5, 0x1d, 0x40, 0x4d, 0x8b, 0xbb, 0x2b, 0xb5,
	0x78, 0xc6, 0xb5, 0x23, 0xa6, 0xd8, 0x69, 0x3f, 0xe0, 0xd4, 0x84, 0xd8, 0x57, 0xbf, 0x15, 0x38,
	0x1a, 0x2c, 0x16, 0x38, 0x75, 0xb8, 0xfb, 0x00, 0xe6, 0x42, 0x87, 0x56, 0x32, 0x5b, 0xd9, 0x9d,
	0xf2, 0xae, 0x9d, 0xe4, 0x99, 0x0c, 0x4a, 0x4b, 0xe2, 0x76, 0x69, 0x9f, 0xc1, 0xc6, 0x58, 0x50,
	0x13, 0x7b, 0x37, 0x9b, 0xda, 0x86, 0x85, 0x2e, 0xbb, 0x72, 0xce, 0xfb, 0x8a, 0x3b, 0x91, 0x7f,
	0xcd, 0x91, 0x3d, 0x4f, 0xcb, 0x5d, 0x76, 0x75, 0xd0, 0x57, 0xfc, 0x9d, 0x7f, 0xcd, 0xed, 0x4b,
	0xd8, 0x4c, 0x61, 0xe3, 0x06, 0x69, 0x67, 0xf6, 0x7e, 0xd4, 0xe2, 0x4c, 0xb2, 0xc5, 0xa3, 0x76,
	0x66, 0xef, 0xd3, 0xce, 0xad, 0x71, 0x62, 0xa3, 0xea, 0x2f, 0x33, 0xff, 0xcc, 0xc1, 0xbf, 0x29,
	0x6a, 0xe4, 0x7a, 0x09, 0xa5, 0xe1, 0x9c, 0x3a, 0xb2, 0x42, 0x70, 0x4c, 0xdb, 0x77, 0x8c, 0xa9,
	0x23, 0xe9, 0x9c, 0xb8, 0xad, 0xb5, 0x01, 0x4b, 0x6d, 0x6d, 0x59, 0x27, 0x46, 0x31, 0xc3, 0x7e,
	0x3c, 0x15, 0x25, 0x65, 0x71, 0xba, 0xd0, 0x4e, 0x39, 0xbe, 0x01, 0x4b, 0xb1, 0x6f, 0x0c, 0x5e,
	0xf6, 0x0e, 0xbc, 0x94, 0x23, 0xe9, 0x82, 0x48, 0x19, 0xf4, 0x2d, 0x2c, 0x23, 0xde, 0xf0, 0x43,
	0x44, 0xc0, 0x1c, 0x02, 0x3e, 0x99, 0x09, 0x18, 0x1b, 0x8d, 0x2e, 0x8a, 0xb4, 0xf1, 0x3e, 0xc0,
	0xaa, 0xf9, 0x75, 0x9a, 0x1a, 0x63, 0xe1, 0x79, 0xc4, 0x7d, 0x3e, 0x15, 0x77, 0xdc, 0x64, 0xd4,
	0xf2, 0xc6, 0x8d, 0xc7, 0x60, 0xcd, 0xe0, 0x0f, 0x6b, 0x8e, 0x09, 0x0a, 0x48, 0xf0, 0x62, 0x36,
	0x41, 0xda, 0x4c, 0xf4, 0x3f, 0x6f, 0x82, 0xc3, 0xde, 0x40, 0xd9, 0xe5, 0x91, 0xf2, 0x05, 0x53,
	0xbe, 0x14, 0xf8, 0x63, 0x5a, 0xdc, 0x7d, 0x3a, 0x15, 0x57, 0xe7, 0xd4, 0x8e, 0xe2, 0x04, 0x9a,
	0xcc, 0xb6, 0x1f, 0x42, 0x39, 0x71, 0x67, 0x15, 0x21, 0xdb, 0x68, 0xb6, 0x96, 0xff, 0xb1, 0xca,
	0x50, 0x7c, 0xfd, 0xea, 0xfd, 0xfe, 0x71, 0xb3, 0xb1, 0x4c, 0x0e, 0xbe, 0x90, 0xaf, 0x83, 0x2a,
	0xf9, 0x36, 0xa8, 0x92, 0xef, 0x83, 0x2a, 0xb9, 0x19, 0x54, 0x09, 0x54, 0x64, 0xe8, 0x25, 0x29,
	0x47, 0x0f, 0xcb, 0xc1, 0xda, 0x18, 0x7b, 0x4b, 0x3f, 0x32, 0x2d, 0x72, 0x76, 0xe6, 0xf9, 0xea,
	0xa2, 0x77, 0x5e, 0x6b, 0xcb, 0x6e, 0x3d, 0xf1, 0x30, 0x4d, 0x5e, 0x7a, 0xf2, 0x1e, 0x4f, 0x9e,
	0xe3, 0x49, 0x07, 0x9f, 0xb0, 0x1f, 0x84, 0x9c, 0x17, 0x70, 0xb5, 0xf7, 0x2b, 0x00, 0x00, 0xff,
	0xff, 0xe8, 0x92, 0xea, 0x27, 0x36, 0x07, 0x00, 0x00,
}

func (m *GraphTransferNodeInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferNodeInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferNodeInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OutputPort != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.OutputPort))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferNodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferNodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferNodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OutputCount != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.OutputCount))
		i--
		dAtA[i] = 0x38
	}
	if m.InputCount != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.InputCount))
		i--
		dAtA[i] = 0x30
	}
	if m.PaddingId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.PaddingId))
		i--
		dAtA[i] = 0x28
	}
	if m.SocOpId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.SocOpId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TypeName) > 0 {
		i -= len(m.TypeName)
		copy(dAtA[i:], m.TypeName)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.TypeName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferConstNodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferConstNodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferConstNodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dtype != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.Dtype))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Shape) > 0 {
		dAtA2 := make([]byte, len(m.Shape)*10)
		var j1 int
		for _, num1 := range m.Shape {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferNodeInputInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferNodeInputInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferNodeInputInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeInput) > 0 {
		for iNdEx := len(m.NodeInput) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeInput[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NodeId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferNodeOutputInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferNodeOutputInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferNodeOutputInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MaxByteSize) > 0 {
		dAtA4 := make([]byte, len(m.MaxByteSize)*10)
		var j3 int
		for _, num1 := range m.MaxByteSize {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.NodeId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferGraphInputNodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferGraphInputNodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferGraphInputNodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dtype != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.Dtype))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Shape) > 0 {
		dAtA6 := make([]byte, len(m.Shape)*10)
		var j5 int
		for _, num1 := range m.Shape {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferGraphOutputNodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferGraphOutputNodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferGraphOutputNodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dtype != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.Dtype))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Shape) > 0 {
		dAtA8 := make([]byte, len(m.Shape)*10)
		var j7 int
		for _, num1 := range m.Shape {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Destination != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.Destination))
		i--
		dAtA[i] = 0x38
	}
	if len(m.GraphOutputNodeInfo) > 0 {
		for iNdEx := len(m.GraphOutputNodeInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GraphOutputNodeInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.GraphInputNodeInfo) > 0 {
		for iNdEx := len(m.GraphInputNodeInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GraphInputNodeInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NodeOutputInfo) > 0 {
		for iNdEx := len(m.NodeOutputInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeOutputInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.NodeInputInfo) > 0 {
		for iNdEx := len(m.NodeInputInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeInputInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ConstNodeInfo) > 0 {
		for iNdEx := len(m.ConstNodeInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConstNodeInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NodeInfo) > 0 {
		for iNdEx := len(m.NodeInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintGraphTransferInfo(dAtA []byte, offset int, v uint64) int {
	offset -= sovGraphTransferInfo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GraphTransferNodeInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.NodeId))
	}
	if m.OutputPort != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.OutputPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GraphTransferNodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if m.NodeId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.NodeId))
	}
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if m.SocOpId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.SocOpId))
	}
	if m.PaddingId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.PaddingId))
	}
	if m.InputCount != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.InputCount))
	}
	if m.OutputCount != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.OutputCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GraphTransferConstNodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if m.NodeId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.NodeId))
	}
	if len(m.Shape) > 0 {
		l = 0
		for _, e := range m.Shape {
			l += sovGraphTransferInfo(uint64(e))
		}
		n += 1 + sovGraphTransferInfo(uint64(l)) + l
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if m.Dtype != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.Dtype))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GraphTransferNodeInputInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.NodeId))
	}
	if len(m.NodeInput) > 0 {
		for _, e := range m.NodeInput {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GraphTransferNodeOutputInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.NodeId))
	}
	if len(m.MaxByteSize) > 0 {
		l = 0
		for _, e := range m.MaxByteSize {
			l += sovGraphTransferInfo(uint64(e))
		}
		n += 1 + sovGraphTransferInfo(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GraphTransferGraphInputNodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if len(m.Shape) > 0 {
		l = 0
		for _, e := range m.Shape {
			l += sovGraphTransferInfo(uint64(e))
		}
		n += 1 + sovGraphTransferInfo(uint64(l)) + l
	}
	if m.Dtype != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.Dtype))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GraphTransferGraphOutputNodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if len(m.Shape) > 0 {
		l = 0
		for _, e := range m.Shape {
			l += sovGraphTransferInfo(uint64(e))
		}
		n += 1 + sovGraphTransferInfo(uint64(l)) + l
	}
	if m.Dtype != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.Dtype))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GraphTransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeInfo) > 0 {
		for _, e := range m.NodeInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if len(m.ConstNodeInfo) > 0 {
		for _, e := range m.ConstNodeInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if len(m.NodeInputInfo) > 0 {
		for _, e := range m.NodeInputInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if len(m.NodeOutputInfo) > 0 {
		for _, e := range m.NodeOutputInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if len(m.GraphInputNodeInfo) > 0 {
		for _, e := range m.GraphInputNodeInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if len(m.GraphOutputNodeInfo) > 0 {
		for _, e := range m.GraphOutputNodeInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if m.Destination != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.Destination))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGraphTransferInfo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGraphTransferInfo(x uint64) (n int) {
	return sovGraphTransferInfo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GraphTransferNodeInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferNodeInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferNodeInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputPort", wireType)
			}
			m.OutputPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferNodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferNodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferNodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocOpId", wireType)
			}
			m.SocOpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SocOpId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaddingId", wireType)
			}
			m.PaddingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaddingId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCount", wireType)
			}
			m.InputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCount", wireType)
			}
			m.OutputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferConstNodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferConstNodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferConstNodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Shape = append(m.Shape, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Shape) == 0 {
					m.Shape = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGraphTransferInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Shape = append(m.Shape, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= types_go_proto.DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferNodeInputInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferNodeInputInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferNodeInputInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeInput = append(m.NodeInput, &GraphTransferNodeInput{})
			if err := m.NodeInput[len(m.NodeInput)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferNodeOutputInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferNodeOutputInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferNodeOutputInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MaxByteSize = append(m.MaxByteSize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MaxByteSize) == 0 {
					m.MaxByteSize = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGraphTransferInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MaxByteSize = append(m.MaxByteSize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxByteSize", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferGraphInputNodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferGraphInputNodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferGraphInputNodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Shape = append(m.Shape, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Shape) == 0 {
					m.Shape = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGraphTransferInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Shape = append(m.Shape, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= types_go_proto.DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferGraphOutputNodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferGraphOutputNodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferGraphOutputNodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Shape = append(m.Shape, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Shape) == 0 {
					m.Shape = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGraphTransferInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Shape = append(m.Shape, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= types_go_proto.DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeInfo = append(m.NodeInfo, &GraphTransferNodeInfo{})
			if err := m.NodeInfo[len(m.NodeInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstNodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConstNodeInfo = append(m.ConstNodeInfo, &GraphTransferConstNodeInfo{})
			if err := m.ConstNodeInfo[len(m.ConstNodeInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInputInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeInputInfo = append(m.NodeInputInfo, &GraphTransferNodeInputInfo{})
			if err := m.NodeInputInfo[len(m.NodeInputInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeOutputInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeOutputInfo = append(m.NodeOutputInfo, &GraphTransferNodeOutputInfo{})
			if err := m.NodeOutputInfo[len(m.NodeOutputInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphInputNodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphInputNodeInfo = append(m.GraphInputNodeInfo, &GraphTransferGraphInputNodeInfo{})
			if err := m.GraphInputNodeInfo[len(m.GraphInputNodeInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphOutputNodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphOutputNodeInfo = append(m.GraphOutputNodeInfo, &GraphTransferGraphOutputNodeInfo{})
			if err := m.GraphOutputNodeInfo[len(m.GraphOutputNodeInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			m.Destination = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Destination |= GraphTransferInfo_Destination(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGraphTransferInfo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGraphTransferInfo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGraphTransferInfo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGraphTransferInfo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGraphTransferInfo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGraphTransferInfo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGraphTransferInfo = fmt.Errorf("proto: unexpected end of group")
)
