// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/debug_event.proto

package for_core_protos_go_proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	tensor_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/tensor_go_proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Available modes for extracting debugging information from a Tensor.
// TODO(cais): Document the detailed column names and semantics in a separate
// markdown file once the implementation settles.
type TensorDebugMode int32

const (
	TensorDebugMode_UNSPECIFIED TensorDebugMode = 0
	// Only records what tensors are computed, eagerly or in graphs.
	// No information regarding the value of the tensor is available.
	TensorDebugMode_NO_TENSOR TensorDebugMode = 1
	// A minimalist health summary for float-type tensors.
	// Contains information only about the presence/absence of pathological
	// values including Infinity and NaN.
	// Applicable only to float dtypes.
	TensorDebugMode_CURT_HEALTH TensorDebugMode = 2
	// A concise health summary for float-type tensors.
	// Contains more information that CURT_HEALTH.
	// Infinity and NaN are treated differently.
	// Applicable only to float and integer dtypes.
	TensorDebugMode_CONCISE_HEALTH TensorDebugMode = 3
	// A detailed health summary.
	// Contains further detailed information than `CONCISE_HEALTH`.
	// Information about device, dtype and shape are included.
	// Counts for various types of values (Infinity, NaN, negative, zero,
	// positive) are included.
	// Applicable to float, integer and boolean dtypes.
	TensorDebugMode_FULL_HEALTH TensorDebugMode = 4
	// Provides full runtime shape information, up to a maximum rank, beyond
	// which the dimension sizes are truncated.
	TensorDebugMode_SHAPE TensorDebugMode = 5
	// Full numeric summary.
	// Including device, dtype, shape, counts of various types of values
	// (Infinity, NaN, negative, zero, positive), and summary statistics
	// (minimum, maximum, mean and variance).
	// Applicable to float, integer and boolean dtypes.
	TensorDebugMode_FULL_NUMERICS TensorDebugMode = 6
	// Full tensor value.
	TensorDebugMode_FULL_TENSOR TensorDebugMode = 7
	// Reduce the elements of a tensor to a rank-1 tensor of shape [3], in which
	// - the 1st element is -inf if any element of the tensor is -inf,
	//   or zero otherwise.
	// - the 2nd element is +inf if any element of the tensor is +inf,
	//   or zero otherwise.
	// - the 3rd element is nan if any element of the tensor is nan, or zero
	//   otherwise.
	TensorDebugMode_REDUCE_INF_NAN_THREE_SLOTS TensorDebugMode = 8
)

var TensorDebugMode_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "NO_TENSOR",
	2: "CURT_HEALTH",
	3: "CONCISE_HEALTH",
	4: "FULL_HEALTH",
	5: "SHAPE",
	6: "FULL_NUMERICS",
	7: "FULL_TENSOR",
	8: "REDUCE_INF_NAN_THREE_SLOTS",
}

var TensorDebugMode_value = map[string]int32{
	"UNSPECIFIED":                0,
	"NO_TENSOR":                  1,
	"CURT_HEALTH":                2,
	"CONCISE_HEALTH":             3,
	"FULL_HEALTH":                4,
	"SHAPE":                      5,
	"FULL_NUMERICS":              6,
	"FULL_TENSOR":                7,
	"REDUCE_INF_NAN_THREE_SLOTS": 8,
}

func (x TensorDebugMode) String() string {
	return proto.EnumName(TensorDebugMode_name, int32(x))
}

func (TensorDebugMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{0}
}

// An Event related to the debugging of a TensorFlow program.
type DebugEvent struct {
	// Timestamp in seconds (with microsecond precision).
	WallTime float64 `protobuf:"fixed64,1,opt,name=wall_time,json=wallTime,proto3" json:"wall_time,omitempty"`
	// Step of training (if available).
	Step int64 `protobuf:"varint,2,opt,name=step,proto3" json:"step,omitempty"`
	// Types that are valid to be assigned to What:
	//	*DebugEvent_DebugMetadata
	//	*DebugEvent_SourceFile
	//	*DebugEvent_StackFrameWithId
	//	*DebugEvent_GraphOpCreation
	//	*DebugEvent_DebuggedGraph
	//	*DebugEvent_Execution
	//	*DebugEvent_GraphExecutionTrace
	//	*DebugEvent_GraphId
	//	*DebugEvent_DebuggedDevice
	What                 isDebugEvent_What `protobuf_oneof:"what"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DebugEvent) Reset()         { *m = DebugEvent{} }
func (m *DebugEvent) String() string { return proto.CompactTextString(m) }
func (*DebugEvent) ProtoMessage()    {}
func (*DebugEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{0}
}
func (m *DebugEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DebugEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugEvent.Merge(m, src)
}
func (m *DebugEvent) XXX_Size() int {
	return m.Size()
}
func (m *DebugEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugEvent.DiscardUnknown(m)
}

var xxx_messageInfo_DebugEvent proto.InternalMessageInfo

type isDebugEvent_What interface {
	isDebugEvent_What()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DebugEvent_DebugMetadata struct {
	DebugMetadata *DebugMetadata `protobuf:"bytes,3,opt,name=debug_metadata,json=debugMetadata,proto3,oneof" json:"debug_metadata,omitempty"`
}
type DebugEvent_SourceFile struct {
	SourceFile *SourceFile `protobuf:"bytes,4,opt,name=source_file,json=sourceFile,proto3,oneof" json:"source_file,omitempty"`
}
type DebugEvent_StackFrameWithId struct {
	StackFrameWithId *StackFrameWithId `protobuf:"bytes,6,opt,name=stack_frame_with_id,json=stackFrameWithId,proto3,oneof" json:"stack_frame_with_id,omitempty"`
}
type DebugEvent_GraphOpCreation struct {
	GraphOpCreation *GraphOpCreation `protobuf:"bytes,7,opt,name=graph_op_creation,json=graphOpCreation,proto3,oneof" json:"graph_op_creation,omitempty"`
}
type DebugEvent_DebuggedGraph struct {
	DebuggedGraph *DebuggedGraph `protobuf:"bytes,8,opt,name=debugged_graph,json=debuggedGraph,proto3,oneof" json:"debugged_graph,omitempty"`
}
type DebugEvent_Execution struct {
	Execution *Execution `protobuf:"bytes,9,opt,name=execution,proto3,oneof" json:"execution,omitempty"`
}
type DebugEvent_GraphExecutionTrace struct {
	GraphExecutionTrace *GraphExecutionTrace `protobuf:"bytes,10,opt,name=graph_execution_trace,json=graphExecutionTrace,proto3,oneof" json:"graph_execution_trace,omitempty"`
}
type DebugEvent_GraphId struct {
	GraphId string `protobuf:"bytes,11,opt,name=graph_id,json=graphId,proto3,oneof" json:"graph_id,omitempty"`
}
type DebugEvent_DebuggedDevice struct {
	DebuggedDevice *DebuggedDevice `protobuf:"bytes,12,opt,name=debugged_device,json=debuggedDevice,proto3,oneof" json:"debugged_device,omitempty"`
}

func (*DebugEvent_DebugMetadata) isDebugEvent_What()       {}
func (*DebugEvent_SourceFile) isDebugEvent_What()          {}
func (*DebugEvent_StackFrameWithId) isDebugEvent_What()    {}
func (*DebugEvent_GraphOpCreation) isDebugEvent_What()     {}
func (*DebugEvent_DebuggedGraph) isDebugEvent_What()       {}
func (*DebugEvent_Execution) isDebugEvent_What()           {}
func (*DebugEvent_GraphExecutionTrace) isDebugEvent_What() {}
func (*DebugEvent_GraphId) isDebugEvent_What()             {}
func (*DebugEvent_DebuggedDevice) isDebugEvent_What()      {}

func (m *DebugEvent) GetWhat() isDebugEvent_What {
	if m != nil {
		return m.What
	}
	return nil
}

func (m *DebugEvent) GetWallTime() float64 {
	if m != nil {
		return m.WallTime
	}
	return 0
}

func (m *DebugEvent) GetStep() int64 {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *DebugEvent) GetDebugMetadata() *DebugMetadata {
	if x, ok := m.GetWhat().(*DebugEvent_DebugMetadata); ok {
		return x.DebugMetadata
	}
	return nil
}

func (m *DebugEvent) GetSourceFile() *SourceFile {
	if x, ok := m.GetWhat().(*DebugEvent_SourceFile); ok {
		return x.SourceFile
	}
	return nil
}

func (m *DebugEvent) GetStackFrameWithId() *StackFrameWithId {
	if x, ok := m.GetWhat().(*DebugEvent_StackFrameWithId); ok {
		return x.StackFrameWithId
	}
	return nil
}

func (m *DebugEvent) GetGraphOpCreation() *GraphOpCreation {
	if x, ok := m.GetWhat().(*DebugEvent_GraphOpCreation); ok {
		return x.GraphOpCreation
	}
	return nil
}

func (m *DebugEvent) GetDebuggedGraph() *DebuggedGraph {
	if x, ok := m.GetWhat().(*DebugEvent_DebuggedGraph); ok {
		return x.DebuggedGraph
	}
	return nil
}

func (m *DebugEvent) GetExecution() *Execution {
	if x, ok := m.GetWhat().(*DebugEvent_Execution); ok {
		return x.Execution
	}
	return nil
}

func (m *DebugEvent) GetGraphExecutionTrace() *GraphExecutionTrace {
	if x, ok := m.GetWhat().(*DebugEvent_GraphExecutionTrace); ok {
		return x.GraphExecutionTrace
	}
	return nil
}

func (m *DebugEvent) GetGraphId() string {
	if x, ok := m.GetWhat().(*DebugEvent_GraphId); ok {
		return x.GraphId
	}
	return ""
}

func (m *DebugEvent) GetDebuggedDevice() *DebuggedDevice {
	if x, ok := m.GetWhat().(*DebugEvent_DebuggedDevice); ok {
		return x.DebuggedDevice
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DebugEvent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DebugEvent_DebugMetadata)(nil),
		(*DebugEvent_SourceFile)(nil),
		(*DebugEvent_StackFrameWithId)(nil),
		(*DebugEvent_GraphOpCreation)(nil),
		(*DebugEvent_DebuggedGraph)(nil),
		(*DebugEvent_Execution)(nil),
		(*DebugEvent_GraphExecutionTrace)(nil),
		(*DebugEvent_GraphId)(nil),
		(*DebugEvent_DebuggedDevice)(nil),
	}
}

// Metadata about the debugger and the debugged TensorFlow program.
type DebugMetadata struct {
	// Version of TensorFlow.
	TensorflowVersion string `protobuf:"bytes,1,opt,name=tensorflow_version,json=tensorflowVersion,proto3" json:"tensorflow_version,omitempty"`
	// Version of the DebugEvent file format.
	// Has a format of "debug.Event:<number>", e.g., "debug.Event:1".
	FileVersion string `protobuf:"bytes,2,opt,name=file_version,json=fileVersion,proto3" json:"file_version,omitempty"`
	// A unique ID for the current run of tfdbg.
	// A run of tfdbg is defined as a TensorFlow job instrumented by tfdbg.
	// Multiple hosts in a distributed TensorFlow job instrumented by tfdbg
	// have the same ID.
	TfdbgRunId           string   `protobuf:"bytes,3,opt,name=tfdbg_run_id,json=tfdbgRunId,proto3" json:"tfdbg_run_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DebugMetadata) Reset()         { *m = DebugMetadata{} }
func (m *DebugMetadata) String() string { return proto.CompactTextString(m) }
func (*DebugMetadata) ProtoMessage()    {}
func (*DebugMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{1}
}
func (m *DebugMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DebugMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugMetadata.Merge(m, src)
}
func (m *DebugMetadata) XXX_Size() int {
	return m.Size()
}
func (m *DebugMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_DebugMetadata proto.InternalMessageInfo

func (m *DebugMetadata) GetTensorflowVersion() string {
	if m != nil {
		return m.TensorflowVersion
	}
	return ""
}

func (m *DebugMetadata) GetFileVersion() string {
	if m != nil {
		return m.FileVersion
	}
	return ""
}

func (m *DebugMetadata) GetTfdbgRunId() string {
	if m != nil {
		return m.TfdbgRunId
	}
	return ""
}

// Content of a source file involved in the execution of the debugged TensorFlow
// program.
type SourceFile struct {
	// Path to the file.
	FilePath string `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// Name of the host on which the file is located.
	HostName string `protobuf:"bytes,2,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// Line-by-line content of the file.
	Lines                []string `protobuf:"bytes,3,rep,name=lines,proto3" json:"lines,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SourceFile) Reset()         { *m = SourceFile{} }
func (m *SourceFile) String() string { return proto.CompactTextString(m) }
func (*SourceFile) ProtoMessage()    {}
func (*SourceFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{2}
}
func (m *SourceFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SourceFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceFile.Merge(m, src)
}
func (m *SourceFile) XXX_Size() int {
	return m.Size()
}
func (m *SourceFile) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceFile.DiscardUnknown(m)
}

var xxx_messageInfo_SourceFile proto.InternalMessageInfo

func (m *SourceFile) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *SourceFile) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *SourceFile) GetLines() []string {
	if m != nil {
		return m.Lines
	}
	return nil
}

// A stack frame with ID.
type StackFrameWithId struct {
	// A unique ID for the stack frame: A UUID-like string.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Stack frame, i.e., a frame of a stack trace, containing information
	// regarding the file name, line number, function name, code content
	// of the line, and column number (if available).
	FileLineCol          *GraphDebugInfo_FileLineCol `protobuf:"bytes,2,opt,name=file_line_col,json=fileLineCol,proto3" json:"file_line_col,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *StackFrameWithId) Reset()         { *m = StackFrameWithId{} }
func (m *StackFrameWithId) String() string { return proto.CompactTextString(m) }
func (*StackFrameWithId) ProtoMessage()    {}
func (*StackFrameWithId) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{3}
}
func (m *StackFrameWithId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StackFrameWithId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StackFrameWithId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StackFrameWithId.Merge(m, src)
}
func (m *StackFrameWithId) XXX_Size() int {
	return m.Size()
}
func (m *StackFrameWithId) XXX_DiscardUnknown() {
	xxx_messageInfo_StackFrameWithId.DiscardUnknown(m)
}

var xxx_messageInfo_StackFrameWithId proto.InternalMessageInfo

func (m *StackFrameWithId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StackFrameWithId) GetFileLineCol() *GraphDebugInfo_FileLineCol {
	if m != nil {
		return m.FileLineCol
	}
	return nil
}

// Code location information: A stack trace with host-name information.
// Instead of encoding the detailed stack trace, this proto refers to IDs of
// stack frames stored as `StackFrameWithId` protos.
type CodeLocation struct {
	// Host name on which the source files are located.
	HostName string `protobuf:"bytes,1,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// ID to a stack frame, each of which is pointed to
	// by a unique ID. The ordering of the frames is consistent with Python's
	// `traceback.extract_tb()`.
	StackFrameIds        []string `protobuf:"bytes,2,rep,name=stack_frame_ids,json=stackFrameIds,proto3" json:"stack_frame_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CodeLocation) Reset()         { *m = CodeLocation{} }
func (m *CodeLocation) String() string { return proto.CompactTextString(m) }
func (*CodeLocation) ProtoMessage()    {}
func (*CodeLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{4}
}
func (m *CodeLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodeLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CodeLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodeLocation.Merge(m, src)
}
func (m *CodeLocation) XXX_Size() int {
	return m.Size()
}
func (m *CodeLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_CodeLocation.DiscardUnknown(m)
}

var xxx_messageInfo_CodeLocation proto.InternalMessageInfo

func (m *CodeLocation) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *CodeLocation) GetStackFrameIds() []string {
	if m != nil {
		return m.StackFrameIds
	}
	return nil
}

// The creation of an op in a TensorFlow Graph (e.g., FuncGraph in TF2).
type GraphOpCreation struct {
	// Type of the op (e.g., "MatMul").
	OpType string `protobuf:"bytes,1,opt,name=op_type,json=opType,proto3" json:"op_type,omitempty"`
	// Name of the op (e.g., "Dense/MatMul_1").
	OpName string `protobuf:"bytes,2,opt,name=op_name,json=opName,proto3" json:"op_name,omitempty"`
	// Name of the graph that the op is a part of (if available).
	GraphName string `protobuf:"bytes,3,opt,name=graph_name,json=graphName,proto3" json:"graph_name,omitempty"`
	// Unique ID of the graph (generated by debugger).
	// This is the ID of the immediately-enclosing graph.
	GraphId string `protobuf:"bytes,4,opt,name=graph_id,json=graphId,proto3" json:"graph_id,omitempty"`
	// Name of the device that the op is assigned to (if available).
	DeviceName string `protobuf:"bytes,5,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	// Names of the input tensors to the op.
	InputNames []string `protobuf:"bytes,6,rep,name=input_names,json=inputNames,proto3" json:"input_names,omitempty"`
	// Number of output tensors emitted by the op.
	NumOutputs int32 `protobuf:"varint,7,opt,name=num_outputs,json=numOutputs,proto3" json:"num_outputs,omitempty"`
	// The unique ID for code location (stack trace) of the op's creation.
	CodeLocation *CodeLocation `protobuf:"bytes,8,opt,name=code_location,json=codeLocation,proto3" json:"code_location,omitempty"`
	// Unique IDs for the output tensors of this op.
	OutputTensorIds      []int32  `protobuf:"varint,9,rep,packed,name=output_tensor_ids,json=outputTensorIds,proto3" json:"output_tensor_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GraphOpCreation) Reset()         { *m = GraphOpCreation{} }
func (m *GraphOpCreation) String() string { return proto.CompactTextString(m) }
func (*GraphOpCreation) ProtoMessage()    {}
func (*GraphOpCreation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{5}
}
func (m *GraphOpCreation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphOpCreation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GraphOpCreation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphOpCreation.Merge(m, src)
}
func (m *GraphOpCreation) XXX_Size() int {
	return m.Size()
}
func (m *GraphOpCreation) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphOpCreation.DiscardUnknown(m)
}

var xxx_messageInfo_GraphOpCreation proto.InternalMessageInfo

func (m *GraphOpCreation) GetOpType() string {
	if m != nil {
		return m.OpType
	}
	return ""
}

func (m *GraphOpCreation) GetOpName() string {
	if m != nil {
		return m.OpName
	}
	return ""
}

func (m *GraphOpCreation) GetGraphName() string {
	if m != nil {
		return m.GraphName
	}
	return ""
}

func (m *GraphOpCreation) GetGraphId() string {
	if m != nil {
		return m.GraphId
	}
	return ""
}

func (m *GraphOpCreation) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *GraphOpCreation) GetInputNames() []string {
	if m != nil {
		return m.InputNames
	}
	return nil
}

func (m *GraphOpCreation) GetNumOutputs() int32 {
	if m != nil {
		return m.NumOutputs
	}
	return 0
}

func (m *GraphOpCreation) GetCodeLocation() *CodeLocation {
	if m != nil {
		return m.CodeLocation
	}
	return nil
}

func (m *GraphOpCreation) GetOutputTensorIds() []int32 {
	if m != nil {
		return m.OutputTensorIds
	}
	return nil
}

// A debugger-instrumented graph.
type DebuggedGraph struct {
	// An ID for the graph.
	// This can be used up to look up graph names. Generated by the debugger.
	GraphId string `protobuf:"bytes,1,opt,name=graph_id,json=graphId,proto3" json:"graph_id,omitempty"`
	// Name of the graph (if available).
	GraphName string `protobuf:"bytes,2,opt,name=graph_name,json=graphName,proto3" json:"graph_name,omitempty"`
	// Names of the instrumented ops. This can be used to look up op name
	// based on the numeric-summary tensors (2nd column).
	InstrumentedOps []string `protobuf:"bytes,3,rep,name=instrumented_ops,json=instrumentedOps,proto3" json:"instrumented_ops,omitempty"`
	// Original (uninstrumented) GraphDef (if available).
	OriginalGraphDef []byte `protobuf:"bytes,4,opt,name=original_graph_def,json=originalGraphDef,proto3" json:"original_graph_def,omitempty"`
	// An encoded version of a GraphDef.
	// This graph may include the debugger-inserted ops.
	InstrumentedGraphDef []byte `protobuf:"bytes,5,opt,name=instrumented_graph_def,json=instrumentedGraphDef,proto3" json:"instrumented_graph_def,omitempty"`
	// IDs of the immediate enclosing context (graph), if any.
	OuterContextId       string   `protobuf:"bytes,6,opt,name=outer_context_id,json=outerContextId,proto3" json:"outer_context_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DebuggedGraph) Reset()         { *m = DebuggedGraph{} }
func (m *DebuggedGraph) String() string { return proto.CompactTextString(m) }
func (*DebuggedGraph) ProtoMessage()    {}
func (*DebuggedGraph) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{6}
}
func (m *DebuggedGraph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebuggedGraph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DebuggedGraph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebuggedGraph.Merge(m, src)
}
func (m *DebuggedGraph) XXX_Size() int {
	return m.Size()
}
func (m *DebuggedGraph) XXX_DiscardUnknown() {
	xxx_messageInfo_DebuggedGraph.DiscardUnknown(m)
}

var xxx_messageInfo_DebuggedGraph proto.InternalMessageInfo

func (m *DebuggedGraph) GetGraphId() string {
	if m != nil {
		return m.GraphId
	}
	return ""
}

func (m *DebuggedGraph) GetGraphName() string {
	if m != nil {
		return m.GraphName
	}
	return ""
}

func (m *DebuggedGraph) GetInstrumentedOps() []string {
	if m != nil {
		return m.InstrumentedOps
	}
	return nil
}

func (m *DebuggedGraph) GetOriginalGraphDef() []byte {
	if m != nil {
		return m.OriginalGraphDef
	}
	return nil
}

func (m *DebuggedGraph) GetInstrumentedGraphDef() []byte {
	if m != nil {
		return m.InstrumentedGraphDef
	}
	return nil
}

func (m *DebuggedGraph) GetOuterContextId() string {
	if m != nil {
		return m.OuterContextId
	}
	return ""
}

// A device on which ops and/or tensors are instrumented by the debugger.
type DebuggedDevice struct {
	// Name of the device.
	DeviceName string `protobuf:"bytes,1,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	// A debugger-generated ID for the device. Guaranteed to be unique within
	// the scope of the debugged TensorFlow program, including single-host and
	// multi-host settings.
	// TODO(cais): Test the uniqueness guarantee in multi-host settings.
	DeviceId             int32    `protobuf:"varint,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DebuggedDevice) Reset()         { *m = DebuggedDevice{} }
func (m *DebuggedDevice) String() string { return proto.CompactTextString(m) }
func (*DebuggedDevice) ProtoMessage()    {}
func (*DebuggedDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{7}
}
func (m *DebuggedDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebuggedDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DebuggedDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebuggedDevice.Merge(m, src)
}
func (m *DebuggedDevice) XXX_Size() int {
	return m.Size()
}
func (m *DebuggedDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_DebuggedDevice.DiscardUnknown(m)
}

var xxx_messageInfo_DebuggedDevice proto.InternalMessageInfo

func (m *DebuggedDevice) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *DebuggedDevice) GetDeviceId() int32 {
	if m != nil {
		return m.DeviceId
	}
	return 0
}

// Data relating to the eager execution of an op or a Graph.
// For a op that generates N output tensors (N >= 0), only one
// Execution proto will be used to describe the execution event.
type Execution struct {
	// Op type (e.g., "MatMul").
	// In the case of a Graph, this is the name of the Graph.
	OpType string `protobuf:"bytes,1,opt,name=op_type,json=opType,proto3" json:"op_type,omitempty"`
	// Number of output tensors.
	NumOutputs int32 `protobuf:"varint,2,opt,name=num_outputs,json=numOutputs,proto3" json:"num_outputs,omitempty"`
	// The graph that's executed: applicable only to the eager
	// execution of a FuncGraph.
	GraphId string `protobuf:"bytes,3,opt,name=graph_id,json=graphId,proto3" json:"graph_id,omitempty"`
	// IDs of the input tensors (if available).
	InputTensorIds []int64 `protobuf:"varint,4,rep,packed,name=input_tensor_ids,json=inputTensorIds,proto3" json:"input_tensor_ids,omitempty"`
	// IDs of the output tensors (if availbable).
	// If specified, must have the same length as tensor_protos.
	OutputTensorIds []int64 `protobuf:"varint,5,rep,packed,name=output_tensor_ids,json=outputTensorIds,proto3" json:"output_tensor_ids,omitempty"`
	// Type of the tensor value encapsulated in this proto.
	TensorDebugMode TensorDebugMode `protobuf:"varint,6,opt,name=tensor_debug_mode,json=tensorDebugMode,proto3,enum=tensorflow.TensorDebugMode" json:"tensor_debug_mode,omitempty"`
	// Output Tensor values in the type described by `tensor_value_type`.
	// The length of this should match `num_outputs`.
	TensorProtos []*tensor_go_proto.TensorProto `protobuf:"bytes,7,rep,name=tensor_protos,json=tensorProtos,proto3" json:"tensor_protos,omitempty"`
	// Stack trace of the eager execution.
	CodeLocation *CodeLocation `protobuf:"bytes,8,opt,name=code_location,json=codeLocation,proto3" json:"code_location,omitempty"`
	// Debugged-generated IDs of the devices on which the output tensors reside.
	// To look up details about the device (e.g., name), cross-reference this
	// field with the DebuggedDevice messages.
	OutputTensorDeviceIds []int32  `protobuf:"varint,9,rep,packed,name=output_tensor_device_ids,json=outputTensorDeviceIds,proto3" json:"output_tensor_device_ids,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *Execution) Reset()         { *m = Execution{} }
func (m *Execution) String() string { return proto.CompactTextString(m) }
func (*Execution) ProtoMessage()    {}
func (*Execution) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{8}
}
func (m *Execution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Execution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Execution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Execution.Merge(m, src)
}
func (m *Execution) XXX_Size() int {
	return m.Size()
}
func (m *Execution) XXX_DiscardUnknown() {
	xxx_messageInfo_Execution.DiscardUnknown(m)
}

var xxx_messageInfo_Execution proto.InternalMessageInfo

func (m *Execution) GetOpType() string {
	if m != nil {
		return m.OpType
	}
	return ""
}

func (m *Execution) GetNumOutputs() int32 {
	if m != nil {
		return m.NumOutputs
	}
	return 0
}

func (m *Execution) GetGraphId() string {
	if m != nil {
		return m.GraphId
	}
	return ""
}

func (m *Execution) GetInputTensorIds() []int64 {
	if m != nil {
		return m.InputTensorIds
	}
	return nil
}

func (m *Execution) GetOutputTensorIds() []int64 {
	if m != nil {
		return m.OutputTensorIds
	}
	return nil
}

func (m *Execution) GetTensorDebugMode() TensorDebugMode {
	if m != nil {
		return m.TensorDebugMode
	}
	return TensorDebugMode_UNSPECIFIED
}

func (m *Execution) GetTensorProtos() []*tensor_go_proto.TensorProto {
	if m != nil {
		return m.TensorProtos
	}
	return nil
}

func (m *Execution) GetCodeLocation() *CodeLocation {
	if m != nil {
		return m.CodeLocation
	}
	return nil
}

func (m *Execution) GetOutputTensorDeviceIds() []int32 {
	if m != nil {
		return m.OutputTensorDeviceIds
	}
	return nil
}

// Data relating to an execution of a Graph (e.g., an eager execution of a
// FuncGraph).
// The values of the intermediate tensors computed in the graph are recorded
// in this proto. A graph execution may correspond to one or more pieces of
// `GraphExecutionTrace`, depending on whether the instrumented tensor values
// are summarized in an aggregated or separate fashion.
type GraphExecutionTrace struct {
	// Unique ID of the context that the executed op(s) belong to (e.g., a
	// compiled concrete tf.function).
	TfdbgContextId string `protobuf:"bytes,1,opt,name=tfdbg_context_id,json=tfdbgContextId,proto3" json:"tfdbg_context_id,omitempty"`
	// Name of the op (applicable only in the case of the `FULL_TENSOR` trace
	// level).
	OpName string `protobuf:"bytes,2,opt,name=op_name,json=opName,proto3" json:"op_name,omitempty"`
	// Output slot of the tensor (applicable only in the case of the `FULL_TENSOR`
	// trace level).
	OutputSlot int32 `protobuf:"varint,3,opt,name=output_slot,json=outputSlot,proto3" json:"output_slot,omitempty"`
	// Type of the tensor value encapsulated in this proto.
	TensorDebugMode TensorDebugMode `protobuf:"varint,4,opt,name=tensor_debug_mode,json=tensorDebugMode,proto3,enum=tensorflow.TensorDebugMode" json:"tensor_debug_mode,omitempty"`
	// Tensor value in the type described by `tensor_value_type`.
	// This tensor may summarize the value of a single intermediate op of the
	// graph, or those of multiple intermediate tensors.
	TensorProto *tensor_go_proto.TensorProto `protobuf:"bytes,5,opt,name=tensor_proto,json=tensorProto,proto3" json:"tensor_proto,omitempty"`
	// Name of the device that the op belongs to.
	DeviceName           string   `protobuf:"bytes,6,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GraphExecutionTrace) Reset()         { *m = GraphExecutionTrace{} }
func (m *GraphExecutionTrace) String() string { return proto.CompactTextString(m) }
func (*GraphExecutionTrace) ProtoMessage()    {}
func (*GraphExecutionTrace) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff023fe0e3927cdd, []int{9}
}
func (m *GraphExecutionTrace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphExecutionTrace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GraphExecutionTrace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphExecutionTrace.Merge(m, src)
}
func (m *GraphExecutionTrace) XXX_Size() int {
	return m.Size()
}
func (m *GraphExecutionTrace) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphExecutionTrace.DiscardUnknown(m)
}

var xxx_messageInfo_GraphExecutionTrace proto.InternalMessageInfo

func (m *GraphExecutionTrace) GetTfdbgContextId() string {
	if m != nil {
		return m.TfdbgContextId
	}
	return ""
}

func (m *GraphExecutionTrace) GetOpName() string {
	if m != nil {
		return m.OpName
	}
	return ""
}

func (m *GraphExecutionTrace) GetOutputSlot() int32 {
	if m != nil {
		return m.OutputSlot
	}
	return 0
}

func (m *GraphExecutionTrace) GetTensorDebugMode() TensorDebugMode {
	if m != nil {
		return m.TensorDebugMode
	}
	return TensorDebugMode_UNSPECIFIED
}

func (m *GraphExecutionTrace) GetTensorProto() *tensor_go_proto.TensorProto {
	if m != nil {
		return m.TensorProto
	}
	return nil
}

func (m *GraphExecutionTrace) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func init() {
	proto.RegisterEnum("tensorflow.TensorDebugMode", TensorDebugMode_name, TensorDebugMode_value)
	proto.RegisterType((*DebugEvent)(nil), "tensorflow.DebugEvent")
	proto.RegisterType((*DebugMetadata)(nil), "tensorflow.DebugMetadata")
	proto.RegisterType((*SourceFile)(nil), "tensorflow.SourceFile")
	proto.RegisterType((*StackFrameWithId)(nil), "tensorflow.StackFrameWithId")
	proto.RegisterType((*CodeLocation)(nil), "tensorflow.CodeLocation")
	proto.RegisterType((*GraphOpCreation)(nil), "tensorflow.GraphOpCreation")
	proto.RegisterType((*DebuggedGraph)(nil), "tensorflow.DebuggedGraph")
	proto.RegisterType((*DebuggedDevice)(nil), "tensorflow.DebuggedDevice")
	proto.RegisterType((*Execution)(nil), "tensorflow.Execution")
	proto.RegisterType((*GraphExecutionTrace)(nil), "tensorflow.GraphExecutionTrace")
}

func init() {
	proto.RegisterFile("tensorflow/core/protobuf/debug_event.proto", fileDescriptor_ff023fe0e3927cdd)
}

var fileDescriptor_ff023fe0e3927cdd = []byte{
	// 1276 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x5d, 0x6f, 0xe3, 0x44,
	0x17, 0x8e, 0xf3, 0xd5, 0xe4, 0xe4, 0xb3, 0xd3, 0xfd, 0xf0, 0xb6, 0xef, 0xdb, 0xe6, 0xcd, 0xc5,
	0x2a, 0xef, 0x0a, 0x5a, 0x69, 0x01, 0x21, 0x10, 0x5c, 0x6c, 0x53, 0x77, 0x13, 0xd4, 0x4d, 0xaa,
	0x49, 0x02, 0x12, 0x42, 0x1a, 0xb9, 0xf6, 0x24, 0xb1, 0xd6, 0xf1, 0x58, 0xf6, 0x78, 0xbb, 0x7b,
	0x0b, 0x3f, 0x01, 0xee, 0xf9, 0x15, 0xf0, 0x1b, 0x90, 0xb8, 0xe1, 0x92, 0x4b, 0xd4, 0x5f, 0xc1,
	0x25, 0x9a, 0x19, 0xc7, 0x71, 0xdc, 0x96, 0x0b, 0xb8, 0xb3, 0x9f, 0x73, 0xce, 0x33, 0x73, 0x9e,
	0xf3, 0xcc, 0xd8, 0xf0, 0x8c, 0x53, 0x2f, 0x64, 0xc1, 0xdc, 0x65, 0xd7, 0x27, 0x16, 0x0b, 0xe8,
	0x89, 0x1f, 0x30, 0xce, 0xae, 0xa2, 0xf9, 0x89, 0x4d, 0xaf, 0xa2, 0x05, 0xa1, 0x6f, 0xa8, 0xc7,
	0x8f, 0x25, 0x88, 0x60, 0x93, 0xbb, 0xff, 0x34, 0x5b, 0x37, 0x0f, 0xcc, 0x15, 0xbd, 0x66, 0xc1,
	0xeb, 0x13, 0x15, 0x51, 0x35, 0xfb, 0x27, 0xf7, 0xf2, 0x2f, 0x02, 0xd3, 0x5f, 0x12, 0xb5, 0x8a,
	0xe3, 0xcd, 0x99, 0x2a, 0xe8, 0xfe, 0x50, 0x02, 0x38, 0x13, 0xa0, 0x21, 0x56, 0x46, 0x07, 0x50,
	0xbd, 0x36, 0x5d, 0x97, 0x70, 0x67, 0x45, 0x75, 0xad, 0xa3, 0xf5, 0x34, 0x5c, 0x11, 0xc0, 0xd4,
	0x59, 0x51, 0x84, 0xa0, 0x18, 0x72, 0xea, 0xeb, 0xf9, 0x8e, 0xd6, 0x2b, 0x60, 0xf9, 0x8c, 0x4e,
	0xa1, 0xa9, 0x38, 0x57, 0x94, 0x9b, 0xb6, 0xc9, 0x4d, 0xbd, 0xd0, 0xd1, 0x7a, 0xb5, 0xe7, 0x4f,
	0x8e, 0x37, 0x3b, 0x39, 0x96, 0x0b, 0xbc, 0x8a, 0x13, 0x06, 0x39, 0xdc, 0xb0, 0xd3, 0x00, 0xfa,
	0x04, 0x6a, 0x21, 0x8b, 0x02, 0x8b, 0x92, 0xb9, 0xe3, 0x52, 0xbd, 0x28, 0x09, 0x1e, 0xa5, 0x09,
	0x26, 0x32, 0x7c, 0xee, 0xb8, 0x74, 0x90, 0xc3, 0x10, 0x26, 0x6f, 0xe8, 0x15, 0xec, 0x85, 0xdc,
	0xb4, 0x5e, 0x13, 0xa9, 0x07, 0xb9, 0x76, 0xf8, 0x92, 0x38, 0xb6, 0x5e, 0x96, 0x14, 0xff, 0xd9,
	0xa2, 0x10, 0x69, 0xe7, 0x22, 0xeb, 0x2b, 0x87, 0x2f, 0x87, 0xf6, 0x20, 0x87, 0xdb, 0x61, 0x06,
	0x43, 0x43, 0xd8, 0x55, 0x3a, 0x31, 0x9f, 0x58, 0x01, 0x35, 0xb9, 0xc3, 0x3c, 0x7d, 0x47, 0x92,
	0x1d, 0xa4, 0xc9, 0x5e, 0x8a, 0xa4, 0xb1, 0xdf, 0x8f, 0x53, 0x06, 0x39, 0xdc, 0x5a, 0x6c, 0x43,
	0x89, 0x30, 0x0b, 0x6a, 0x13, 0x19, 0xd3, 0x2b, 0xf7, 0x08, 0xb3, 0xa0, 0xb6, 0xe4, 0x4b, 0x84,
	0x59, 0x03, 0xe8, 0x23, 0xa8, 0xd2, 0xb7, 0xd4, 0x8a, 0xe4, 0x36, 0xaa, 0xb2, 0xfc, 0x61, 0xba,
	0xdc, 0x58, 0x07, 0x07, 0x39, 0xbc, 0xc9, 0x44, 0x33, 0x78, 0xa8, 0xba, 0x48, 0x20, 0xc2, 0x03,
	0xd3, 0xa2, 0x3a, 0x48, 0x8a, 0xa3, 0x5b, 0x9d, 0x24, 0x3c, 0x53, 0x91, 0x36, 0xc8, 0xe1, 0xbd,
	0xc5, 0x6d, 0x18, 0x1d, 0x40, 0x45, 0xd1, 0x3a, 0xb6, 0x5e, 0xeb, 0x68, 0xbd, 0xea, 0x20, 0x87,
	0x77, 0x24, 0x32, 0xb4, 0x91, 0x01, 0xad, 0xa4, 0x5d, 0x9b, 0xbe, 0x71, 0x2c, 0xaa, 0xd7, 0xe5,
	0x6a, 0xfb, 0x77, 0xf5, 0x7b, 0x26, 0x33, 0x06, 0x39, 0x9c, 0x68, 0xa4, 0x90, 0xd3, 0x32, 0x14,
	0xaf, 0x97, 0x26, 0xef, 0x7e, 0xa7, 0x41, 0x63, 0xcb, 0x35, 0xe8, 0x7d, 0x40, 0x1b, 0x22, 0xf2,
	0x86, 0x06, 0xa1, 0x10, 0x45, 0x58, 0xb4, 0x8a, 0x77, 0x37, 0x91, 0x2f, 0x55, 0x00, 0xfd, 0x0f,
	0xea, 0xc2, 0x4c, 0x49, 0x62, 0x5e, 0x26, 0xd6, 0x04, 0xb6, 0x4e, 0xe9, 0x40, 0x9d, 0xcf, 0xed,
	0xab, 0x05, 0x09, 0x22, 0x4f, 0xf4, 0x54, 0x90, 0x29, 0x20, 0x31, 0x1c, 0x79, 0x43, 0xbb, 0xfb,
	0x0d, 0xc0, 0xc6, 0x79, 0xe2, 0x6c, 0x48, 0x4a, 0xdf, 0xe4, 0xcb, 0x78, 0xe1, 0x8a, 0x00, 0x2e,
	0x4d, 0xbe, 0x14, 0xc1, 0x25, 0x0b, 0x39, 0xf1, 0xcc, 0x15, 0x8d, 0x17, 0xab, 0x08, 0x60, 0x64,
	0xae, 0x28, 0x7a, 0x00, 0x25, 0xd7, 0xf1, 0x68, 0xa8, 0x17, 0x3a, 0x85, 0x5e, 0x15, 0xab, 0x97,
	0xae, 0x07, 0xed, 0xac, 0x29, 0x51, 0x13, 0xf2, 0x8e, 0x1d, 0x93, 0xe7, 0x1d, 0x1b, 0x7d, 0x01,
	0x0d, 0xb9, 0xa6, 0xa8, 0x20, 0x16, 0x73, 0x25, 0x75, 0xed, 0xf9, 0xd3, 0x5b, 0x23, 0x94, 0x62,
	0x0d, 0xc5, 0xb9, 0x16, 0x7b, 0xbd, 0x70, 0x3c, 0xda, 0x67, 0xae, 0xea, 0x37, 0x7e, 0xe9, 0x4e,
	0xa0, 0xde, 0x67, 0x36, 0xbd, 0x60, 0x96, 0x72, 0xe8, 0xd6, 0x96, 0xb5, 0xcc, 0x96, 0x9f, 0x42,
	0x2b, 0x7d, 0xb0, 0x1c, 0x3b, 0xd4, 0xf3, 0x72, 0xf3, 0x8d, 0xcd, 0xa1, 0x19, 0xda, 0x61, 0xf7,
	0xd7, 0x3c, 0xb4, 0x32, 0xa7, 0x01, 0x3d, 0x86, 0x1d, 0xe6, 0x13, 0xfe, 0xce, 0x5f, 0xd3, 0x96,
	0x99, 0x3f, 0x7d, 0xe7, 0xd3, 0x38, 0x90, 0x92, 0xa8, 0xcc, 0x7c, 0xb9, 0xda, 0x7f, 0x01, 0x94,
	0xb5, 0x64, 0x4c, 0x0d, 0xa2, 0x2a, 0x11, 0x19, 0x7e, 0x92, 0x72, 0x5e, 0x51, 0x06, 0x13, 0xdf,
	0x1d, 0x41, 0x4d, 0xd9, 0x4d, 0x95, 0x96, 0xd4, 0x0c, 0x15, 0x24, 0x6b, 0x8f, 0xa0, 0xe6, 0x78,
	0x7e, 0xa4, 0xda, 0x0c, 0xf5, 0xb2, 0x6c, 0x02, 0x24, 0x24, 0xe2, 0xa1, 0x48, 0xf0, 0xa2, 0x15,
	0x61, 0x11, 0xf7, 0x23, 0x1e, 0xca, 0xd3, 0x5e, 0xc2, 0xe0, 0x45, 0xab, 0xb1, 0x42, 0xd0, 0xe7,
	0xd0, 0xb0, 0x98, 0x4d, 0x89, 0x1b, 0x0b, 0x17, 0x1f, 0x64, 0x3d, 0x3d, 0x83, 0xb4, 0xb0, 0xb8,
	0x6e, 0xa5, 0x65, 0x7e, 0x06, 0xbb, 0x8a, 0x9b, 0xa8, 0x7c, 0xa9, 0x65, 0xb5, 0x53, 0xe8, 0x95,
	0x70, 0x4b, 0x05, 0xa6, 0x12, 0x17, 0x6a, 0x7e, 0x9b, 0x8f, 0x6d, 0x9f, 0x5c, 0x01, 0xe9, 0xd6,
	0xb5, 0xed, 0xd6, 0xb7, 0x45, 0xcb, 0x67, 0x45, 0xfb, 0x3f, 0xb4, 0x1d, 0x2f, 0xe4, 0x41, 0xb4,
	0xa2, 0x1e, 0xa7, 0x36, 0x61, 0xfe, 0xda, 0x7f, 0xad, 0x34, 0x3e, 0xf6, 0x43, 0xf4, 0x1e, 0x20,
	0x16, 0x38, 0x0b, 0xc7, 0x33, 0x5d, 0xb2, 0xfe, 0x4e, 0xcc, 0xa5, 0xd2, 0x75, 0xdc, 0x5e, 0x47,
	0x62, 0x9b, 0xcd, 0xd1, 0x87, 0xf0, 0x68, 0x8b, 0x78, 0x53, 0x51, 0x92, 0x15, 0x0f, 0xd2, 0xd1,
	0xa4, 0xaa, 0x07, 0x6d, 0x16, 0x71, 0x1a, 0x10, 0x8b, 0x79, 0x9c, 0xbe, 0xe5, 0xeb, 0x6b, 0xba,
	0x8a, 0x9b, 0x12, 0xef, 0x2b, 0x78, 0x68, 0x77, 0x47, 0xd0, 0xdc, 0xbe, 0x27, 0xb2, 0x43, 0xd6,
	0x6e, 0x0d, 0xf9, 0x00, 0xaa, 0x71, 0x82, 0x63, 0x4b, 0x25, 0x4a, 0xb8, 0xa2, 0x80, 0xa1, 0xdd,
	0xfd, 0xa9, 0x00, 0xd5, 0xe4, 0x2a, 0xbb, 0xdf, 0x9c, 0x19, 0x1f, 0xe4, 0x6f, 0xf9, 0x20, 0x3d,
	0x8a, 0xc2, 0xf6, 0x28, 0x7a, 0x42, 0xeb, 0xcc, 0x88, 0x8b, 0x9d, 0x42, 0xaf, 0x80, 0x9b, 0x12,
	0x4f, 0x26, 0x7c, 0xb7, 0x1b, 0x4a, 0x32, 0x35, 0xeb, 0x06, 0xf4, 0x12, 0xe2, 0x8b, 0x2d, 0xfe,
	0x6c, 0xaf, 0x98, 0x4d, 0xa5, 0x66, 0xcd, 0xed, 0xaf, 0x91, 0xaa, 0x50, 0xd7, 0x25, 0xb3, 0x29,
	0x6e, 0xf1, 0x6d, 0x00, 0x7d, 0x06, 0x8d, 0x98, 0x48, 0x7e, 0xf4, 0x85, 0xc9, 0x0b, 0xbd, 0xda,
	0xf3, 0xc7, 0xb7, 0x49, 0x2e, 0x45, 0x1c, 0xd7, 0xf9, 0xe6, 0xe5, 0x5f, 0xfb, 0xff, 0x63, 0xd0,
	0xb7, 0x3b, 0x4e, 0x26, 0xb5, 0x3e, 0x06, 0x0f, 0xd3, 0x8d, 0x9f, 0xc5, 0x63, 0x0b, 0xbb, 0x3f,
	0xe6, 0x61, 0xef, 0x8e, 0xcf, 0x93, 0x10, 0x5b, 0xdd, 0xdb, 0x29, 0x27, 0xa9, 0x51, 0x36, 0x25,
	0x9e, 0x38, 0xe9, 0xfe, 0xfb, 0xe6, 0x08, 0x6a, 0xf1, 0x9e, 0x42, 0x97, 0x71, 0x39, 0xcd, 0x12,
	0x06, 0x05, 0x4d, 0x5c, 0xc6, 0xef, 0x96, 0xbe, 0xf8, 0x0f, 0xa4, 0xff, 0x14, 0xea, 0x69, 0xe9,
	0xe5, 0x11, 0xf9, 0x1b, 0xe5, 0x6b, 0x29, 0xe5, 0xb3, 0xb6, 0x2f, 0x67, 0x6d, 0xff, 0xec, 0x67,
	0x0d, 0x5a, 0x99, 0x1d, 0xa0, 0x16, 0xd4, 0x66, 0xa3, 0xc9, 0xa5, 0xd1, 0x1f, 0x9e, 0x0f, 0x8d,
	0xb3, 0x76, 0x0e, 0x35, 0xa0, 0x3a, 0x1a, 0x93, 0xa9, 0x31, 0x9a, 0x8c, 0x71, 0x5b, 0x13, 0xf1,
	0xfe, 0x0c, 0x4f, 0xc9, 0xc0, 0x78, 0x71, 0x31, 0x1d, 0xb4, 0xf3, 0x08, 0x41, 0xb3, 0x3f, 0x1e,
	0xf5, 0x87, 0x13, 0x63, 0x8d, 0x15, 0x44, 0xd2, 0xf9, 0xec, 0xe2, 0x62, 0x0d, 0x14, 0x51, 0x15,
	0x4a, 0x93, 0xc1, 0x8b, 0x4b, 0xa3, 0x5d, 0x42, 0xbb, 0xd0, 0x90, 0xb1, 0xd1, 0xec, 0x95, 0x81,
	0x87, 0xfd, 0x49, 0xbb, 0x9c, 0xa4, 0xc7, 0x8b, 0xec, 0xa0, 0x43, 0xd8, 0xc7, 0xc6, 0xd9, 0xac,
	0x6f, 0x90, 0xe1, 0xe8, 0x9c, 0x8c, 0x5e, 0x8c, 0xc8, 0x74, 0x80, 0x0d, 0x83, 0x4c, 0x2e, 0xc6,
	0xd3, 0x49, 0xbb, 0x72, 0xfa, 0xbd, 0xf6, 0xcb, 0xcd, 0xa1, 0xf6, 0xdb, 0xcd, 0xa1, 0xf6, 0xfb,
	0xcd, 0xa1, 0xf6, 0xc7, 0xcd, 0xa1, 0x06, 0x7b, 0x2c, 0x58, 0xa4, 0x55, 0x89, 0xb8, 0xe3, 0x9e,
	0xb6, 0x37, 0xbf, 0xa6, 0xca, 0x8c, 0x97, 0xda, 0xd7, 0xb3, 0x85, 0xc3, 0x97, 0xd1, 0xd5, 0xb1,
	0xc5, 0x56, 0xe9, 0xbf, 0xdd, 0xbb, 0x1f, 0x17, 0x2c, 0xf3, 0x1b, 0x3c, 0x67, 0xe2, 0x06, 0x0a,
	0x68, 0x7c, 0x12, 0xc8, 0x82, 0xa9, 0xa7, 0x3f, 0x35, 0xed, 0xaa, 0x2c, 0x9f, 0x3e, 0xf8, 0x2b,
	0x00, 0x00, 0xff, 0xff, 0xde, 0xa6, 0xfb, 0xe4, 0xa5, 0x0b, 0x00, 0x00,
}

func (m *DebugEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.What != nil {
		{
			size := m.What.Size()
			i -= size
			if _, err := m.What.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Step != 0 {
		i = encodeVarintDebugEvent(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x10
	}
	if m.WallTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WallTime))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DebugEvent_DebugMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEvent_DebugMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DebugMetadata != nil {
		{
			size, err := m.DebugMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DebugEvent_SourceFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEvent_SourceFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SourceFile != nil {
		{
			size, err := m.SourceFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DebugEvent_StackFrameWithId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEvent_StackFrameWithId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StackFrameWithId != nil {
		{
			size, err := m.StackFrameWithId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DebugEvent_GraphOpCreation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEvent_GraphOpCreation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GraphOpCreation != nil {
		{
			size, err := m.GraphOpCreation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DebugEvent_DebuggedGraph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEvent_DebuggedGraph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DebuggedGraph != nil {
		{
			size, err := m.DebuggedGraph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DebugEvent_Execution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEvent_Execution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Execution != nil {
		{
			size, err := m.Execution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *DebugEvent_GraphExecutionTrace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEvent_GraphExecutionTrace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GraphExecutionTrace != nil {
		{
			size, err := m.GraphExecutionTrace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DebugEvent_GraphId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEvent_GraphId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.GraphId)
	copy(dAtA[i:], m.GraphId)
	i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.GraphId)))
	i--
	dAtA[i] = 0x5a
	return len(dAtA) - i, nil
}
func (m *DebugEvent_DebuggedDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEvent_DebuggedDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DebuggedDevice != nil {
		{
			size, err := m.DebuggedDevice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *DebugMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TfdbgRunId) > 0 {
		i -= len(m.TfdbgRunId)
		copy(dAtA[i:], m.TfdbgRunId)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.TfdbgRunId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileVersion) > 0 {
		i -= len(m.FileVersion)
		copy(dAtA[i:], m.FileVersion)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.FileVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TensorflowVersion) > 0 {
		i -= len(m.TensorflowVersion)
		copy(dAtA[i:], m.TensorflowVersion)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.TensorflowVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SourceFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Lines) > 0 {
		for iNdEx := len(m.Lines) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Lines[iNdEx])
			copy(dAtA[i:], m.Lines[iNdEx])
			i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.Lines[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StackFrameWithId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StackFrameWithId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StackFrameWithId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FileLineCol != nil {
		{
			size, err := m.FileLineCol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CodeLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodeLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodeLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StackFrameIds) > 0 {
		for iNdEx := len(m.StackFrameIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StackFrameIds[iNdEx])
			copy(dAtA[i:], m.StackFrameIds[iNdEx])
			i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.StackFrameIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GraphOpCreation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphOpCreation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphOpCreation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OutputTensorIds) > 0 {
		dAtA11 := make([]byte, len(m.OutputTensorIds)*10)
		var j10 int
		for _, num1 := range m.OutputTensorIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintDebugEvent(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x4a
	}
	if m.CodeLocation != nil {
		{
			size, err := m.CodeLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.NumOutputs != 0 {
		i = encodeVarintDebugEvent(dAtA, i, uint64(m.NumOutputs))
		i--
		dAtA[i] = 0x38
	}
	if len(m.InputNames) > 0 {
		for iNdEx := len(m.InputNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InputNames[iNdEx])
			copy(dAtA[i:], m.InputNames[iNdEx])
			i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.InputNames[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GraphId) > 0 {
		i -= len(m.GraphId)
		copy(dAtA[i:], m.GraphId)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.GraphId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GraphName) > 0 {
		i -= len(m.GraphName)
		copy(dAtA[i:], m.GraphName)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.GraphName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OpName) > 0 {
		i -= len(m.OpName)
		copy(dAtA[i:], m.OpName)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.OpName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OpType) > 0 {
		i -= len(m.OpType)
		copy(dAtA[i:], m.OpType)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.OpType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DebuggedGraph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebuggedGraph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebuggedGraph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OuterContextId) > 0 {
		i -= len(m.OuterContextId)
		copy(dAtA[i:], m.OuterContextId)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.OuterContextId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.InstrumentedGraphDef) > 0 {
		i -= len(m.InstrumentedGraphDef)
		copy(dAtA[i:], m.InstrumentedGraphDef)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.InstrumentedGraphDef)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OriginalGraphDef) > 0 {
		i -= len(m.OriginalGraphDef)
		copy(dAtA[i:], m.OriginalGraphDef)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.OriginalGraphDef)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.InstrumentedOps) > 0 {
		for iNdEx := len(m.InstrumentedOps) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InstrumentedOps[iNdEx])
			copy(dAtA[i:], m.InstrumentedOps[iNdEx])
			i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.InstrumentedOps[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.GraphName) > 0 {
		i -= len(m.GraphName)
		copy(dAtA[i:], m.GraphName)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.GraphName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GraphId) > 0 {
		i -= len(m.GraphId)
		copy(dAtA[i:], m.GraphId)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.GraphId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DebuggedDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebuggedDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebuggedDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeviceId != 0 {
		i = encodeVarintDebugEvent(dAtA, i, uint64(m.DeviceId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Execution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Execution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Execution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OutputTensorDeviceIds) > 0 {
		dAtA14 := make([]byte, len(m.OutputTensorDeviceIds)*10)
		var j13 int
		for _, num1 := range m.OutputTensorDeviceIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintDebugEvent(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x4a
	}
	if m.CodeLocation != nil {
		{
			size, err := m.CodeLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.TensorProtos) > 0 {
		for iNdEx := len(m.TensorProtos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TensorProtos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebugEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.TensorDebugMode != 0 {
		i = encodeVarintDebugEvent(dAtA, i, uint64(m.TensorDebugMode))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OutputTensorIds) > 0 {
		dAtA17 := make([]byte, len(m.OutputTensorIds)*10)
		var j16 int
		for _, num1 := range m.OutputTensorIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintDebugEvent(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.InputTensorIds) > 0 {
		dAtA19 := make([]byte, len(m.InputTensorIds)*10)
		var j18 int
		for _, num1 := range m.InputTensorIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintDebugEvent(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GraphId) > 0 {
		i -= len(m.GraphId)
		copy(dAtA[i:], m.GraphId)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.GraphId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NumOutputs != 0 {
		i = encodeVarintDebugEvent(dAtA, i, uint64(m.NumOutputs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.OpType) > 0 {
		i -= len(m.OpType)
		copy(dAtA[i:], m.OpType)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.OpType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GraphExecutionTrace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphExecutionTrace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphExecutionTrace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x32
	}
	if m.TensorProto != nil {
		{
			size, err := m.TensorProto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebugEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TensorDebugMode != 0 {
		i = encodeVarintDebugEvent(dAtA, i, uint64(m.TensorDebugMode))
		i--
		dAtA[i] = 0x20
	}
	if m.OutputSlot != 0 {
		i = encodeVarintDebugEvent(dAtA, i, uint64(m.OutputSlot))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OpName) > 0 {
		i -= len(m.OpName)
		copy(dAtA[i:], m.OpName)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.OpName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TfdbgContextId) > 0 {
		i -= len(m.TfdbgContextId)
		copy(dAtA[i:], m.TfdbgContextId)
		i = encodeVarintDebugEvent(dAtA, i, uint64(len(m.TfdbgContextId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDebugEvent(dAtA []byte, offset int, v uint64) int {
	offset -= sovDebugEvent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DebugEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WallTime != 0 {
		n += 9
	}
	if m.Step != 0 {
		n += 1 + sovDebugEvent(uint64(m.Step))
	}
	if m.What != nil {
		n += m.What.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DebugEvent_DebugMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DebugMetadata != nil {
		l = m.DebugMetadata.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	return n
}
func (m *DebugEvent_SourceFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceFile != nil {
		l = m.SourceFile.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	return n
}
func (m *DebugEvent_StackFrameWithId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StackFrameWithId != nil {
		l = m.StackFrameWithId.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	return n
}
func (m *DebugEvent_GraphOpCreation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GraphOpCreation != nil {
		l = m.GraphOpCreation.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	return n
}
func (m *DebugEvent_DebuggedGraph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DebuggedGraph != nil {
		l = m.DebuggedGraph.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	return n
}
func (m *DebugEvent_Execution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Execution != nil {
		l = m.Execution.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	return n
}
func (m *DebugEvent_GraphExecutionTrace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GraphExecutionTrace != nil {
		l = m.GraphExecutionTrace.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	return n
}
func (m *DebugEvent_GraphId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GraphId)
	n += 1 + l + sovDebugEvent(uint64(l))
	return n
}
func (m *DebugEvent_DebuggedDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DebuggedDevice != nil {
		l = m.DebuggedDevice.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	return n
}
func (m *DebugMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TensorflowVersion)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.FileVersion)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.TfdbgRunId)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SourceFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if len(m.Lines) > 0 {
		for _, s := range m.Lines {
			l = len(s)
			n += 1 + l + sovDebugEvent(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StackFrameWithId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if m.FileLineCol != nil {
		l = m.FileLineCol.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CodeLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if len(m.StackFrameIds) > 0 {
		for _, s := range m.StackFrameIds {
			l = len(s)
			n += 1 + l + sovDebugEvent(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GraphOpCreation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OpType)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.OpName)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.GraphName)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.GraphId)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if len(m.InputNames) > 0 {
		for _, s := range m.InputNames {
			l = len(s)
			n += 1 + l + sovDebugEvent(uint64(l))
		}
	}
	if m.NumOutputs != 0 {
		n += 1 + sovDebugEvent(uint64(m.NumOutputs))
	}
	if m.CodeLocation != nil {
		l = m.CodeLocation.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if len(m.OutputTensorIds) > 0 {
		l = 0
		for _, e := range m.OutputTensorIds {
			l += sovDebugEvent(uint64(e))
		}
		n += 1 + sovDebugEvent(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DebuggedGraph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GraphId)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.GraphName)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if len(m.InstrumentedOps) > 0 {
		for _, s := range m.InstrumentedOps {
			l = len(s)
			n += 1 + l + sovDebugEvent(uint64(l))
		}
	}
	l = len(m.OriginalGraphDef)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.InstrumentedGraphDef)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.OuterContextId)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DebuggedDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if m.DeviceId != 0 {
		n += 1 + sovDebugEvent(uint64(m.DeviceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Execution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OpType)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if m.NumOutputs != 0 {
		n += 1 + sovDebugEvent(uint64(m.NumOutputs))
	}
	l = len(m.GraphId)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if len(m.InputTensorIds) > 0 {
		l = 0
		for _, e := range m.InputTensorIds {
			l += sovDebugEvent(uint64(e))
		}
		n += 1 + sovDebugEvent(uint64(l)) + l
	}
	if len(m.OutputTensorIds) > 0 {
		l = 0
		for _, e := range m.OutputTensorIds {
			l += sovDebugEvent(uint64(e))
		}
		n += 1 + sovDebugEvent(uint64(l)) + l
	}
	if m.TensorDebugMode != 0 {
		n += 1 + sovDebugEvent(uint64(m.TensorDebugMode))
	}
	if len(m.TensorProtos) > 0 {
		for _, e := range m.TensorProtos {
			l = e.Size()
			n += 1 + l + sovDebugEvent(uint64(l))
		}
	}
	if m.CodeLocation != nil {
		l = m.CodeLocation.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if len(m.OutputTensorDeviceIds) > 0 {
		l = 0
		for _, e := range m.OutputTensorDeviceIds {
			l += sovDebugEvent(uint64(e))
		}
		n += 1 + sovDebugEvent(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GraphExecutionTrace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TfdbgContextId)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.OpName)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if m.OutputSlot != 0 {
		n += 1 + sovDebugEvent(uint64(m.OutputSlot))
	}
	if m.TensorDebugMode != 0 {
		n += 1 + sovDebugEvent(uint64(m.TensorDebugMode))
	}
	if m.TensorProto != nil {
		l = m.TensorProto.Size()
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovDebugEvent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDebugEvent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDebugEvent(x uint64) (n int) {
	return sovDebugEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DebugEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WallTime = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DebugMetadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.What = &DebugEvent_DebugMetadata{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.What = &DebugEvent_SourceFile{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackFrameWithId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StackFrameWithId{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.What = &DebugEvent_StackFrameWithId{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphOpCreation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GraphOpCreation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.What = &DebugEvent_GraphOpCreation{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebuggedGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DebuggedGraph{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.What = &DebugEvent_DebuggedGraph{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Execution{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.What = &DebugEvent_Execution{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphExecutionTrace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GraphExecutionTrace{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.What = &DebugEvent_GraphExecutionTrace{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.What = &DebugEvent_GraphId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebuggedDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DebuggedDevice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.What = &DebugEvent_DebuggedDevice{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebugEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorflowVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorflowVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TfdbgRunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TfdbgRunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebugEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lines", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lines = append(m.Lines, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebugEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StackFrameWithId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StackFrameWithId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StackFrameWithId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileLineCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileLineCol == nil {
				m.FileLineCol = &GraphDebugInfo_FileLineCol{}
			}
			if err := m.FileLineCol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebugEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodeLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodeLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodeLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackFrameIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StackFrameIds = append(m.StackFrameIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebugEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphOpCreation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphOpCreation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphOpCreation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputNames = append(m.InputNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOutputs", wireType)
			}
			m.NumOutputs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOutputs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodeLocation == nil {
				m.CodeLocation = &CodeLocation{}
			}
			if err := m.CodeLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebugEvent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutputTensorIds = append(m.OutputTensorIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebugEvent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDebugEvent
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDebugEvent
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OutputTensorIds) == 0 {
					m.OutputTensorIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDebugEvent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutputTensorIds = append(m.OutputTensorIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputTensorIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebugEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebuggedGraph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebuggedGraph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebuggedGraph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstrumentedOps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstrumentedOps = append(m.InstrumentedOps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalGraphDef", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalGraphDef = append(m.OriginalGraphDef[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalGraphDef == nil {
				m.OriginalGraphDef = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstrumentedGraphDef", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstrumentedGraphDef = append(m.InstrumentedGraphDef[:0], dAtA[iNdEx:postIndex]...)
			if m.InstrumentedGraphDef == nil {
				m.InstrumentedGraphDef = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterContextId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OuterContextId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebugEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebuggedDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebuggedDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebuggedDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			m.DeviceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebugEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOutputs", wireType)
			}
			m.NumOutputs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOutputs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebugEvent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InputTensorIds = append(m.InputTensorIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebugEvent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDebugEvent
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDebugEvent
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InputTensorIds) == 0 {
					m.InputTensorIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDebugEvent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InputTensorIds = append(m.InputTensorIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InputTensorIds", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebugEvent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutputTensorIds = append(m.OutputTensorIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebugEvent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDebugEvent
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDebugEvent
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OutputTensorIds) == 0 {
					m.OutputTensorIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDebugEvent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutputTensorIds = append(m.OutputTensorIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputTensorIds", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorDebugMode", wireType)
			}
			m.TensorDebugMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TensorDebugMode |= TensorDebugMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorProtos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorProtos = append(m.TensorProtos, &tensor_go_proto.TensorProto{})
			if err := m.TensorProtos[len(m.TensorProtos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodeLocation == nil {
				m.CodeLocation = &CodeLocation{}
			}
			if err := m.CodeLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebugEvent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutputTensorDeviceIds = append(m.OutputTensorDeviceIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebugEvent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDebugEvent
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDebugEvent
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OutputTensorDeviceIds) == 0 {
					m.OutputTensorDeviceIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDebugEvent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutputTensorDeviceIds = append(m.OutputTensorDeviceIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputTensorDeviceIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebugEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphExecutionTrace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphExecutionTrace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphExecutionTrace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TfdbgContextId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TfdbgContextId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSlot", wireType)
			}
			m.OutputSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputSlot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorDebugMode", wireType)
			}
			m.TensorDebugMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TensorDebugMode |= TensorDebugMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorProto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TensorProto == nil {
				m.TensorProto = &tensor_go_proto.TensorProto{}
			}
			if err := m.TensorProto.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebugEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebugEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDebugEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDebugEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebugEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDebugEvent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDebugEvent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDebugEvent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDebugEvent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDebugEvent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDebugEvent = fmt.Errorf("proto: unexpected end of group")
)
