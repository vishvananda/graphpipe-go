// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/master.proto

package for_core_protos_go_proto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	device_attributes_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/device_attributes_go_proto"
	graph_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/graph_go_proto"
	tensor_go_proto "github.com/vishvananda/graphpipe-go/cmd/graphpipe-tf/internal/github.com/tensorflow/tensorflow/tensorflow/go/core/framework/tensor_go_proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CreateSessionRequest struct {
	// The initial graph definition.
	GraphDef *graph_go_proto.GraphDef `protobuf:"bytes,1,opt,name=graph_def,json=graphDef,proto3" json:"graph_def,omitempty"`
	// Configuration options.
	Config *ConfigProto `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	// The target string used from the client's perspective.
	Target               string   `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateSessionRequest) Reset()         { *m = CreateSessionRequest{} }
func (m *CreateSessionRequest) String() string { return proto.CompactTextString(m) }
func (*CreateSessionRequest) ProtoMessage()    {}
func (*CreateSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{0}
}
func (m *CreateSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSessionRequest.Merge(m, src)
}
func (m *CreateSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSessionRequest proto.InternalMessageInfo

func (m *CreateSessionRequest) GetGraphDef() *graph_go_proto.GraphDef {
	if m != nil {
		return m.GraphDef
	}
	return nil
}

func (m *CreateSessionRequest) GetConfig() *ConfigProto {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *CreateSessionRequest) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

type CreateSessionResponse struct {
	// The session handle to be used in subsequent calls for the created session.
	//
	// The client must arrange to call CloseSession with this returned
	// session handle to close the session.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// The initial version number for the graph, to be used in the next call
	// to ExtendSession.
	GraphVersion         int64    `protobuf:"varint,2,opt,name=graph_version,json=graphVersion,proto3" json:"graph_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateSessionResponse) Reset()         { *m = CreateSessionResponse{} }
func (m *CreateSessionResponse) String() string { return proto.CompactTextString(m) }
func (*CreateSessionResponse) ProtoMessage()    {}
func (*CreateSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{1}
}
func (m *CreateSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSessionResponse.Merge(m, src)
}
func (m *CreateSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSessionResponse proto.InternalMessageInfo

func (m *CreateSessionResponse) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *CreateSessionResponse) GetGraphVersion() int64 {
	if m != nil {
		return m.GraphVersion
	}
	return 0
}

type ExtendSessionRequest struct {
	// REQUIRED: session_handle must be returned by a CreateSession call
	// to the same master service.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// REQUIRED: The nodes to be added to the session's graph. If any node has
	// the same name as an existing node, the operation will fail with
	// ILLEGAL_ARGUMENT.
	GraphDef *graph_go_proto.GraphDef `protobuf:"bytes,2,opt,name=graph_def,json=graphDef,proto3" json:"graph_def,omitempty"`
	// REQUIRED: The version number of the graph to be extended. This will be
	// tested against the current server-side version number, and the operation
	// will fail with FAILED_PRECONDITION if they do not match.
	CurrentGraphVersion  int64    `protobuf:"varint,3,opt,name=current_graph_version,json=currentGraphVersion,proto3" json:"current_graph_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtendSessionRequest) Reset()         { *m = ExtendSessionRequest{} }
func (m *ExtendSessionRequest) String() string { return proto.CompactTextString(m) }
func (*ExtendSessionRequest) ProtoMessage()    {}
func (*ExtendSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{2}
}
func (m *ExtendSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtendSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExtendSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtendSessionRequest.Merge(m, src)
}
func (m *ExtendSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExtendSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtendSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExtendSessionRequest proto.InternalMessageInfo

func (m *ExtendSessionRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *ExtendSessionRequest) GetGraphDef() *graph_go_proto.GraphDef {
	if m != nil {
		return m.GraphDef
	}
	return nil
}

func (m *ExtendSessionRequest) GetCurrentGraphVersion() int64 {
	if m != nil {
		return m.CurrentGraphVersion
	}
	return 0
}

type ExtendSessionResponse struct {
	// The new version number for the extended graph, to be used in the next call
	// to ExtendSession.
	NewGraphVersion      int64    `protobuf:"varint,4,opt,name=new_graph_version,json=newGraphVersion,proto3" json:"new_graph_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtendSessionResponse) Reset()         { *m = ExtendSessionResponse{} }
func (m *ExtendSessionResponse) String() string { return proto.CompactTextString(m) }
func (*ExtendSessionResponse) ProtoMessage()    {}
func (*ExtendSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{3}
}
func (m *ExtendSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtendSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExtendSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtendSessionResponse.Merge(m, src)
}
func (m *ExtendSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExtendSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtendSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExtendSessionResponse proto.InternalMessageInfo

func (m *ExtendSessionResponse) GetNewGraphVersion() int64 {
	if m != nil {
		return m.NewGraphVersion
	}
	return 0
}

type RunStepRequest struct {
	// REQUIRED: session_handle must be returned by a CreateSession call
	// to the same master service.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// Tensors to be fed in the step. Each feed is a named tensor.
	Feed []*NamedTensorProto `protobuf:"bytes,2,rep,name=feed,proto3" json:"feed,omitempty"`
	// Fetches. A list of tensor names. The caller expects a tensor to
	// be returned for each fetch[i] (see RunStepResponse.tensor). The
	// order of specified fetches does not change the execution order.
	Fetch []string `protobuf:"bytes,3,rep,name=fetch,proto3" json:"fetch,omitempty"`
	// Target Nodes. A list of node names. The named nodes will be run
	// to but their outputs will not be fetched.
	Target []string `protobuf:"bytes,4,rep,name=target,proto3" json:"target,omitempty"`
	// Options for the run call.
	Options *RunOptions `protobuf:"bytes,5,opt,name=options,proto3" json:"options,omitempty"`
	// Partial run handle (optional). If specified, this will be a partial run
	// execution, run up to the specified fetches.
	PartialRunHandle string `protobuf:"bytes,6,opt,name=partial_run_handle,json=partialRunHandle,proto3" json:"partial_run_handle,omitempty"`
	// If true then some errors, e.g., execution errors that have long
	// error messages, may return an OK RunStepResponse with the actual
	// error saved in the status_code/status_error_message fields of the
	// response body. This is a workaround since the RPC subsystem may
	// truncate long metadata messages.
	StoreErrorsInResponseBody bool `protobuf:"varint,7,opt,name=store_errors_in_response_body,json=storeErrorsInResponseBody,proto3" json:"store_errors_in_response_body,omitempty"`
	// Unique identifier for this request. Every RunStepRequest must
	// have a unique request_id, and retried RunStepRequest must have
	// the same request_id. If request_id is zero, retry detection is disabled.
	RequestId            int64    `protobuf:"varint,8,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunStepRequest) Reset()         { *m = RunStepRequest{} }
func (m *RunStepRequest) String() string { return proto.CompactTextString(m) }
func (*RunStepRequest) ProtoMessage()    {}
func (*RunStepRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{4}
}
func (m *RunStepRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunStepRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RunStepRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunStepRequest.Merge(m, src)
}
func (m *RunStepRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunStepRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunStepRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunStepRequest proto.InternalMessageInfo

func (m *RunStepRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *RunStepRequest) GetFeed() []*NamedTensorProto {
	if m != nil {
		return m.Feed
	}
	return nil
}

func (m *RunStepRequest) GetFetch() []string {
	if m != nil {
		return m.Fetch
	}
	return nil
}

func (m *RunStepRequest) GetTarget() []string {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *RunStepRequest) GetOptions() *RunOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *RunStepRequest) GetPartialRunHandle() string {
	if m != nil {
		return m.PartialRunHandle
	}
	return ""
}

func (m *RunStepRequest) GetStoreErrorsInResponseBody() bool {
	if m != nil {
		return m.StoreErrorsInResponseBody
	}
	return false
}

func (m *RunStepRequest) GetRequestId() int64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

type RunStepResponse struct {
	// NOTE: The order of the returned tensors may or may not match
	// the fetch order specified in RunStepRequest.
	Tensor []*NamedTensorProto `protobuf:"bytes,1,rep,name=tensor,proto3" json:"tensor,omitempty"`
	// Returned metadata if requested in the options.
	Metadata *RunMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// If store_errors_in_response_body is true in the request, then
	// optionally the server may return an OK status for the RPC and
	// fill the true status into the fields below, to allow for messages
	// that are too long to fit in metadata.
	StatusCode           Code     `protobuf:"varint,3,opt,name=status_code,json=statusCode,proto3,enum=tensorflow.error.Code" json:"status_code,omitempty"`
	StatusErrorMessage   string   `protobuf:"bytes,4,opt,name=status_error_message,json=statusErrorMessage,proto3" json:"status_error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunStepResponse) Reset()         { *m = RunStepResponse{} }
func (m *RunStepResponse) String() string { return proto.CompactTextString(m) }
func (*RunStepResponse) ProtoMessage()    {}
func (*RunStepResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{5}
}
func (m *RunStepResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunStepResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RunStepResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunStepResponse.Merge(m, src)
}
func (m *RunStepResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunStepResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunStepResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunStepResponse proto.InternalMessageInfo

func (m *RunStepResponse) GetTensor() []*NamedTensorProto {
	if m != nil {
		return m.Tensor
	}
	return nil
}

func (m *RunStepResponse) GetMetadata() *RunMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *RunStepResponse) GetStatusCode() Code {
	if m != nil {
		return m.StatusCode
	}
	return Code_OK
}

func (m *RunStepResponse) GetStatusErrorMessage() string {
	if m != nil {
		return m.StatusErrorMessage
	}
	return ""
}

type PartialRunSetupRequest struct {
	// REQUIRED: session_handle must be returned by a CreateSession call
	// to the same master service.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// Tensors to be fed in future steps.
	Feed []string `protobuf:"bytes,2,rep,name=feed,proto3" json:"feed,omitempty"`
	// Fetches. A list of tensor names. The caller expects a tensor to be returned
	// for each fetch[i] (see RunStepResponse.tensor), for corresponding partial
	// RunStepRequests. The order of specified fetches does not change the
	// execution order.
	Fetch []string `protobuf:"bytes,3,rep,name=fetch,proto3" json:"fetch,omitempty"`
	// Target Nodes. A list of node names. The named nodes will be run in future
	// steps, but their outputs will not be fetched.
	Target []string `protobuf:"bytes,4,rep,name=target,proto3" json:"target,omitempty"`
	// Unique identifier for this request. Every PartialRunSetupRequest must
	// have a unique request_id, and retried PartialRunSetupRequest must have
	// the same request_id. If request_id is zero, retry detection is disabled.
	RequestId            int64    `protobuf:"varint,5,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartialRunSetupRequest) Reset()         { *m = PartialRunSetupRequest{} }
func (m *PartialRunSetupRequest) String() string { return proto.CompactTextString(m) }
func (*PartialRunSetupRequest) ProtoMessage()    {}
func (*PartialRunSetupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{6}
}
func (m *PartialRunSetupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartialRunSetupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PartialRunSetupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartialRunSetupRequest.Merge(m, src)
}
func (m *PartialRunSetupRequest) XXX_Size() int {
	return m.Size()
}
func (m *PartialRunSetupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PartialRunSetupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PartialRunSetupRequest proto.InternalMessageInfo

func (m *PartialRunSetupRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *PartialRunSetupRequest) GetFeed() []string {
	if m != nil {
		return m.Feed
	}
	return nil
}

func (m *PartialRunSetupRequest) GetFetch() []string {
	if m != nil {
		return m.Fetch
	}
	return nil
}

func (m *PartialRunSetupRequest) GetTarget() []string {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *PartialRunSetupRequest) GetRequestId() int64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

type PartialRunSetupResponse struct {
	// The unique handle corresponding to the ongoing partial run call setup by
	// the invocation to PartialRunSetup. This handle may be passed to
	// RunStepRequest to send and receive tensors for this partial run.
	PartialRunHandle     string   `protobuf:"bytes,1,opt,name=partial_run_handle,json=partialRunHandle,proto3" json:"partial_run_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartialRunSetupResponse) Reset()         { *m = PartialRunSetupResponse{} }
func (m *PartialRunSetupResponse) String() string { return proto.CompactTextString(m) }
func (*PartialRunSetupResponse) ProtoMessage()    {}
func (*PartialRunSetupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{7}
}
func (m *PartialRunSetupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartialRunSetupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PartialRunSetupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartialRunSetupResponse.Merge(m, src)
}
func (m *PartialRunSetupResponse) XXX_Size() int {
	return m.Size()
}
func (m *PartialRunSetupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PartialRunSetupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PartialRunSetupResponse proto.InternalMessageInfo

func (m *PartialRunSetupResponse) GetPartialRunHandle() string {
	if m != nil {
		return m.PartialRunHandle
	}
	return ""
}

type CloseSessionRequest struct {
	// REQUIRED: session_handle must be returned by a CreateSession call
	// to the same master service.
	SessionHandle        string   `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloseSessionRequest) Reset()         { *m = CloseSessionRequest{} }
func (m *CloseSessionRequest) String() string { return proto.CompactTextString(m) }
func (*CloseSessionRequest) ProtoMessage()    {}
func (*CloseSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{8}
}
func (m *CloseSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloseSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseSessionRequest.Merge(m, src)
}
func (m *CloseSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CloseSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CloseSessionRequest proto.InternalMessageInfo

func (m *CloseSessionRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

type CloseSessionResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloseSessionResponse) Reset()         { *m = CloseSessionResponse{} }
func (m *CloseSessionResponse) String() string { return proto.CompactTextString(m) }
func (*CloseSessionResponse) ProtoMessage()    {}
func (*CloseSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{9}
}
func (m *CloseSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloseSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseSessionResponse.Merge(m, src)
}
func (m *CloseSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CloseSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CloseSessionResponse proto.InternalMessageInfo

// Reset() allows misbehaving or slow sessions to be aborted and closed, and
// causes their resources eventually to be released.  Reset() does not wait
// for the computations in old sessions to cease; it merely starts the
// process of tearing them down.  However, if a new session is started after
// a Reset(), the new session is isolated from changes that old sessions
// (started prior to the Reset()) may continue to make to resources, provided
// all those resources are in containers listed in "containers".
//
// Old sessions may continue to have side-effects on resources not in
// containers listed in "containers", and thus may affect future
// sessions' results in ways that are hard to predict.  Thus, if well-defined
// behavior is desired, is it recommended that all containers be listed in
// "containers".  Similarly, if a device_filter is specified, results may be
// hard to predict.
type ResetRequest struct {
	// A list of container names, which may be empty.
	//
	// If 'container' is not empty, releases resources in the given
	// containers in all devices.
	//
	// If 'container' is empty, releases resources in the default
	// container in all devices.
	Container []string `protobuf:"bytes,1,rep,name=container,proto3" json:"container,omitempty"`
	// When any filters are present, only devices that match the filters
	// will be reset. Each filter can be partially specified,
	// e.g. "/job:ps" "/job:worker/replica:3", etc.
	DeviceFilters        []string `protobuf:"bytes,2,rep,name=device_filters,json=deviceFilters,proto3" json:"device_filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetRequest) Reset()         { *m = ResetRequest{} }
func (m *ResetRequest) String() string { return proto.CompactTextString(m) }
func (*ResetRequest) ProtoMessage()    {}
func (*ResetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{10}
}
func (m *ResetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetRequest.Merge(m, src)
}
func (m *ResetRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetRequest proto.InternalMessageInfo

func (m *ResetRequest) GetContainer() []string {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *ResetRequest) GetDeviceFilters() []string {
	if m != nil {
		return m.DeviceFilters
	}
	return nil
}

type ResetResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetResponse) Reset()         { *m = ResetResponse{} }
func (m *ResetResponse) String() string { return proto.CompactTextString(m) }
func (*ResetResponse) ProtoMessage()    {}
func (*ResetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{11}
}
func (m *ResetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetResponse.Merge(m, src)
}
func (m *ResetResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResetResponse proto.InternalMessageInfo

type ListDevicesRequest struct {
	// Optional: session_handle must be returned by a CreateSession call to the
	// same master service.
	//
	// When session_handle is empty, the ClusterSpec provided when the master was
	// started is used to compute the available devices. If the session_handle is
	// provided but not recognized, an error is returned. Finally, if a valid
	// session_handle is provided, the cluster configuration for that session is
	// used when computing the response.
	SessionHandle        string   `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDevicesRequest) Reset()         { *m = ListDevicesRequest{} }
func (m *ListDevicesRequest) String() string { return proto.CompactTextString(m) }
func (*ListDevicesRequest) ProtoMessage()    {}
func (*ListDevicesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{12}
}
func (m *ListDevicesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDevicesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListDevicesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDevicesRequest.Merge(m, src)
}
func (m *ListDevicesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListDevicesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDevicesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListDevicesRequest proto.InternalMessageInfo

func (m *ListDevicesRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

type ListDevicesResponse struct {
	LocalDevice          []*device_attributes_go_proto.DeviceAttributes `protobuf:"bytes,1,rep,name=local_device,json=localDevice,proto3" json:"local_device,omitempty"`
	RemoteDevice         []*device_attributes_go_proto.DeviceAttributes `protobuf:"bytes,2,rep,name=remote_device,json=remoteDevice,proto3" json:"remote_device,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                       `json:"-"`
	XXX_unrecognized     []byte                                         `json:"-"`
	XXX_sizecache        int32                                          `json:"-"`
}

func (m *ListDevicesResponse) Reset()         { *m = ListDevicesResponse{} }
func (m *ListDevicesResponse) String() string { return proto.CompactTextString(m) }
func (*ListDevicesResponse) ProtoMessage()    {}
func (*ListDevicesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{13}
}
func (m *ListDevicesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDevicesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListDevicesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDevicesResponse.Merge(m, src)
}
func (m *ListDevicesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListDevicesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDevicesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListDevicesResponse proto.InternalMessageInfo

func (m *ListDevicesResponse) GetLocalDevice() []*device_attributes_go_proto.DeviceAttributes {
	if m != nil {
		return m.LocalDevice
	}
	return nil
}

func (m *ListDevicesResponse) GetRemoteDevice() []*device_attributes_go_proto.DeviceAttributes {
	if m != nil {
		return m.RemoteDevice
	}
	return nil
}

type MakeCallableRequest struct {
	// REQUIRED: session_handle must be returned by a CreateSession call
	// to the same master service.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// Options that define the behavior of the created callable.
	Options *CallableOptions `protobuf:"bytes,2,opt,name=options,proto3" json:"options,omitempty"`
	// Unique identifier for this request. Every MakeCallableRequest must
	// have a unique request_id, and retried MakeCallableRequest must have
	// the same request_id. If request_id is zero, retry detection is disabled.
	RequestId            int64    `protobuf:"varint,3,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MakeCallableRequest) Reset()         { *m = MakeCallableRequest{} }
func (m *MakeCallableRequest) String() string { return proto.CompactTextString(m) }
func (*MakeCallableRequest) ProtoMessage()    {}
func (*MakeCallableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{14}
}
func (m *MakeCallableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MakeCallableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MakeCallableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MakeCallableRequest.Merge(m, src)
}
func (m *MakeCallableRequest) XXX_Size() int {
	return m.Size()
}
func (m *MakeCallableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MakeCallableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MakeCallableRequest proto.InternalMessageInfo

func (m *MakeCallableRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *MakeCallableRequest) GetOptions() *CallableOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *MakeCallableRequest) GetRequestId() int64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

type MakeCallableResponse struct {
	// A handle to the created callable.
	Handle               int64    `protobuf:"varint,1,opt,name=handle,proto3" json:"handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MakeCallableResponse) Reset()         { *m = MakeCallableResponse{} }
func (m *MakeCallableResponse) String() string { return proto.CompactTextString(m) }
func (*MakeCallableResponse) ProtoMessage()    {}
func (*MakeCallableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{15}
}
func (m *MakeCallableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MakeCallableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MakeCallableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MakeCallableResponse.Merge(m, src)
}
func (m *MakeCallableResponse) XXX_Size() int {
	return m.Size()
}
func (m *MakeCallableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MakeCallableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MakeCallableResponse proto.InternalMessageInfo

func (m *MakeCallableResponse) GetHandle() int64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

type RunCallableRequest struct {
	// REQUIRED: session_handle must be returned by a CreateSession call
	// to the same master service.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// REQUIRED: handle must be returned by a MakeCallable call to the same
	// master service.
	Handle int64 `protobuf:"varint,2,opt,name=handle,proto3" json:"handle,omitempty"`
	// Values of the tensors passed as arguments to the callable, in the order
	// defined in the CallableOptions.feed field passed to MakeCallable.
	Feed []*tensor_go_proto.TensorProto `protobuf:"bytes,3,rep,name=feed,proto3" json:"feed,omitempty"`
	// Unique identifier for this request. Every RunCallableRequest must
	// have a unique request_id, and retried RunCallableRequest must have
	// the same request_id. If request_id is zero, retry detection is disabled.
	RequestId            int64    `protobuf:"varint,4,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunCallableRequest) Reset()         { *m = RunCallableRequest{} }
func (m *RunCallableRequest) String() string { return proto.CompactTextString(m) }
func (*RunCallableRequest) ProtoMessage()    {}
func (*RunCallableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{16}
}
func (m *RunCallableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunCallableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RunCallableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunCallableRequest.Merge(m, src)
}
func (m *RunCallableRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunCallableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunCallableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunCallableRequest proto.InternalMessageInfo

func (m *RunCallableRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *RunCallableRequest) GetHandle() int64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

func (m *RunCallableRequest) GetFeed() []*tensor_go_proto.TensorProto {
	if m != nil {
		return m.Feed
	}
	return nil
}

func (m *RunCallableRequest) GetRequestId() int64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

type RunCallableResponse struct {
	// Values of the tensors returned by the callable, in the order defined in the
	// CallableOptions.fetch field passed to MakeCallable.
	Fetch []*tensor_go_proto.TensorProto `protobuf:"bytes,1,rep,name=fetch,proto3" json:"fetch,omitempty"`
	// Returned metadata if requested in the options.
	Metadata             *RunMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RunCallableResponse) Reset()         { *m = RunCallableResponse{} }
func (m *RunCallableResponse) String() string { return proto.CompactTextString(m) }
func (*RunCallableResponse) ProtoMessage()    {}
func (*RunCallableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{17}
}
func (m *RunCallableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunCallableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RunCallableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunCallableResponse.Merge(m, src)
}
func (m *RunCallableResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunCallableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunCallableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunCallableResponse proto.InternalMessageInfo

func (m *RunCallableResponse) GetFetch() []*tensor_go_proto.TensorProto {
	if m != nil {
		return m.Fetch
	}
	return nil
}

func (m *RunCallableResponse) GetMetadata() *RunMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type ReleaseCallableRequest struct {
	// REQUIRED: session_handle must be returned by a CreateSession call
	// to the same master service.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// REQUIRED: handle must be returned by a MakeCallable call to the same
	// master service.
	Handle               int64    `protobuf:"varint,2,opt,name=handle,proto3" json:"handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReleaseCallableRequest) Reset()         { *m = ReleaseCallableRequest{} }
func (m *ReleaseCallableRequest) String() string { return proto.CompactTextString(m) }
func (*ReleaseCallableRequest) ProtoMessage()    {}
func (*ReleaseCallableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{18}
}
func (m *ReleaseCallableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReleaseCallableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReleaseCallableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReleaseCallableRequest.Merge(m, src)
}
func (m *ReleaseCallableRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReleaseCallableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReleaseCallableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReleaseCallableRequest proto.InternalMessageInfo

func (m *ReleaseCallableRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *ReleaseCallableRequest) GetHandle() int64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

type ReleaseCallableResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReleaseCallableResponse) Reset()         { *m = ReleaseCallableResponse{} }
func (m *ReleaseCallableResponse) String() string { return proto.CompactTextString(m) }
func (*ReleaseCallableResponse) ProtoMessage()    {}
func (*ReleaseCallableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5171b2a5dcde72cd, []int{19}
}
func (m *ReleaseCallableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReleaseCallableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReleaseCallableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReleaseCallableResponse.Merge(m, src)
}
func (m *ReleaseCallableResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReleaseCallableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReleaseCallableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReleaseCallableResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*CreateSessionRequest)(nil), "tensorflow.CreateSessionRequest")
	proto.RegisterType((*CreateSessionResponse)(nil), "tensorflow.CreateSessionResponse")
	proto.RegisterType((*ExtendSessionRequest)(nil), "tensorflow.ExtendSessionRequest")
	proto.RegisterType((*ExtendSessionResponse)(nil), "tensorflow.ExtendSessionResponse")
	proto.RegisterType((*RunStepRequest)(nil), "tensorflow.RunStepRequest")
	proto.RegisterType((*RunStepResponse)(nil), "tensorflow.RunStepResponse")
	proto.RegisterType((*PartialRunSetupRequest)(nil), "tensorflow.PartialRunSetupRequest")
	proto.RegisterType((*PartialRunSetupResponse)(nil), "tensorflow.PartialRunSetupResponse")
	proto.RegisterType((*CloseSessionRequest)(nil), "tensorflow.CloseSessionRequest")
	proto.RegisterType((*CloseSessionResponse)(nil), "tensorflow.CloseSessionResponse")
	proto.RegisterType((*ResetRequest)(nil), "tensorflow.ResetRequest")
	proto.RegisterType((*ResetResponse)(nil), "tensorflow.ResetResponse")
	proto.RegisterType((*ListDevicesRequest)(nil), "tensorflow.ListDevicesRequest")
	proto.RegisterType((*ListDevicesResponse)(nil), "tensorflow.ListDevicesResponse")
	proto.RegisterType((*MakeCallableRequest)(nil), "tensorflow.MakeCallableRequest")
	proto.RegisterType((*MakeCallableResponse)(nil), "tensorflow.MakeCallableResponse")
	proto.RegisterType((*RunCallableRequest)(nil), "tensorflow.RunCallableRequest")
	proto.RegisterType((*RunCallableResponse)(nil), "tensorflow.RunCallableResponse")
	proto.RegisterType((*ReleaseCallableRequest)(nil), "tensorflow.ReleaseCallableRequest")
	proto.RegisterType((*ReleaseCallableResponse)(nil), "tensorflow.ReleaseCallableResponse")
}

func init() {
	proto.RegisterFile("tensorflow/core/protobuf/master.proto", fileDescriptor_5171b2a5dcde72cd)
}

var fileDescriptor_5171b2a5dcde72cd = []byte{
	// 983 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0x56, 0xdb, 0x59, 0x6f, 0x5c, 0xf9, 0x83, 0x8e, 0xe3, 0xcc, 0x86, 0xdd, 0x28, 0x1a, 0x14,
	0x14, 0xed, 0x82, 0x9d, 0xcd, 0x82, 0x38, 0x80, 0x04, 0xbb, 0xce, 0x12, 0x56, 0x22, 0x10, 0x75,
	0xf8, 0x91, 0xb8, 0x8c, 0xda, 0x33, 0x35, 0xce, 0x68, 0xc7, 0xd3, 0xa6, 0xbb, 0x67, 0x43, 0x5e,
	0x83, 0x1b, 0x27, 0x10, 0xe2, 0x61, 0x38, 0x72, 0xdc, 0x23, 0xca, 0x85, 0x57, 0xe0, 0x88, 0xdc,
	0xdd, 0xb6, 0x67, 0x1c, 0x1b, 0x25, 0x11, 0xb7, 0xee, 0xaa, 0xaf, 0xaa, 0xbf, 0xfa, 0xba, 0xba,
	0x66, 0x60, 0x57, 0x63, 0xa6, 0x84, 0x8c, 0x53, 0x71, 0xde, 0x0e, 0x85, 0xc4, 0xf6, 0x40, 0x0a,
	0x2d, 0xba, 0x79, 0xdc, 0xee, 0x73, 0xa5, 0x51, 0xb6, 0xcc, 0x9e, 0xc2, 0x04, 0xb6, 0xf5, 0x78,
	0x3a, 0x24, 0x96, 0xbc, 0x8f, 0xe7, 0x42, 0xbe, 0x6c, 0x47, 0xf8, 0x2a, 0x09, 0x31, 0xe0, 0x5a,
	0xcb, 0xa4, 0x9b, 0x6b, 0x54, 0x36, 0x7c, 0x6b, 0x77, 0x7e, 0x48, 0x4f, 0xf2, 0xc1, 0x99, 0x83,
	0xbd, 0x33, 0x1f, 0x66, 0x3d, 0xf3, 0xd2, 0x8d, 0x49, 0x87, 0x22, 0x8b, 0x93, 0x9e, 0x83, 0x3d,
	0x9c, 0x0b, 0x43, 0x29, 0x85, 0x0c, 0x42, 0x11, 0x8d, 0x19, 0x3e, 0x9a, 0x8b, 0xcd, 0x78, 0x1f,
	0xa3, 0xa0, 0x78, 0xbe, 0xff, 0x13, 0x81, 0x46, 0x47, 0x22, 0xd7, 0x78, 0x8a, 0x4a, 0x25, 0x22,
	0x63, 0xf8, 0x43, 0x8e, 0x4a, 0xd3, 0xc7, 0x50, 0x37, 0xf5, 0x04, 0x11, 0xc6, 0x1e, 0xd9, 0x21,
	0x7b, 0x4b, 0x07, 0x8d, 0xd6, 0x24, 0x73, 0xeb, 0x68, 0xe8, 0x3c, 0xc4, 0x98, 0x2d, 0xf6, 0xdc,
	0x8a, 0xb6, 0xa1, 0x66, 0x49, 0x7b, 0x15, 0x83, 0xdf, 0x2c, 0xe2, 0x3b, 0xc6, 0x73, 0x32, 0x3c,
	0x94, 0x39, 0x18, 0x6d, 0x42, 0x4d, 0x73, 0xd9, 0x43, 0xed, 0x55, 0x77, 0xc8, 0x5e, 0x9d, 0xb9,
	0x9d, 0x1f, 0xc2, 0xc6, 0x14, 0x27, 0x35, 0x10, 0x99, 0x42, 0xba, 0x0b, 0xab, 0xca, 0x9a, 0x82,
	0x33, 0x9e, 0x45, 0x29, 0x1a, 0x66, 0x75, 0xb6, 0xe2, 0xac, 0x9f, 0x1b, 0x23, 0x7d, 0x1b, 0x56,
	0x2c, 0xf7, 0x57, 0x28, 0x87, 0x66, 0xc3, 0xa7, 0xca, 0x96, 0x8d, 0xf1, 0x5b, 0x6b, 0xf3, 0x7f,
	0x27, 0xd0, 0x78, 0xfe, 0xa3, 0xc6, 0x2c, 0x9a, 0xaa, 0xfc, 0x9a, 0x87, 0x94, 0x04, 0xaa, 0x5c,
	0x4b, 0xa0, 0x03, 0xd8, 0x08, 0x73, 0x29, 0x31, 0xd3, 0x41, 0x99, 0x5f, 0xd5, 0xf0, 0x5b, 0x77,
	0xce, 0xa3, 0x22, 0xcd, 0x0e, 0x6c, 0x4c, 0xb1, 0x74, 0x5a, 0x3c, 0x84, 0x37, 0x33, 0x3c, 0x9f,
	0x4a, 0xb4, 0x60, 0x12, 0xad, 0x65, 0x78, 0x5e, 0x4a, 0xf2, 0xba, 0x02, 0xab, 0x2c, 0xcf, 0x4e,
	0x35, 0x0e, 0x6e, 0x58, 0xe5, 0x3e, 0x2c, 0xc4, 0x88, 0x91, 0x57, 0xd9, 0xa9, 0xee, 0x2d, 0x1d,
	0xdc, 0x2f, 0x16, 0xf8, 0xe5, 0xb0, 0x9b, 0xbe, 0x36, 0x7b, 0x7b, 0xad, 0x06, 0x49, 0x1b, 0x70,
	0x27, 0x46, 0x1d, 0x9e, 0x79, 0xd5, 0x9d, 0xea, 0x5e, 0x9d, 0xd9, 0x4d, 0xe1, 0xaa, 0x17, 0x8c,
	0xd9, 0xed, 0xe8, 0x3e, 0xdc, 0x15, 0x03, 0x9d, 0x88, 0x4c, 0x79, 0x77, 0x8c, 0x86, 0xcd, 0xe2,
	0x11, 0x2c, 0xcf, 0xbe, 0xb2, 0x5e, 0x36, 0x82, 0xd1, 0x77, 0x81, 0x0e, 0xb8, 0xd4, 0x09, 0x4f,
	0x03, 0x99, 0x8f, 0xc9, 0xd7, 0x0c, 0xf9, 0x37, 0x9c, 0x87, 0xe5, 0x23, 0xfe, 0x9f, 0xc2, 0x03,
	0xa5, 0x85, 0xc4, 0xc0, 0xbc, 0x13, 0x15, 0x24, 0x59, 0x20, 0x9d, 0x82, 0x41, 0x57, 0x44, 0x17,
	0xde, 0xdd, 0x1d, 0xb2, 0xb7, 0xc8, 0xee, 0x19, 0xd0, 0x73, 0x83, 0x79, 0x31, 0xd6, 0xf8, 0x99,
	0x88, 0x2e, 0xe8, 0x03, 0x00, 0x69, 0x35, 0x0b, 0x92, 0xc8, 0x5b, 0x34, 0x02, 0xd7, 0x9d, 0xe5,
	0x45, 0xe4, 0xff, 0x4d, 0x60, 0x6d, 0x2c, 0xad, 0xbb, 0x9a, 0xf7, 0xa1, 0x66, 0x8b, 0xf0, 0xc8,
	0x35, 0x64, 0x73, 0x58, 0xfa, 0x04, 0x16, 0xfb, 0xa8, 0x79, 0xc4, 0x35, 0x9f, 0xf5, 0x80, 0x58,
	0x9e, 0x1d, 0x3b, 0x37, 0x1b, 0x03, 0xe9, 0x87, 0xb0, 0xa4, 0x34, 0xd7, 0xb9, 0x32, 0x23, 0xc0,
	0x34, 0xd2, 0x6a, 0x59, 0x43, 0x53, 0x78, 0xab, 0x23, 0x22, 0x64, 0x60, 0xa1, 0xc3, 0x35, 0xdd,
	0x87, 0x86, 0x0b, 0xb4, 0x13, 0xa4, 0x8f, 0x4a, 0xf1, 0x1e, 0x9a, 0x0e, 0xaa, 0x33, 0x6a, 0x7d,
	0x46, 0x90, 0x63, 0xeb, 0xf1, 0x7f, 0x25, 0xd0, 0x3c, 0x19, 0xeb, 0x7b, 0x8a, 0x3a, 0xbf, 0x69,
	0x33, 0xd1, 0x42, 0x33, 0xd5, 0x6f, 0xd5, 0x2e, 0xe5, 0xcb, 0xb8, 0x33, 0x7d, 0x19, 0x47, 0xb0,
	0x79, 0x85, 0xa1, 0xbb, 0x93, 0xd9, 0x6d, 0x43, 0x66, 0xb7, 0x8d, 0xff, 0x31, 0xac, 0x77, 0x52,
	0xa1, 0xf0, 0x56, 0xa3, 0xc1, 0x6f, 0x42, 0xa3, 0x1c, 0x6d, 0x39, 0xf8, 0xa7, 0xb0, 0xcc, 0x50,
	0xa1, 0x1e, 0xa5, 0xbb, 0x0f, 0xf5, 0x50, 0x64, 0x9a, 0x27, 0x19, 0xda, 0x56, 0xa9, 0xb3, 0x89,
	0x61, 0x78, 0x98, 0xfb, 0x08, 0xc5, 0x49, 0xaa, 0x51, 0x2a, 0xa7, 0xdb, 0x8a, 0xb5, 0x7e, 0x66,
	0x8d, 0xfe, 0x1a, 0xac, 0xb8, 0xa4, 0xee, 0x94, 0x8f, 0x80, 0x7e, 0x91, 0x28, 0x7d, 0x68, 0x50,
	0xea, 0x86, 0xd4, 0x7f, 0x26, 0xb0, 0x5e, 0x8a, 0x76, 0xf2, 0x7d, 0x02, 0xcb, 0xa9, 0x08, 0x79,
	0x1a, 0xd8, 0xc3, 0x67, 0x35, 0xb6, 0x0d, 0x79, 0x3a, 0xfe, 0x60, 0xb2, 0x25, 0x13, 0x61, 0xcd,
	0xf4, 0x29, 0xac, 0x48, 0xec, 0x0b, 0x8d, 0xa3, 0x0c, 0x95, 0x6b, 0x64, 0x58, 0xb6, 0x21, 0xd6,
	0x3e, 0xfc, 0x56, 0xad, 0x1f, 0xf3, 0x97, 0xd8, 0xe1, 0x69, 0xca, 0xbb, 0x29, 0xde, 0xb0, 0xfb,
	0x3e, 0x98, 0x8c, 0x1a, 0xfb, 0xbc, 0xde, 0x2a, 0x7d, 0x9f, 0x5c, 0xd2, 0x2b, 0xf3, 0xa6, 0xdc,
	0x72, 0xd5, 0xe9, 0x96, 0x6b, 0x41, 0xa3, 0xcc, 0xc9, 0x09, 0xd6, 0x84, 0x5a, 0x81, 0x4c, 0x95,
	0xb9, 0x9d, 0xff, 0x0b, 0x01, 0xca, 0xf2, 0xec, 0x96, 0x35, 0x4c, 0xb2, 0x56, 0x8a, 0x59, 0xe9,
	0x23, 0xf7, 0xb2, 0xaa, 0x46, 0xd4, 0xd2, 0xdc, 0xb8, 0x3a, 0xa1, 0xcb, 0x15, 0x2d, 0x4c, 0x57,
	0x74, 0x01, 0xeb, 0x25, 0x82, 0xae, 0xa0, 0xf7, 0x46, 0x0f, 0x95, 0xfc, 0xf7, 0x19, 0xee, 0x05,
	0xdf, 0x66, 0x9a, 0xf9, 0xdf, 0x41, 0x93, 0x61, 0x8a, 0x5c, 0xe1, 0xff, 0xab, 0x8f, 0x7f, 0x0f,
	0x36, 0xaf, 0x24, 0x76, 0x33, 0xfe, 0x37, 0xf2, 0xc7, 0xe5, 0x36, 0xf9, 0xf3, 0x72, 0x9b, 0xbc,
	0xbe, 0xdc, 0x26, 0x7f, 0x5d, 0x6e, 0x13, 0xd8, 0x12, 0xb2, 0x57, 0x24, 0x1b, 0x25, 0x4a, 0xcb,
	0x3c, 0xd3, 0x49, 0x1f, 0x9f, 0x79, 0x87, 0xc3, 0x8d, 0xe9, 0xcf, 0x88, 0x59, 0x9b, 0xa9, 0x5b,
	0x9d, 0x90, 0xef, 0xbf, 0xe9, 0x25, 0xfa, 0x2c, 0xef, 0xb6, 0x42, 0xd1, 0x6f, 0x17, 0x7e, 0xc2,
	0x66, 0x2f, 0x7b, 0x62, 0xea, 0xef, 0x2c, 0x36, 0xff, 0x71, 0x12, 0x03, 0x63, 0x51, 0x41, 0x4f,
	0xd8, 0xd5, 0x3f, 0x84, 0x74, 0x6b, 0x66, 0xf5, 0xe4, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x17,
	0xea, 0x31, 0x35, 0xe4, 0x0a, 0x00, 0x00,
}

func (m *CreateSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GraphDef != nil {
		{
			size, err := m.GraphDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GraphVersion != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.GraphVersion))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtendSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtendSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtendSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CurrentGraphVersion != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.CurrentGraphVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.GraphDef != nil {
		{
			size, err := m.GraphDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtendSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtendSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtendSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NewGraphVersion != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.NewGraphVersion))
		i--
		dAtA[i] = 0x20
	}
	return len(dAtA) - i, nil
}

func (m *RunStepRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunStepRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunStepRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestId != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x40
	}
	if m.StoreErrorsInResponseBody {
		i--
		if m.StoreErrorsInResponseBody {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.PartialRunHandle) > 0 {
		i -= len(m.PartialRunHandle)
		copy(dAtA[i:], m.PartialRunHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.PartialRunHandle)))
		i--
		dAtA[i] = 0x32
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Target) > 0 {
		for iNdEx := len(m.Target) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Target[iNdEx])
			copy(dAtA[i:], m.Target[iNdEx])
			i = encodeVarintMaster(dAtA, i, uint64(len(m.Target[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Fetch) > 0 {
		for iNdEx := len(m.Fetch) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fetch[iNdEx])
			copy(dAtA[i:], m.Fetch[iNdEx])
			i = encodeVarintMaster(dAtA, i, uint64(len(m.Fetch[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Feed) > 0 {
		for iNdEx := len(m.Feed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Feed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunStepResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunStepResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunStepResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StatusErrorMessage) > 0 {
		i -= len(m.StatusErrorMessage)
		copy(dAtA[i:], m.StatusErrorMessage)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.StatusErrorMessage)))
		i--
		dAtA[i] = 0x22
	}
	if m.StatusCode != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x18
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tensor) > 0 {
		for iNdEx := len(m.Tensor) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tensor[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PartialRunSetupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartialRunSetupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartialRunSetupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestId != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Target) > 0 {
		for iNdEx := len(m.Target) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Target[iNdEx])
			copy(dAtA[i:], m.Target[iNdEx])
			i = encodeVarintMaster(dAtA, i, uint64(len(m.Target[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Fetch) > 0 {
		for iNdEx := len(m.Fetch) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fetch[iNdEx])
			copy(dAtA[i:], m.Fetch[iNdEx])
			i = encodeVarintMaster(dAtA, i, uint64(len(m.Fetch[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Feed) > 0 {
		for iNdEx := len(m.Feed) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Feed[iNdEx])
			copy(dAtA[i:], m.Feed[iNdEx])
			i = encodeVarintMaster(dAtA, i, uint64(len(m.Feed[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartialRunSetupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartialRunSetupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartialRunSetupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartialRunHandle) > 0 {
		i -= len(m.PartialRunHandle)
		copy(dAtA[i:], m.PartialRunHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.PartialRunHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloseSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloseSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeviceFilters) > 0 {
		for iNdEx := len(m.DeviceFilters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DeviceFilters[iNdEx])
			copy(dAtA[i:], m.DeviceFilters[iNdEx])
			i = encodeVarintMaster(dAtA, i, uint64(len(m.DeviceFilters[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Container) > 0 {
		for iNdEx := len(m.Container) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Container[iNdEx])
			copy(dAtA[i:], m.Container[iNdEx])
			i = encodeVarintMaster(dAtA, i, uint64(len(m.Container[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ListDevicesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDevicesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDevicesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListDevicesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDevicesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDevicesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RemoteDevice) > 0 {
		for iNdEx := len(m.RemoteDevice) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoteDevice[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.LocalDevice) > 0 {
		for iNdEx := len(m.LocalDevice) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalDevice[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MakeCallableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MakeCallableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MakeCallableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestId != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x18
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MakeCallableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MakeCallableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MakeCallableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Handle != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.Handle))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RunCallableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunCallableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunCallableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestId != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Feed) > 0 {
		for iNdEx := len(m.Feed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Feed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Handle != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.Handle))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunCallableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunCallableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunCallableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMaster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fetch) > 0 {
		for iNdEx := len(m.Fetch) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fetch[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReleaseCallableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReleaseCallableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReleaseCallableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Handle != 0 {
		i = encodeVarintMaster(dAtA, i, uint64(m.Handle))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SessionHandle) > 0 {
		i -= len(m.SessionHandle)
		copy(dAtA[i:], m.SessionHandle)
		i = encodeVarintMaster(dAtA, i, uint64(len(m.SessionHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReleaseCallableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReleaseCallableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReleaseCallableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintMaster(dAtA []byte, offset int, v uint64) int {
	offset -= sovMaster(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CreateSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GraphDef != nil {
		l = m.GraphDef.Size()
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovMaster(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.GraphVersion != 0 {
		n += 1 + sovMaster(uint64(m.GraphVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtendSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.GraphDef != nil {
		l = m.GraphDef.Size()
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.CurrentGraphVersion != 0 {
		n += 1 + sovMaster(uint64(m.CurrentGraphVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtendSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewGraphVersion != 0 {
		n += 1 + sovMaster(uint64(m.NewGraphVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunStepRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if len(m.Feed) > 0 {
		for _, e := range m.Feed {
			l = e.Size()
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if len(m.Fetch) > 0 {
		for _, s := range m.Fetch {
			l = len(s)
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if len(m.Target) > 0 {
		for _, s := range m.Target {
			l = len(s)
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovMaster(uint64(l))
	}
	l = len(m.PartialRunHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.StoreErrorsInResponseBody {
		n += 2
	}
	if m.RequestId != 0 {
		n += 1 + sovMaster(uint64(m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunStepResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tensor) > 0 {
		for _, e := range m.Tensor {
			l = e.Size()
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.StatusCode != 0 {
		n += 1 + sovMaster(uint64(m.StatusCode))
	}
	l = len(m.StatusErrorMessage)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartialRunSetupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if len(m.Feed) > 0 {
		for _, s := range m.Feed {
			l = len(s)
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if len(m.Fetch) > 0 {
		for _, s := range m.Fetch {
			l = len(s)
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if len(m.Target) > 0 {
		for _, s := range m.Target {
			l = len(s)
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if m.RequestId != 0 {
		n += 1 + sovMaster(uint64(m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartialRunSetupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartialRunHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloseSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloseSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Container) > 0 {
		for _, s := range m.Container {
			l = len(s)
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if len(m.DeviceFilters) > 0 {
		for _, s := range m.DeviceFilters {
			l = len(s)
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDevicesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDevicesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LocalDevice) > 0 {
		for _, e := range m.LocalDevice {
			l = e.Size()
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if len(m.RemoteDevice) > 0 {
		for _, e := range m.RemoteDevice {
			l = e.Size()
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MakeCallableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovMaster(uint64(m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MakeCallableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Handle != 0 {
		n += 1 + sovMaster(uint64(m.Handle))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunCallableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.Handle != 0 {
		n += 1 + sovMaster(uint64(m.Handle))
	}
	if len(m.Feed) > 0 {
		for _, e := range m.Feed {
			l = e.Size()
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if m.RequestId != 0 {
		n += 1 + sovMaster(uint64(m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunCallableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fetch) > 0 {
		for _, e := range m.Fetch {
			l = e.Size()
			n += 1 + l + sovMaster(uint64(l))
		}
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReleaseCallableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovMaster(uint64(l))
	}
	if m.Handle != 0 {
		n += 1 + sovMaster(uint64(m.Handle))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReleaseCallableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMaster(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMaster(x uint64) (n int) {
	return sovMaster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreateSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphDef == nil {
				m.GraphDef = &graph_go_proto.GraphDef{}
			}
			if err := m.GraphDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &ConfigProto{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphVersion", wireType)
			}
			m.GraphVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GraphVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtendSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphDef == nil {
				m.GraphDef = &graph_go_proto.GraphDef{}
			}
			if err := m.GraphDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentGraphVersion", wireType)
			}
			m.CurrentGraphVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentGraphVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtendSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewGraphVersion", wireType)
			}
			m.NewGraphVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewGraphVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunStepRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunStepRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunStepRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Feed = append(m.Feed, &NamedTensorProto{})
			if err := m.Feed[len(m.Feed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fetch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fetch = append(m.Fetch, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &RunOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialRunHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartialRunHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreErrorsInResponseBody", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StoreErrorsInResponseBody = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunStepResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunStepResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunStepResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tensor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tensor = append(m.Tensor, &NamedTensorProto{})
			if err := m.Tensor[len(m.Tensor)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &RunMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartialRunSetupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialRunSetupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialRunSetupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Feed = append(m.Feed, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fetch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fetch = append(m.Fetch, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartialRunSetupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialRunSetupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialRunSetupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialRunHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartialRunHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = append(m.Container, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceFilters = append(m.DeviceFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDevicesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDevicesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDevicesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDevicesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDevicesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDevicesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalDevice = append(m.LocalDevice, &device_attributes_go_proto.DeviceAttributes{})
			if err := m.LocalDevice[len(m.LocalDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteDevice = append(m.RemoteDevice, &device_attributes_go_proto.DeviceAttributes{})
			if err := m.RemoteDevice[len(m.RemoteDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MakeCallableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MakeCallableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MakeCallableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &CallableOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MakeCallableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MakeCallableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MakeCallableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Handle |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunCallableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunCallableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunCallableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Handle |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Feed = append(m.Feed, &tensor_go_proto.TensorProto{})
			if err := m.Feed[len(m.Feed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunCallableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunCallableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunCallableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fetch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fetch = append(m.Fetch, &tensor_go_proto.TensorProto{})
			if err := m.Fetch[len(m.Fetch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &RunMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReleaseCallableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReleaseCallableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReleaseCallableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Handle |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReleaseCallableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReleaseCallableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReleaseCallableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMaster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMaster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMaster
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMaster
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMaster
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMaster        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMaster          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMaster = fmt.Errorf("proto: unexpected end of group")
)
