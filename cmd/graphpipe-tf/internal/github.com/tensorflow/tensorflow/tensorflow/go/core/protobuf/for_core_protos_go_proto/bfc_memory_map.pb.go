// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/bfc_memory_map.proto

package for_core_protos_go_proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Some of the data from AllocatorStats
type MemAllocatorStats struct {
	NumAllocs            int64    `protobuf:"varint,1,opt,name=num_allocs,json=numAllocs,proto3" json:"num_allocs,omitempty"`
	BytesInUse           int64    `protobuf:"varint,2,opt,name=bytes_in_use,json=bytesInUse,proto3" json:"bytes_in_use,omitempty"`
	PeakBytesInUse       int64    `protobuf:"varint,3,opt,name=peak_bytes_in_use,json=peakBytesInUse,proto3" json:"peak_bytes_in_use,omitempty"`
	LargestAllocSize     int64    `protobuf:"varint,4,opt,name=largest_alloc_size,json=largestAllocSize,proto3" json:"largest_alloc_size,omitempty"`
	FragmentationMetric  float32  `protobuf:"fixed32,5,opt,name=fragmentation_metric,json=fragmentationMetric,proto3" json:"fragmentation_metric,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemAllocatorStats) Reset()         { *m = MemAllocatorStats{} }
func (m *MemAllocatorStats) String() string { return proto.CompactTextString(m) }
func (*MemAllocatorStats) ProtoMessage()    {}
func (*MemAllocatorStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdf22777007c1f3d, []int{0}
}
func (m *MemAllocatorStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemAllocatorStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MemAllocatorStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemAllocatorStats.Merge(m, src)
}
func (m *MemAllocatorStats) XXX_Size() int {
	return m.Size()
}
func (m *MemAllocatorStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MemAllocatorStats.DiscardUnknown(m)
}

var xxx_messageInfo_MemAllocatorStats proto.InternalMessageInfo

func (m *MemAllocatorStats) GetNumAllocs() int64 {
	if m != nil {
		return m.NumAllocs
	}
	return 0
}

func (m *MemAllocatorStats) GetBytesInUse() int64 {
	if m != nil {
		return m.BytesInUse
	}
	return 0
}

func (m *MemAllocatorStats) GetPeakBytesInUse() int64 {
	if m != nil {
		return m.PeakBytesInUse
	}
	return 0
}

func (m *MemAllocatorStats) GetLargestAllocSize() int64 {
	if m != nil {
		return m.LargestAllocSize
	}
	return 0
}

func (m *MemAllocatorStats) GetFragmentationMetric() float32 {
	if m != nil {
		return m.FragmentationMetric
	}
	return 0
}

type MemChunk struct {
	Address              uint64   `protobuf:"varint,1,opt,name=address,proto3" json:"address,omitempty"`
	Size_                int64    `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	RequestedSize        int64    `protobuf:"varint,3,opt,name=requested_size,json=requestedSize,proto3" json:"requested_size,omitempty"`
	Bin                  int32    `protobuf:"varint,4,opt,name=bin,proto3" json:"bin,omitempty"`
	OpName               string   `protobuf:"bytes,5,opt,name=op_name,json=opName,proto3" json:"op_name,omitempty"`
	FreedAtCount         uint64   `protobuf:"varint,6,opt,name=freed_at_count,json=freedAtCount,proto3" json:"freed_at_count,omitempty"`
	ActionCount          uint64   `protobuf:"varint,7,opt,name=action_count,json=actionCount,proto3" json:"action_count,omitempty"`
	InUse                bool     `protobuf:"varint,8,opt,name=in_use,json=inUse,proto3" json:"in_use,omitempty"`
	StepId               uint64   `protobuf:"varint,9,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemChunk) Reset()         { *m = MemChunk{} }
func (m *MemChunk) String() string { return proto.CompactTextString(m) }
func (*MemChunk) ProtoMessage()    {}
func (*MemChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdf22777007c1f3d, []int{1}
}
func (m *MemChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MemChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemChunk.Merge(m, src)
}
func (m *MemChunk) XXX_Size() int {
	return m.Size()
}
func (m *MemChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_MemChunk.DiscardUnknown(m)
}

var xxx_messageInfo_MemChunk proto.InternalMessageInfo

func (m *MemChunk) GetAddress() uint64 {
	if m != nil {
		return m.Address
	}
	return 0
}

func (m *MemChunk) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *MemChunk) GetRequestedSize() int64 {
	if m != nil {
		return m.RequestedSize
	}
	return 0
}

func (m *MemChunk) GetBin() int32 {
	if m != nil {
		return m.Bin
	}
	return 0
}

func (m *MemChunk) GetOpName() string {
	if m != nil {
		return m.OpName
	}
	return ""
}

func (m *MemChunk) GetFreedAtCount() uint64 {
	if m != nil {
		return m.FreedAtCount
	}
	return 0
}

func (m *MemChunk) GetActionCount() uint64 {
	if m != nil {
		return m.ActionCount
	}
	return 0
}

func (m *MemChunk) GetInUse() bool {
	if m != nil {
		return m.InUse
	}
	return false
}

func (m *MemChunk) GetStepId() uint64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

type BinSummary struct {
	Bin                  int32    `protobuf:"varint,1,opt,name=bin,proto3" json:"bin,omitempty"`
	TotalBytesInUse      int64    `protobuf:"varint,2,opt,name=total_bytes_in_use,json=totalBytesInUse,proto3" json:"total_bytes_in_use,omitempty"`
	TotalBytesInBin      int64    `protobuf:"varint,3,opt,name=total_bytes_in_bin,json=totalBytesInBin,proto3" json:"total_bytes_in_bin,omitempty"`
	TotalChunksInUse     int64    `protobuf:"varint,4,opt,name=total_chunks_in_use,json=totalChunksInUse,proto3" json:"total_chunks_in_use,omitempty"`
	TotalChunksInBin     int64    `protobuf:"varint,5,opt,name=total_chunks_in_bin,json=totalChunksInBin,proto3" json:"total_chunks_in_bin,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinSummary) Reset()         { *m = BinSummary{} }
func (m *BinSummary) String() string { return proto.CompactTextString(m) }
func (*BinSummary) ProtoMessage()    {}
func (*BinSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdf22777007c1f3d, []int{2}
}
func (m *BinSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BinSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinSummary.Merge(m, src)
}
func (m *BinSummary) XXX_Size() int {
	return m.Size()
}
func (m *BinSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_BinSummary.DiscardUnknown(m)
}

var xxx_messageInfo_BinSummary proto.InternalMessageInfo

func (m *BinSummary) GetBin() int32 {
	if m != nil {
		return m.Bin
	}
	return 0
}

func (m *BinSummary) GetTotalBytesInUse() int64 {
	if m != nil {
		return m.TotalBytesInUse
	}
	return 0
}

func (m *BinSummary) GetTotalBytesInBin() int64 {
	if m != nil {
		return m.TotalBytesInBin
	}
	return 0
}

func (m *BinSummary) GetTotalChunksInUse() int64 {
	if m != nil {
		return m.TotalChunksInUse
	}
	return 0
}

func (m *BinSummary) GetTotalChunksInBin() int64 {
	if m != nil {
		return m.TotalChunksInBin
	}
	return 0
}

type SnapShot struct {
	ActionCount          uint64   `protobuf:"varint,1,opt,name=action_count,json=actionCount,proto3" json:"action_count,omitempty"`
	Size_                int64    `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapShot) Reset()         { *m = SnapShot{} }
func (m *SnapShot) String() string { return proto.CompactTextString(m) }
func (*SnapShot) ProtoMessage()    {}
func (*SnapShot) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdf22777007c1f3d, []int{3}
}
func (m *SnapShot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapShot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SnapShot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapShot.Merge(m, src)
}
func (m *SnapShot) XXX_Size() int {
	return m.Size()
}
func (m *SnapShot) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapShot.DiscardUnknown(m)
}

var xxx_messageInfo_SnapShot proto.InternalMessageInfo

func (m *SnapShot) GetActionCount() uint64 {
	if m != nil {
		return m.ActionCount
	}
	return 0
}

func (m *SnapShot) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type MemoryDump struct {
	AllocatorName        string             `protobuf:"bytes,1,opt,name=allocator_name,json=allocatorName,proto3" json:"allocator_name,omitempty"`
	BinSummary           []*BinSummary      `protobuf:"bytes,2,rep,name=bin_summary,json=binSummary,proto3" json:"bin_summary,omitempty"`
	Chunk                []*MemChunk        `protobuf:"bytes,3,rep,name=chunk,proto3" json:"chunk,omitempty"`
	SnapShot             []*SnapShot        `protobuf:"bytes,4,rep,name=snap_shot,json=snapShot,proto3" json:"snap_shot,omitempty"`
	Stats                *MemAllocatorStats `protobuf:"bytes,5,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MemoryDump) Reset()         { *m = MemoryDump{} }
func (m *MemoryDump) String() string { return proto.CompactTextString(m) }
func (*MemoryDump) ProtoMessage()    {}
func (*MemoryDump) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdf22777007c1f3d, []int{4}
}
func (m *MemoryDump) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryDump) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MemoryDump) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryDump.Merge(m, src)
}
func (m *MemoryDump) XXX_Size() int {
	return m.Size()
}
func (m *MemoryDump) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryDump.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryDump proto.InternalMessageInfo

func (m *MemoryDump) GetAllocatorName() string {
	if m != nil {
		return m.AllocatorName
	}
	return ""
}

func (m *MemoryDump) GetBinSummary() []*BinSummary {
	if m != nil {
		return m.BinSummary
	}
	return nil
}

func (m *MemoryDump) GetChunk() []*MemChunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *MemoryDump) GetSnapShot() []*SnapShot {
	if m != nil {
		return m.SnapShot
	}
	return nil
}

func (m *MemoryDump) GetStats() *MemAllocatorStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func init() {
	proto.RegisterType((*MemAllocatorStats)(nil), "tensorflow.MemAllocatorStats")
	proto.RegisterType((*MemChunk)(nil), "tensorflow.MemChunk")
	proto.RegisterType((*BinSummary)(nil), "tensorflow.BinSummary")
	proto.RegisterType((*SnapShot)(nil), "tensorflow.SnapShot")
	proto.RegisterType((*MemoryDump)(nil), "tensorflow.MemoryDump")
}

func init() {
	proto.RegisterFile("tensorflow/core/protobuf/bfc_memory_map.proto", fileDescriptor_fdf22777007c1f3d)
}

var fileDescriptor_fdf22777007c1f3d = []byte{
	// 619 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x94, 0x4d, 0x4f, 0x1b, 0x3d,
	0x10, 0xc7, 0xb5, 0x79, 0xcf, 0x04, 0x78, 0xc0, 0xf0, 0x94, 0xbd, 0x10, 0xa5, 0x51, 0x2b, 0xa5,
	0x2f, 0x24, 0x02, 0x0e, 0x3d, 0x13, 0x7a, 0xe1, 0x90, 0x1e, 0x36, 0xe2, 0xd2, 0x8b, 0xe5, 0xdd,
	0x38, 0x89, 0x45, 0x6c, 0x6f, 0x6d, 0xaf, 0x2a, 0x38, 0x55, 0xea, 0x97, 0xeb, 0xb1, 0xa7, 0xaa,
	0x47, 0x94, 0x4f, 0x52, 0xed, 0x38, 0x61, 0x81, 0xe4, 0x14, 0xef, 0x7f, 0x7e, 0x3b, 0x9e, 0x99,
	0x7f, 0x66, 0xe1, 0xd4, 0x71, 0x65, 0xb5, 0x99, 0x2e, 0xf4, 0xf7, 0x41, 0xa2, 0x0d, 0x1f, 0xa4,
	0x46, 0x3b, 0x1d, 0x67, 0xd3, 0x41, 0x3c, 0x4d, 0xa8, 0xe4, 0x52, 0x9b, 0x3b, 0x2a, 0x59, 0xda,
	0x47, 0x9d, 0x40, 0x81, 0x77, 0x1f, 0x02, 0x38, 0x18, 0x71, 0x79, 0xb9, 0x58, 0xe8, 0x84, 0x39,
	0x6d, 0xc6, 0x8e, 0x39, 0x4b, 0x4e, 0x00, 0x54, 0x26, 0x29, 0xcb, 0x55, 0x1b, 0x06, 0x9d, 0xa0,
	0x57, 0x8e, 0x9a, 0x2a, 0xf3, 0x98, 0x25, 0x1d, 0xd8, 0x89, 0xef, 0x1c, 0xb7, 0x54, 0x28, 0x9a,
	0x59, 0x1e, 0x96, 0x10, 0x00, 0xd4, 0xae, 0xd5, 0x8d, 0xe5, 0xe4, 0x1d, 0x1c, 0xa4, 0x9c, 0xdd,
	0xd2, 0x67, 0x58, 0x19, 0xb1, 0xbd, 0x3c, 0x30, 0x2c, 0xd0, 0x8f, 0x40, 0x16, 0xcc, 0xcc, 0xb8,
	0x75, 0xfe, 0x3e, 0x6a, 0xc5, 0x3d, 0x0f, 0x2b, 0xc8, 0xee, 0xaf, 0x22, 0x78, 0xef, 0x58, 0xdc,
	0x73, 0x72, 0x06, 0x47, 0x53, 0xc3, 0x66, 0x92, 0x2b, 0xc7, 0x9c, 0xd0, 0x8a, 0x4a, 0xee, 0x8c,
	0x48, 0xc2, 0x6a, 0x27, 0xe8, 0x95, 0xa2, 0xc3, 0x67, 0xb1, 0x11, 0x86, 0xba, 0x3f, 0x4b, 0xd0,
	0x18, 0x71, 0x79, 0x35, 0xcf, 0xd4, 0x2d, 0x09, 0xa1, 0xce, 0x26, 0x13, 0xc3, 0xad, 0x6f, 0xab,
	0x12, 0xad, 0x1f, 0x09, 0x81, 0x0a, 0xde, 0xec, 0x9b, 0xc1, 0x33, 0x79, 0x0b, 0x7b, 0x86, 0x7f,
	0xcb, 0xb8, 0x75, 0x7c, 0xe2, 0xeb, 0xf2, 0x3d, 0xec, 0x3e, 0xaa, 0x58, 0xd4, 0x3e, 0x94, 0x63,
	0xa1, 0xb0, 0xe6, 0x6a, 0x94, 0x1f, 0xc9, 0x31, 0xd4, 0x75, 0x4a, 0x15, 0x93, 0x1c, 0x2b, 0x6b,
	0x46, 0x35, 0x9d, 0x7e, 0x61, 0x92, 0x93, 0x37, 0xb0, 0x37, 0x35, 0x9c, 0x4f, 0x28, 0x73, 0x34,
	0xd1, 0x99, 0x72, 0x61, 0x0d, 0xcb, 0xd8, 0x41, 0xf5, 0xd2, 0x5d, 0xe5, 0x1a, 0x79, 0x0d, 0x3b,
	0x2c, 0xc1, 0xf6, 0x3c, 0x53, 0x47, 0xa6, 0xe5, 0x35, 0x8f, 0xfc, 0x0f, 0xb5, 0xd5, 0x58, 0x1b,
	0x9d, 0xa0, 0xd7, 0x88, 0xaa, 0x02, 0xa7, 0x79, 0x0c, 0x75, 0xeb, 0x78, 0x4a, 0xc5, 0x24, 0x6c,
	0xe2, 0x4b, 0xb5, 0xfc, 0xf1, 0x7a, 0xd2, 0xfd, 0x13, 0x00, 0x0c, 0x85, 0x1a, 0x67, 0x52, 0x32,
	0x73, 0xb7, 0x2e, 0x39, 0x28, 0x4a, 0xfe, 0x00, 0xc4, 0x69, 0xc7, 0x16, 0x74, 0x8b, 0xb5, 0xff,
	0x61, 0xe4, 0x89, 0x69, 0x9b, 0x70, 0x9e, 0xad, 0xbc, 0x09, 0x0f, 0x85, 0x22, 0xa7, 0x70, 0xe8,
	0xe1, 0x24, 0xb7, 0xe0, 0x31, 0xf5, 0xca, 0x62, 0x0c, 0xa1, 0x39, 0xab, 0xdc, 0x5b, 0xf0, 0x3c,
	0x79, 0x75, 0x0b, 0x3e, 0x14, 0xaa, 0x7b, 0x09, 0x8d, 0xb1, 0x62, 0xe9, 0x78, 0xae, 0x37, 0xe7,
	0x16, 0x6c, 0xce, 0x6d, 0x8b, 0xcd, 0xdd, 0x1f, 0x25, 0x80, 0x11, 0x6e, 0xc9, 0xe7, 0x4c, 0xa6,
	0xb9, 0xeb, 0x6c, 0xbd, 0x0f, 0xde, 0xc3, 0x00, 0x3d, 0xdc, 0x7d, 0x54, 0xd1, 0xca, 0x4f, 0xd0,
	0x8a, 0x85, 0xa2, 0xd6, 0x4f, 0x34, 0x2c, 0x75, 0xca, 0xbd, 0xd6, 0xf9, 0xab, 0x7e, 0xb1, 0x5c,
	0xfd, 0x62, 0xde, 0x11, 0xc4, 0xc5, 0xec, 0xdf, 0x43, 0x15, 0x5b, 0x0b, 0xcb, 0xf8, 0xca, 0xd1,
	0xd3, 0x57, 0xd6, 0x7f, 0xd4, 0xc8, 0x23, 0xe4, 0x0c, 0x9a, 0x56, 0xb1, 0x94, 0xda, 0xb9, 0x76,
	0x61, 0x65, 0x93, 0x5f, 0xb7, 0x1e, 0x35, 0xec, 0x7a, 0x08, 0x17, 0x50, 0xb5, 0xf9, 0x16, 0xe3,
	0xc4, 0x5a, 0xe7, 0x27, 0x2f, 0xd2, 0x3f, 0x5f, 0xf5, 0xc8, 0xb3, 0xc3, 0xd9, 0xaf, 0x65, 0x3b,
	0xf8, 0xbd, 0x6c, 0x07, 0x7f, 0x97, 0xed, 0xe0, 0x61, 0xd9, 0x0e, 0xbe, 0xde, 0xcc, 0x84, 0x9b,
	0x67, 0x71, 0x3f, 0xd1, 0x72, 0xf0, 0xe4, 0xfb, 0xb2, 0xfd, 0x38, 0xd3, 0x2f, 0x3e, 0x3c, 0x53,
	0x6d, 0x68, 0xae, 0x50, 0x54, 0x2c, 0x9d, 0x69, 0x7f, 0x8a, 0x6b, 0xf8, 0x73, 0xf1, 0x2f, 0x00,
	0x00, 0xff, 0xff, 0x9f, 0x72, 0xe0, 0xb0, 0xb4, 0x04, 0x00, 0x00,
}

func (m *MemAllocatorStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemAllocatorStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemAllocatorStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FragmentationMetric != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FragmentationMetric))))
		i--
		dAtA[i] = 0x2d
	}
	if m.LargestAllocSize != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.LargestAllocSize))
		i--
		dAtA[i] = 0x20
	}
	if m.PeakBytesInUse != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.PeakBytesInUse))
		i--
		dAtA[i] = 0x18
	}
	if m.BytesInUse != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.BytesInUse))
		i--
		dAtA[i] = 0x10
	}
	if m.NumAllocs != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.NumAllocs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StepId != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.StepId))
		i--
		dAtA[i] = 0x48
	}
	if m.InUse {
		i--
		if m.InUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ActionCount != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.ActionCount))
		i--
		dAtA[i] = 0x38
	}
	if m.FreedAtCount != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.FreedAtCount))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OpName) > 0 {
		i -= len(m.OpName)
		copy(dAtA[i:], m.OpName)
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(len(m.OpName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Bin != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.Bin))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestedSize != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.RequestedSize))
		i--
		dAtA[i] = 0x18
	}
	if m.Size_ != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Address != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.Address))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BinSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalChunksInBin != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.TotalChunksInBin))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalChunksInUse != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.TotalChunksInUse))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalBytesInBin != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.TotalBytesInBin))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalBytesInUse != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.TotalBytesInUse))
		i--
		dAtA[i] = 0x10
	}
	if m.Bin != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.Bin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SnapShot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapShot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapShot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Size_ != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.ActionCount != 0 {
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(m.ActionCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemoryDump) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryDump) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryDump) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBfcMemoryMap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SnapShot) > 0 {
		for iNdEx := len(m.SnapShot) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SnapShot[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBfcMemoryMap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Chunk) > 0 {
		for iNdEx := len(m.Chunk) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunk[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBfcMemoryMap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BinSummary) > 0 {
		for iNdEx := len(m.BinSummary) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BinSummary[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBfcMemoryMap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AllocatorName) > 0 {
		i -= len(m.AllocatorName)
		copy(dAtA[i:], m.AllocatorName)
		i = encodeVarintBfcMemoryMap(dAtA, i, uint64(len(m.AllocatorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBfcMemoryMap(dAtA []byte, offset int, v uint64) int {
	offset -= sovBfcMemoryMap(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MemAllocatorStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumAllocs != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.NumAllocs))
	}
	if m.BytesInUse != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.BytesInUse))
	}
	if m.PeakBytesInUse != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.PeakBytesInUse))
	}
	if m.LargestAllocSize != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.LargestAllocSize))
	}
	if m.FragmentationMetric != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.Address))
	}
	if m.Size_ != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.Size_))
	}
	if m.RequestedSize != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.RequestedSize))
	}
	if m.Bin != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.Bin))
	}
	l = len(m.OpName)
	if l > 0 {
		n += 1 + l + sovBfcMemoryMap(uint64(l))
	}
	if m.FreedAtCount != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.FreedAtCount))
	}
	if m.ActionCount != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.ActionCount))
	}
	if m.InUse {
		n += 2
	}
	if m.StepId != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.StepId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bin != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.Bin))
	}
	if m.TotalBytesInUse != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.TotalBytesInUse))
	}
	if m.TotalBytesInBin != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.TotalBytesInBin))
	}
	if m.TotalChunksInUse != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.TotalChunksInUse))
	}
	if m.TotalChunksInBin != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.TotalChunksInBin))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapShot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionCount != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.ActionCount))
	}
	if m.Size_ != 0 {
		n += 1 + sovBfcMemoryMap(uint64(m.Size_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryDump) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AllocatorName)
	if l > 0 {
		n += 1 + l + sovBfcMemoryMap(uint64(l))
	}
	if len(m.BinSummary) > 0 {
		for _, e := range m.BinSummary {
			l = e.Size()
			n += 1 + l + sovBfcMemoryMap(uint64(l))
		}
	}
	if len(m.Chunk) > 0 {
		for _, e := range m.Chunk {
			l = e.Size()
			n += 1 + l + sovBfcMemoryMap(uint64(l))
		}
	}
	if len(m.SnapShot) > 0 {
		for _, e := range m.SnapShot {
			l = e.Size()
			n += 1 + l + sovBfcMemoryMap(uint64(l))
		}
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovBfcMemoryMap(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBfcMemoryMap(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBfcMemoryMap(x uint64) (n int) {
	return sovBfcMemoryMap(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MemAllocatorStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBfcMemoryMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemAllocatorStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemAllocatorStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAllocs", wireType)
			}
			m.NumAllocs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAllocs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesInUse", wireType)
			}
			m.BytesInUse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesInUse |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakBytesInUse", wireType)
			}
			m.PeakBytesInUse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakBytesInUse |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargestAllocSize", wireType)
			}
			m.LargestAllocSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LargestAllocSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentationMetric", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.FragmentationMetric = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipBfcMemoryMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBfcMemoryMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			m.Address = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Address |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedSize", wireType)
			}
			m.RequestedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bin", wireType)
			}
			m.Bin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreedAtCount", wireType)
			}
			m.FreedAtCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreedAtCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionCount", wireType)
			}
			m.ActionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InUse = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBfcMemoryMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBfcMemoryMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bin", wireType)
			}
			m.Bin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytesInUse", wireType)
			}
			m.TotalBytesInUse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytesInUse |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytesInBin", wireType)
			}
			m.TotalBytesInBin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytesInBin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalChunksInUse", wireType)
			}
			m.TotalChunksInUse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalChunksInUse |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalChunksInBin", wireType)
			}
			m.TotalChunksInBin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalChunksInBin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBfcMemoryMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapShot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBfcMemoryMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapShot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapShot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionCount", wireType)
			}
			m.ActionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBfcMemoryMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryDump) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBfcMemoryMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryDump: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryDump: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocatorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinSummary = append(m.BinSummary, &BinSummary{})
			if err := m.BinSummary[len(m.BinSummary)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunk = append(m.Chunk, &MemChunk{})
			if err := m.Chunk[len(m.Chunk)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapShot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapShot = append(m.SnapShot, &SnapShot{})
			if err := m.SnapShot[len(m.SnapShot)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &MemAllocatorStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBfcMemoryMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBfcMemoryMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBfcMemoryMap(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBfcMemoryMap
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBfcMemoryMap
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBfcMemoryMap
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBfcMemoryMap
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBfcMemoryMap
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBfcMemoryMap        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBfcMemoryMap          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBfcMemoryMap = fmt.Errorf("proto: unexpected end of group")
)
